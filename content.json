{"pages":[{"title":"404 Page","text":"The website encounters an unresolvable link. It maybe caused by errors written in the blog's source. You click back, or go to the home page.","link":"/404"},{"title":"关于","text":"这里可以介绍一下本博客和各位作者。 博客的建设可能会慢，但绝不会坑掉🙃。","link":"/about/index.html"}],"posts":[{"title":"《习近平关于“不忘初心、牢记使命”论述摘编》学习心得","text":"有些学生企图用一个晚上通读《习近平关于“不忘初心、牢记使命”论述摘编》.jpg 第二批“不忘初心、牢记使命”主题教育从 2019 年 9 月开始到 11 月底基本结束，包括高等学校在内。围绕学习贯彻习近平新时代中国特色社会主义思想的主线，各党员要深入学习主题教育精神，以理论滋养初心、以理论引领使命，增强“四个意识”、坚定“四个自信”、做到“两个维护”，以彻底的自我革命精神解决违背初心和使命的各种问题，努力实现理论学习有收获、思想政治受洗礼、干事创业敢担当、为民服务解难题、清正廉洁作表率的目标。 为配合第二批主题教育，《习近平关于“不忘初心、牢记使命”论述摘编》出版，供基层党员学习使用。其内容包括习近平同志 2012 年 十一月至 2019 年七月的 362 段论述，共分十个专题。下面是我对这本书的总结和学习心得。 body { background-color: #DE2910; } 专题总结 一、中国共产党人的初心和使命，就是为中国人民谋幸福，为中华民族谋复兴 这一专题说明了中国共产党人的目标与责任，强调了“不忘初心、牢记使命”的主体维度。 二、新时代中国共产党的历史使命 本专题指出中国特色社会主义进入新时代这一新的历史方位，部署了实现伟大梦想的工作，强调党的建设和加强党的领导的重要性。 三、用新时代中国特色社会主义思想武装全党 强调深入学习中国特色社会主义理论体系，坚持和发展马克思主义科学理论，阐述了新时代中国特色社会主义思想的内容，说明在新时代坚持和发展中国特色社会主义的十四个基本方略，要求学习贯彻党的十九大精神。 四、坚定理想信念，始终是共产党人安身立命的根本 坚定理想信念与第一专题不忘初心相似。 五、把政治建设摆在首位，不断增强“四个意识”、坚定“四个自信”、做到“两个维护” 强调在思想上政治上行动上同党中央保持高度一致，坚持党性原则，严守党的政治纪律。 六、坚持以人民为中心，把群众观点和群众路线深深根植于思想具体落实到行动上 群众路线是党的生命线和根本工作路线，党的一切工作都是为了实现好、维护好、发展好最广大人民群众的根本利益。 七、勇于自我革命，同一切影响党的先进性、弱化党的纯洁性的问题作坚决斗争 开展党的自身建设，廉洁自律，反腐倡廉。强调先进性和纯洁性是马克思主义政党的本质属性，加强党内监督，开展批评与自我批评，保持自我革命精神。 八、坚决整治形式主义、官僚主义，加强真抓实干的作风建设 反对形式主义，讲求实效 九、加强学习、深入开展调查研究，全面增强执政本领 强调不断学习，深入调查研究的重要性。 十、新时代要有新气象，更要有新作为 与第二专题差不多，重点是要有“新作为”，给人身心振奋的感觉。 我的学习心得 论述摘编的内容面向全体基层党员，涵盖了围绕学习贯彻习近平新时代中国特色社会主义思想的主线，深入学习主题教育精神，以理论滋养初心、以理论引领使命，增强“四个意识”、坚定“四个自信”、做到“两个维护”的方方面面的内容。这次报告我分享对与高校学生关系比较密切的三个方面的心得。 首先是第一专题和第四专题讲到的中国共产党人的初心和使命以及坚定理想信念的问题。我认为其中的重要一点是认识“不忘初心、牢记使命”的主体维度。历史告诉我们，中华民族的命运与中国共产党紧密相连，实现中华民族的伟大复兴是中国共产党的崇高使命和历史责任，它着眼于中国人民和中华民族。这也就意味着我们看待中国问题要从中国角度出发，既关注每位中国人民的个人观点，也囊括中华民族的总体范畴。总书记在论述共产党人为中国人民谋幸福，为中华民族谋复兴这一中国共产党人的初心和使命时，强调了在历史维度上加强党的自身建设的宝贵经验的传承，由中国情况出发，在实践中丰富和发展马克思主义科学理论。他在有关内容的讲话中提到历史上的优秀例子和他自己在福州、宁德当市委、地委书记时实践走访每个乡县的切身体会，给我最大的感受就是守初心、担使命不是被束之高阁的概念，每位共产党员都必须时时刻刻牢记践行。在价值维度上把人民的价值诉求作为党的价值追求，让人民同享改革成果，把人民的观点作为判断决策成果优劣的标准。在实践维度上在新时代贯彻新发展理念，满足人民日益增长的美好生活需要，这要求我们敢于承担风险、勇于承担责任、乐于迎接挑战、勤于开创事业。明确了以上解决坚持和发展中国特色社会主义的动力和源泉问题，我们才能始终充满奋勇前进的强大动力。 第二是第六专题论述的，群众路线是党的生命线和根本工作路线。党的一切工作都是为了实现好，维护好，发展好最广大人民群众的根本利益。既要看到人民群众中先进的优秀的成分，自觉学习发扬优良传统和社会主义新风尚，也要意识到现实情况下的不足，看到落后与跟不上时代的部分，并在自己的行动中有意识地做出改变。不要忘记现在良好的学习条件来自党的领导和人民群众的辛勤劳动。我们在学习生活中也要紧密团结同学，起到先进表率作用，积极了解学生群体中的情况，解决现实的困难。 第三是第九章中对学习和调查的观点，强调不断学习深入调查研究的重要性，同时结合第八章反对形式主义的观点。学习不是为学而学，在新知识新事物层出不穷的当今时代，更加要注意全方面的学习。其一是通过掌握知识掌握本领，克服面对困难时恐慌退缩的不足；其二是扎实学习，避免形式主义突击学习；第三是学有所用与实践结合。在应用中加深对所学知识的理解。这让我联想到在科研实践中，我们应当夯实基础能力，挑战核心技术，避免盲目追求前沿，走花拳绣腿的套路。","link":"/2019/diary/%E3%80%8A%E4%B9%A0%E8%BF%91%E5%B9%B3%E5%85%B3%E4%BA%8E%E2%80%9C%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E3%80%81%E7%89%A2%E8%AE%B0%E4%BD%BF%E5%91%BD%E2%80%9D%E8%AE%BA%E8%BF%B0%E6%91%98%E7%BC%96%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"},{"title":"庆祝祖国七十华诞-🇨🇳","text":"1949 - 2019 热烈庆祝中华人民共和国成立 70 周年 🇨🇳","link":"/2019/diary/%E5%BA%86%E7%A5%9D%E7%A5%96%E5%9B%BD%E4%B8%83%E5%8D%81%E5%8D%8E%E8%AF%9E-%F0%9F%87%A8%F0%9F%87%B3/"},{"title":"博客日志","text":"本文记录博客的变更信息。 Web 服务器： 博客托管于美国加州圣何塞 域名：https://waferlab.tk Github Pages: https://atlanswer.github.io 2019年7月26日：博客上线，使用 Hexo 框架，服务器位于东京。 2019年7月27日：采用 Icarus 主题，完成基本布局。发布了第一篇文章“跨阻放大器简介”。 2019年7月30日：完善博客部署流程，修改Post not found: tutorial/Hexo-博客写作流程 “博客写作流程”介绍文章。 2019年10月7日：更新 Icarus 2.6.1。 2019年10月9日：迁移博客服务器。 2019年10月11日：Markdown 渲染器切换到 hexo-renderer-markdown-it，提升了页面渲染速度的同时解决了一些错误排版问题。 2019年10月12日：修改博文页面布局，新增最近更改时间。现在博文将按照最后修改的时间排序。 2019年10月13日：中文字体更改为 Noto Sans SC。 2019年10月21日：修复了页面目录链接错误的 bug。 2019年10月23日：更改字体 CDN 为 Google Fonts，博客页面字体配置为 Roboto、Noto Sans SC、Noto Sans JP。 2020年2月4日：迁移博客服务器。 2020年3月4日：博客同时托管在 Github Pages，补充了 404 页面。 2020年4月10日：更新 Icarus 3。 2020年4月9日：更新字体配置，衬线字体为 Roboto、Noto Sans SC，等宽字体为 Roboto Mono。 2020年8月10日：迁移博客服务器。 2020年9月5日：更新 Icarus 4。 2021年7月17日：添加 GitHub Actions，实现自动构建并同步至 GitHub Pages。 2021年7月20日：更新 GitHub Actions，实现自动同步至 WaferLab。 2021年10月12日：服务器后端更改为 GitLab。","link":"/2019/log/blog-log/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2019/log/hello-world/"},{"title":"A bite of AiP &amp; MLAO","text":"Antenna-in-Package (AiP) Overview reference: Zhang, Y. and J. Mao (2019). \"An Overview of the Development of Antenna-in-Package Technology for Highly Integrated Wireless Devices.\" Proceedings of the IEEE 107(11): 2265-2280. Motivations Next generations of wireless communications: mmWave frequencies and multiple antennas for beamforming and tracking; Automotive radar: mmWave with a wide bandwidth allows for high spatial resolution for collision avoidance and vision enhancement in self-driving[1]. Development of Integrated Antennas Prerequisite: Single-die wireless transceiver DSP and CMOS technologies enabled the full integration of an entire wireless transceiver into a single die. Chip antenna technology was developed to provide a compatible antenna solution, while the interconnections between the transceiver and the chip antenna introduce a transmission loss, causing serious problems for higher frequencies. Integration solutions: AoC vs AiP Integrated antennas were attempted. Antenna-on-Chip (AoC) realizes an antenna or antennas with the transceiver in a die on the same wafer, suitable for terahertz applications. Antenna-in-Package (Aip) implements an antenna or antennas with the transceiver die into a standard SMT package. AiP Design Considerations Fundamental antenna characteristics as well as package-specific characteristics: Wavelength, bandwidth &amp; dimension considerations; Basic antenna types: dipole, loop, slot, etc; AiP arrangement: Patch, Yagi-Uda, Grid array, etc; Custom solution specially for developed for AiP: horn antenna by Tajima et al. The basic antennas were used for the proof of the concept, the unusual antennas for specific designs, and the popular antennas for general radios and radars[1:1]. Parasitic effects: leaded and leadless; Package types: BGA, QFN, etc; Interconnection pad configurations: ground-signal-ground (GSG) and GSG-signal-ground (GSGSG); Trace: coplanar waveguide (CPW), strip, and microstrip lines; Fabrication technologies: low temperature co-fired ceramic (LTCC), high density interconnection (HDI), fan-out wafer level packaging (FOWLP), etc. Machine Learning Assisted Optimization (MLAO) Overview reference: Wuf, Q., et al. (2020). \"Machine-learning-assisted optimization and its application to antenna designs: Opportunities and challenges.\" China Communications 17(4): 152-164. Motivation Full-wave electromagnetic simulation provides great accuracy while being resource demanding and time consuming; Modern wireless communication systems gave higher antenna performance requirements; MLAO has been introduced to accelerate the design process of antennas and arrays[2]. In modern wireless communication systems, the antenna is designed and considered not as a separate component but as a system-level task that must integrate with other components, structures, or even appearance designs for commercial devices[2:1]. Available methods Irregular geometries leads to analytically incalculable solutions. Numerical methods were introduced to analyze complex configurations: Integral equation solvers: discrete dipole approximation, method of moments element method, fast multipole method, plane wave time-domain, partial element equivalent circuit method, etc; Differential equation solvers: finite-difference time-domain method, discontinuous time-domain method, multiresolution time-domain method, finite element method, finite integration technique, etc; Other methods: eigenmode expansion, physical optics, uniform theory of diffraction. Machine learning approaches: Artificial neural networks, support vector machine, gaussian process regression, etc. Optimization considerations Multi-objective, variable-fidelity, parallel computing and sensitivity analysis. Opportunities Hybrid surrogate models: data-driven and physical-driven methods. Work in Progress Zhang, Y. and J. Mao (2019). &quot;An Overview of the Development of Antenna-in-Package Technology for Highly Integrated Wireless Devices.&quot; Proceedings of the IEEE 107(11): 2265-2280. ↩︎ ↩︎ Wu, Q., et al. (2020). &quot;Machine-learning-assisted optimization and its application to antenna designs: Opportunities and challenges.&quot; China Communications 17(4): 152-164. ↩︎ ↩︎","link":"/2021/note/A-bite-of-AiP-MLAO/"},{"title":"An Efficient Surrogate Assisted Particle Swarm Optimization for Antenna Synthesis","text":"Motivation[1] Optimization: to find to optimum design parameters; Sensitivity Analysis: to explore the design performance when parameters are varying. Solution Evolutionary algorithm (EA): a generic population-based metaheuristic optimization algorithm, ideally making no assumption about the underlying fitness landscape. Steps: Randomly generate the initial population of individuals; Repeat until termination: Evaluate the fitness of each individual in the population; Select parents: the fittest individuals; Breed new individuals with crossover and mutation; Replace the least-fit individuals of the population with new individuals. Types: Genetic algorithm (GA): One seeks the solution of a problem in the form of strings of numbers, by applying operators such as recombination and mutation; Differential evolution (DE): Based on vector differences and is therefore primarily suited for numerical optimization problems. Particle swarm optimization (PSO): Only the objective function is needed and it is not dependent on the gradient or any differential form of the objective. Limitations The computational budget of EA-based antenna synthesis is usually high because of various exact function evaluations are required at each iteration and hundreds of iterations are needed for a global optimal solution. Surrogate Assisted Evolutionary Algorithms (SAEAs) Surrogate Modeling Accurately approximate the simulation output by constructing statistical model (or surrogate model). Characteristics Surrogate modeling is a special case of supervised machine learning applied in the field of engineering design. Its training data is obtained via probing the simulation outputs at several intelligently selected locations in the design parameter space. At each of these locations, a full simulation is conducted to calculate the corresponding simulation output.[2] Steps[3] Sampling: generating initial training data by selecting samples of the design parameters from their parameter space, preferably to have samples that are spread evenly across the parameter space. Output evaluations: run the simulations for each sample, resulting the initial training dataset; Construct the surrogate model: usually by utilizing established machine learning algorithms; Active learning: enrich the training dataset as the training progresses by crafting learning functions to allocate samples to regions where the model is thought to be inaccurate or uncertain, or to regions of interests. Enrich training dataset: Perform new simulations runs to retrain the model. Details Problem Formulation of Antenna Optimization Adjusting the geometric parameters of a given topological antenna structure inside the range of desired operating frequencies to achieve optimal performance: To minimize \\(f(\\bm{x})\\), given that \\(g_i(\\bm{x})\\leqslant0,i=1,2,\\ldots,k,\\bm{x}\\in[\\bm{lb}, \\bm{ub}]^D\\) where \\(\\bm{x}=[x_1, x_2, \\ldots, x_D]\\) represents the geometrical variables of a fixed antenna structure, \\(D\\) is the problem dimension, \\(k\\) is the number od constrains. \\(\\bm{lb}\\) and \\(\\bm{ub}\\) are the lower and upper bounds of the design space. \\(f(\\bm{x})\\) and \\(g_i(\\bm{x})\\) represent the major performance metric and subordinate performance metrics respectively. An introduction to Surrogate modeling. ↩︎ Interpretable Machine Learning: A Guide for Making Black Box Models Explainable. ↩︎ Alexander I. J. Forrester, András Sóbester, Andy J. Keane, Engineering Design via Surrogate Modelling: A Practical Guide, 2008. ↩︎","link":"/2021/note/An-Efficient-Surrogate-Assisted-Particle-Swarm-Optimization-for-Antenna-Synthesis/"},{"title":"Git Detached Work Tree","text":"Separate work tree from the git directory, useful when the git repository is a bare git repository located on a git server. Synopsis 1git [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] &lt;command&gt; [&lt;args&gt;] Example 12git --git-dir=/home/git/hexo-blog.git --work-tree=/var/www/blog checkout -f publishgit --git-dir=/home/git/hexo-blog.git --work-tree=/var/www/blog reset --hard HEAD","link":"/2021/note/Git-Detached-Work-Tree/"},{"title":"GitLab Configuration","text":"Installation Docker Compose File Configuration Let's Encrypt Integration Should be disabled because of the server configuration. /etc/gitlab/gitlab.rb1letsencrypt['enable'] = false Nginx Prevent the bundled Nginx from handling SSL termination. /etc/gitlab/gitlab.rb12345nginx['listen_port'] = 80nginx['listen_https'] = falsenginx['real_ip_trusted_addresses'] = [ '192.168.1.0/24', '172.22.0.1/24', '2001:0db8::/32' ]nginx['real_ip_header'] = 'X-Real-IP'nginx['real_ip_recursive'] = 'on' OmniAuth /etc/gitlab/gitlab.rb12345678910111213141516171819202122232425gitlab_rails['omniauth_enabled'] = truegitlab_rails['omniauth_allow_single_sign_on'] = ['github']gitlab_rails['omniauth_sync_email_from_provider'] = ['github']gitlab_rails['omniauth_sync_profile_from_provider'] = ['github']gitlab_rails['omniauth_sync_profile_attributes'] = ['name', 'email', 'location']gitlab_rails['omniauth_auto_link_user'] = ['github']gitlab_rails['omniauth_allow_bypass_two_factor'] = ['github']gitlab_rails['omniauth_auto_sign_in_with_provider'] = 'github'gitlab_rails['omniauth_block_auto_created_users'] = truegitlab_rails['omniauth_providers'] = [ { 'name' =&gt; 'github', 'app_id' =&gt; 'APP_ID', 'app_secret' =&gt; 'APP_SECRET', 'args' =&gt; { 'scope' =&gt; 'user:email' } }]#### SSH```ruby /etc/gitlab/gitlab.rbgitlab_rails['gitlab_ssh_host'] = 'git.waferlab.tk:port'gitlab_rails['gitlab_ssh_user'] = 'git' Optimize Puma Start only a single Puma process. /etc/gitlab/gitlab.rb1puma['worker_processes'] = 0 Optimize Sidekiq It is advised to configure it to use a significantly smaller value of 5 or 10 (preferred). /etc/gitlab/gitlab.rb1sidekiq['max_concurrency'] = 8 Optimize Gitaly Gitaly is a storage service that allows efficient access to Git-based repositories. It is advised to configure a maximum concurrency and memory limits enforced by Gitaly. /etc/gitlab/gitlab.rb12345678910111213gitaly['ruby_max_rss'] = 200_000_000gitaly['concurrency'] = [ { 'rpc' =&gt; &quot;/gitaly.SmartHTTPService/PostReceivePack&quot;, 'max_per_repo' =&gt; 3 }, { 'rpc' =&gt; &quot;/gitaly.SSHService/SSHUploadPack&quot;, 'max_per_repo' =&gt; 3 }]gitaly['env'] = { 'GITALY_COMMAND_SPAWN_MAX_PARALLEL' =&gt; '2'} Disable monitoring GitLab enables all services by default to provide a complete DevOps solution without any additional configuration. Some of the default services, like monitoring, are not essential for GitLab to function and can be disabled to save memory. /etc/gitlab/gitlab.rb1prometheus_monitoring['enable'] = false Action Cable Don't know how it works. /etc/gitlab/gitlab.rb1actioncable['enable'] = true Backups To prune old backups: /etc/gitlab/gitlab.rb1gitlab_rails['backup_keep_time'] = 604800 Database Automatic database reindexing /etc/gitlab/gitlab.rb1gitlab_rails['database_reindexing']['enable'] = true SMTP QQ exmail /etc/gitlab/gitlab.rb12345678910gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = &quot;hwsmtp.exmail.qq.com&quot;gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = &quot;xxxx@xx.com&quot;gitlab_rails['smtp_password'] = &quot;password&quot;gitlab_rails['smtp_authentication'] = &quot;login&quot;gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['gitlab_email_from'] = 'gitlab@waferlab.tk'gitlab_rails['smtp_domain'] = &quot;exmail.qq.com&quot; Container Registry We don't need it currently. /etc/gitlab/gitlab.rb1registry['enabled'] = false Logging Docker’s default logging driver is json-file, which performs no log rotation by default. As a result of this lack of rotation, log files stored by the json-file driver can consume a significant amount of disk space for containers that generate a lot of output. This can lead to disk space exhaustion. To address this, use journald as the logging driver when available, or another supported driver with native rotation support.","link":"/2021/note/GitLab-Config/"},{"title":"HFSS 偶极子天线仿真","text":"建模 现在我们仿真偶极子天线。其结构可建模为两个沿 y 轴放置的金属圆柱体，两者之间连接馈电接口。 设置仿真频率为 2.4 GHz，添加 50 点频率扫描，范围是 2 GHz ~ 3 GHz。 分析 方向图 铅锤面方向图 水平面方向图 方向图说明了偶极子天线的特性：其增益在位于中心垂直于天线指向的平面上最大，在 \\(\\varphi\\) 各方向上增益相同。 反射系数 以馈电接口处的反射系数为匹配效果的标准，天线的长度和半径是优化设计的目标。 \\(S\\) 参数中，设端口 2 匹配时，端口 1 的归一化输入电压为 \\(a_1\\)，反射波电压为 \\(b_1\\)，输入反射系数定义为 \\[ S_{11}=\\frac{b_1}{a_1} \\] 馈电接口处反射系数越低则传递到天线的能量越多。认为 \\(S_{11}\\) 小于 -10 dB 时接口于天线匹配。比较不同天线长度和半径来寻找最佳匹配结果。 天线半径对反射系数 -10dB 带宽的影响 天线半径的观测范围是 0.5 mm ~ 1.5 mm。对不同的天线半径，上限频率大致相同而下限频率差异较大。在观测范围内天线半径越大则 -10 dB 带宽越大，谐振频率略有下降。 天线长度对谐振频率的影响 天线长度的观测范围是 22 mm ~ 32 mm。观察反射系数曲线最低点即谐振点。在观测范围内谐振频率随天线长度增加而降低，反射系数增大。 考虑不同长度和半径的 9 种组合：","link":"/2020/note/HFSS-%E5%81%B6%E6%9E%81%E5%AD%90%E5%A4%A9%E7%BA%BF%E4%BB%BF%E7%9C%9F/"},{"title":"HFSS 矩形波导仿真","text":"在 Ansys HFSS (High Frequency Structure Simulator) 中可使用有限元法求解电磁场，现在我们借助 HFSS 15 仿真矩形金属波导中的场分布。 矩形波导中的场 矩形金属波导只有一个导体，电磁波在中间空腔内传播。由于金属波导没有自由电荷和传导电流，无法传输 TEM 波。一般情况下，只需要 \\(E_z\\) 和 \\(H_z\\) 中一个为零即可满足边界条件，因此只能存在 TE 波和 TM 波。 建立如下的矩形波导模型。 设矩形波导的宽边长度为 \\(a\\)，窄边长度为 \\(b\\)。电磁波沿 \\(z\\) 方向传播。 TE 波 对 TE 波，\\(E_z=0\\) 而 \\(H_z=H_{oz}(x,y)e^{-j\\beta z}\\neq 0\\)，只有纵向磁场，满足边界条件 \\[ \\left.\\frac{\\partial H_z}{\\partial \\mathbf{n}}\\right|_S=0 \\tag{2-1-22} \\] 其中 \\(S\\) 表示波导周界，\\(\\mathbf{n}\\) 是边界法向单位矢量。 矩形波导 TE 波纵向磁场的基本解为 \\[ H_z=H_{mn}\\cos(\\frac{m\\pi}{a}x)\\cos(\\frac{n\\pi}{b}y)e^{-j\\beta z} \\tag{2-2-8} \\] 由式 \\((2-2-10)\\) 可得矩形波导 \\(\\text{TE} _ \\text{mn}\\) 模的截止波数为 \\[ k^2 _ \\text{cmn}=\\left(\\frac{m\\pi}{a}\\right)^2+\\left(\\frac{n\\pi}{b}\\right)^2 \\tag{2-2-15} \\] 对应截止波长 \\[ \\lambda _ {\\text{cTE} _ {\\text{mn}}}=\\frac{2\\pi}{k _ \\text{cmn}}=\\lambda _ \\text{c} \\tag{2-2-15} \\] 只有当工作波长 \\(\\lambda\\) 小于某个模式的截止波长 \\(\\lambda _ \\text{c}\\) 时，这个模式才可在波导中传输。主模 \\(\\text{TE} _ \\text{10}\\) 模是最常用的模式，下面分析该模式的场分布。 HFSS 仿真 定义矩形波导尺寸，\\(a=0.03\\text{m}\\)，\\(b=0.02\\text{m}\\)。 金属管壁是理想导体，其表面是电场等势面，设置 Perfect E 边界条件。 在 \\(z=0\\) 处设置激励 Wave Port 作为电磁波输入口。\\(\\text{TE} _ \\text{10}\\) 模已经是矩形波导的最低次模，只需设置仿真一个模式。 各模式的截止波长和截止频率如下 模式 截止波长 截止频率 \\(\\text{TE} _ \\text{10}\\) 0.06m 5GHz \\(\\text{TE} _ \\text{01}\\) 0.04m 7.5GHz \\(\\text{TE} _ \\text{11}\\) 0.033m 9GHz 设置求解频率为 \\(f=10\\text{GHz}\\)，以上各个模式都能够传播。这里只显示最低模式。 行波状态 设置波导终端边界条件为辐射面，电磁波离开辐射面后不再返回，即终端匹配。 将 \\(m=1\\)，\\(n=0\\)，\\(k_\\text{c}=\\pi/a\\) 代入 \\((2-2-10)\\) 可得场强与 \\(y\\) 无关。在没有反射的情况下，电磁波沿 \\(z\\) 方向按行波传播；沿 \\(x\\) 方向，\\(E_y\\)、\\(H_x\\) 最大值在同截面出现，与 \\(H_z\\) 有 90° 的相位差，电磁波沿横向呈驻波分布。 由于沿 \\(y\\) 方向场强相同，只需观察表面场，如下为电场幅值分布。 0° 90° 可见仿真结果符合理论预期。相邻的电场幅值点一个是最大值一个是最小值，第一个幅值点与第三个幅值点的距离为波导波长： \\[ \\lambda _ \\text{g}=\\frac{2\\pi}{\\beta}=\\frac{\\lambda}{\\sqrt{1-(\\lambda/2a)^2}}=0.035\\text{m} \\tag{2-2-24} \\] 驻波状态 终端边界条件为 Perfect E 时相当于终端短路，电场必为零。电磁波全部反射形成驻波，终端为电压波节点。 0° 90° 终端边界条件为 Perfect H 时相当于终端开路，电磁波也呈纯驻波分布。终端为电压波腹点。 0° 90° 波腹点与波节点之间距离为 \\(\\lambda _ \\text{g}/4\\)，因为反射波与入射波叠加，因此驻波状态电场幅值明显高于行波状态，但由于该模型中反射波与入射波存在相位差，因此幅值小于行波幅值的 2 倍。","link":"/2020/note/HFSS-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E4%BB%BF%E7%9C%9F/"},{"title":"QR Code Standard: ISO&#x2F;IEC 18004:2015","text":"Excerpted form ISO/IEC 18004:2015 QR Code Standard, modified. 11 Decoding procedure overview Locate and obtain an image of the symbol. Recognize dark and light modules as an array of “0” and “1” bits. Identify reflectance polarity from finder pattern module colouring. Read format information. … Read the version information (where applicable), … Release the data masking by XORing the encoding region bit pattern with the data mask pattern. The reference of which has been extracted from the format information. Read the symbol characters according to the placement rules for the model and restore the data and error correction codewords of the message. Detect errors using the error correction codewords corresponding to the Level Information. If any error is detected, correct it. Divide the data codewords into segments according to the mode indicators and character count indicators. Finally, decode the Data Characters in accordance with the mode(s) in use and output the result. 12 Reference decode algorithm for QR Code This reference decode algorithm finds the symbol in an image and decodes it. The decode algorithm refers to dark and light states in the image. Determine a Global Threshold by taking a reflectance value midway between the maximum reflectance and minimum reflectance in the image. Convert the image to a set of dark and light pixels using the Global Threshold. Locate the finder pattern. The finder pattern in QR Code consists of three identical finder patterns located at three of the four corners of the symbol. The finder pattern in Micro QR Code is a single finder pattern. As described in 6.3.3, module widths in each finder pattern form a dark-light-dark-light-dark sequence the relative widths of each element of which are in the ratios 1 : 1 : 3 : 1 : 1. For the purposes of this algorithm the tolerance for each of these widths is 0.5 (i.e. a range of 0.5 to 1.5 for the single module box and 2.5 to 3.5 for the three module square box). When a candidate area is detected note the position of the first and last points A and B respectively at which a line of pixels in the image encounters the outer edges of the finder pattern (see Figure 31). Repeat this for adjacent pixel lines in the image until all lines crossing the central box of the finder pattern in the x axis of the image have been identified. Repeat step i for pixel columns crossing the central box of the finder pattern in the y axis of the image. Locate the center of the pattern. Construct a line through the midpoints between the points A and B on the outermost pixel lines crossing the central box of the finder pattern in the x axis. Construct a similar line through points A and B on the outermost pixel columns crossing the central box in the y axis. The center of the pattern is located at the intersection of these two lines. Repeat steps i to iii to locate the centers of the two other finder pattern. If no candidate areas are detected, reverse the colouring of the light and dark pixels and recommence at the beginning of step 2 to attempt the decode the symbol as as a symbol with reflectance reversal. If a single patter is identified but two further finder patterns can not be located, attempt to decode the symbol as a Micro QR Code symbol by jumping to the Micro QR Code symbols reference decode (from step 13). Determine the rotational orientation of the symbol by analysing the finder pattern center coordinates to identify which pattern is the upper left pattern in the symbol and the angle of rotation of the symbol. Determine the distance $D$ crossing the full width of the symbol between the centers of the upper left finder pattern and the upper right finder pattern and the width of the two patterns, $W_{UL}$ and $W_{UR}$ as shown in Figure 32. Calculate the nominal $X$ dimension of the symbol. $$X=(W_{UL}+W_{UR})/14$$ Provisionally determine the version V of the symbol. $$V=[(D/X)−10]/4$$ If the provisional symbol version is 6 or less, this is specified as the defined version. If the provisional symbol version is 7 or more, the version information is decoded as follows. … For Version 1 symbols, redefine $X$ as the average spacing of the center points of the dark and light modules in the upper side Timing Patterns. In a similar manner, calculate the $Y$ dimension as the average spacing of the center points of the dark and light modules in the left side Timing Pattern. WIP","link":"/2019/note/QR-Code-Standard-ISO-IEC-18004-2015/"},{"title":"如何使用 ROS","text":"并不是所有的机器人都像电子设计普及赛要求的循迹小车那样简单，要实现精确的控制，让机器人采集复杂的信息并作出准确的判断并非易事。对循迹小车级别的要求，我们一般尝试从零开始实现所有的部分，换言之就是“造轮子”。当然，不存在真正从“零”起步的工作，例如制造二极管、编写编译器等过于基础的部分显然不包含在内。所谓从基础做起，其原料都是极易获取的组件。对基础的应用，每个团队得到的结果将大同小异，是否动手实现每个环节才是评判水平高低的重要标准。对评委来说，结果要求越低，参赛者动手实现程度越为重要。 随着机器人复杂程度的提高，这种“造轮子”式的开发方法逐渐变得不现实。基本上我们会选择从之前已有的工作开始，整合各个模块实现所需功能。这是需要解决的问题是：需要那些模块，如何使用这些模块，那些部分需要亲自实现，能否让不同来源的组件整合工作。对设计一个连接各个模块的框架的要求渐渐变得明显。 实践中，有很多团队尝试完成这种框架。ROS (Robot Operating System) 正是其中之一。 Work in Progress","link":"/2019/note/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ROS/"},{"title":"对外开放","text":"摘录自《广东改革开放 40 年研究丛书 - 广东对外开放 40 年》 研究广东改革开放，要系统总结广东改革开放 40 年的伟大成就，增强改革不停顿、开放不止步的信心和决心。 广东是中国改革开放的排头兵、先行地、试验区，在改革开放和现代化建设中始终走在全国前列，取得了举世瞩目的辉煌成就，展现了改革开放的磅礴伟力。 广东实现了从一个经济比较落后的农业省份向全国第一经济大省的历史性跨越。1978 - 2017 年，广东 GDP 从 185.85 亿元增加到 89 879.23 亿元，增长约 482.6 倍， 占全国的 10.9%。1989 年以来，广东 GDP 总量连续 29 年稳居全国首位，成为中国第一经济大省。经济总量先后超越新加披、中国香港和台湾地区，2017 年超过全球第 13 大经济体澳大利亚，进一步逼近“亚洲四小龙”中经济总量最大的韩国，处于世界中上等收入国家水平。 广东实现了从计划经济体制向社会主义市场经济体制的历史性变革。 广东实现了从封闭半封闭到全方位开放的历史性转折。 广东实现了由要素驱动向创新驱动的历史性变化。 广东实现了从温饱到全面小康迈进的历史性飞跃。 广东实现了生态环境由问题不少向逐步改善的历史性转变。 历史回顾 第一章 先行先试：广东对外开放拉开大帷幕 改革开放伊始：开启序幕 对外开放的探索：经济特区 对外开放的探索：外贸体制改革 第二章 扩大开放：广东对外开放迈向新台阶 邓小平南方谈话指明前进航向 大力引进和优化外资 出口导向战略引领对外贸易发展 深化粤港澳经济合作 广东成为中国改革开放“试验田”和示范区 第三章 国际接轨：广东对外开放争当排头兵 中国加入 WTO 与广东对外开放 粤港澳合作 “三来一补”与“香港因素” 第四章 转危为机：广东对外开放勇闯深水区 化挑战为机遇，积极应对金融危机 科学规划，推动形成高水平开放新格局 习近平总书记重要讲话精神和指示批示精神引领方向 第五章 全面引领：广东对外开放构建新格局 实施创新驱动发展战略 建设广东自由贸易试验区 打造“一带一路”核心枢纽 共建“粤港澳大湾区”新增长极","link":"/2021/note/%E5%AF%B9%E5%A4%96%E5%BC%80%E6%94%BE/"},{"title":"Generate a UUID","text":"GUID (aka UUID) is an acronym for 'Globally Unique Identifier' (or 'Universally Unique Identifier'). It is a 128-bit integer number used to identify resources. The term GUID is generally used by developers working with Microsoft technologies, while UUID is used everywhere else. Online GUID / UUID Generatorwww.guidgenerator.com Generate a GUID in PowerShell: 1[guid]::NewGuid() or Javascript UUID Generator","link":"/2021/tip/Generate-a-UUID/"},{"title":"Windows Terminal and PowerShell","text":"What's the difference between a console, a terminal, and a shell? PowerShell Installation (Windows) https://aka.ms/PSWindows Winget 1winget install --name PowerShell --exact --source winget Profile 12code $PROFILE. $PROFILE Oh My Posh Installation (PowerShell) https://ohmyposh.dev/docs/ 12Install-Module oh-my-posh -Scope CurrentUserUpdate-Module oh-my-posh Configuration Windows Terminal Install from Microsoft Store. Configuration","link":"/2021/tip/Windows-Terminal-and-PowerShell/"},{"title":"HFSS 仿真基础","text":"HFSS 介绍 ANSYS HFSS是电磁场仿真的常用工具[1]。 HFSS 使用的数学方法 HFSS 利用有限元法（Finite element method, FEM）求解电磁场。该技术将结构划分为许多小组件，称为有限元。HFSS 划分的有限元是四面体，所有四面体的集合称为网格。HFSS 首先对有限元内的场求解，然后将各场关联起来使有限元间的边界满足麦克斯韦方程组。 式 \\((1)\\) 计算电场 \\(\\bm{E}\\)： \\[ \\nabla\\times\\left(\\frac{1}{\\mu_r}\\nabla\\times\\bm{E}\\right) -k_0^2\\epsilon_e\\bm{E}=0 \\tag{1} \\] 其中 \\(\\mu_r=\\mu/\\mu_0\\)，\\(\\epsilon_r=\\epsilon/\\epsilon_0\\)，\\(k_0^2=\\omega^2\\epsilon_0\\mu_0=\\omega_2/c^2\\)。 式 \\((2)\\) 计算磁场 \\(\\bm{H}\\)： \\[ \\bm{H}=\\frac{j}{\\omega\\mu}\\nabla\\times\\bm{E} \\tag{2} \\] Work in Progress An Introduction to HFSS: Fundamental, Principles, Concepts, and Use. A copy could be found here. ↩︎","link":"/2021/tutorial/HFSS-%E4%BB%BF%E7%9C%9F%E5%9F%BA%E7%A1%80/"},{"title":"How to Write Documentation","text":"Reference: Clear, Functional C++ Documentation with Sphinx + Breathe + Doxygen + CMake","link":"/2021/tutorial/How-to-Write-Documentation/"},{"title":"Nature Formatting Guide","text":"Reference: Nature for Authors. Nature Articles Articles are original reports whose conclusions represent a substantial advance in understanding of an important problem and have immediate, far-reaching implications. In print, they do not normally exceed 5 pages of Nature. Articles start with a fully referenced summary paragraph, ideally of no more than 200 words, which is separate form the main text and avoids numbers, abbreviations, acronyms or measurements unless essential. As a guideline, articles typically have 30-50 references, but be mindful of the space that these will occupy on the page. (There is no such constrain on any additional references associated with a Methods or Supplementary Information file.) Format of Articles Contributions should be double-spaced and written in English (spelling as in the Oxford English Dictionary). Contributions should be organized in the sequence: title, authors, affiliations (plus present addresses), bold first paragraph, main text, main references, tables, figure legends, methods (including separate data and code availability statement), methods references, acknowledgements, author contributions, competing interest declaration, additional information (containing supplementary information line (if any) and corresponding author line), extended data figure/table legends. In order to facilitate the review process, for initial submissions we encourage authors to incorporate the manuscript text and figures together in a single file (Microsoft Word or PDF, up to 30 MB in size). The figures may be inserted within the text at the appropriate positions to grouped at the end, and each figure legend should be presented together with its figure. Also, please include line numbers within the text. Title Text Our preferred format for text is Microsoft Word, with the style tags removed. TeX/LaTeX: If you have prepared your paper using TeX/LaTeX, we will need to convert this to Word after acceptance, before your paper in typeset. All textual material of the paper (including references, tables, figure captions, online methods, etc.) should be included as a single .tex file. We prefer the use of a standard font, preferably 12-point Times New Roman. For mathematical symbols, Greek letters and other special characters, use normal text or Symbol font. Word Equation Editor/MathType should be used only for formulae that cannot be produced using normal text or Symbol font. References References are each numbered, ordered sequentially as they appear in the text, tables, boxes, figure legends, online-only methods, Extended Data tables and Extended Data figure legends. When cited in the text, reference numbers are superscript, not in brackets unless they are likely to be confused with a superscript number. Do not use linked fields (produced by EndNote and similar programs). Please use the one-click button provided by EndNote to remove EndNote codes before saving your file. As a guideline, articles allow up to 30 references in the main text, but can go up to 50 references if needed and within the allocated page budget. Only one publication can be listed for each number. Only articles that have been published or accepted by a named publication, or that have been uploaded to a recognized preprint server (for example, arxiv, bioRxiv), should be in the reference list; papers in preparation should be mentioned in the text with a list of authors (or initials if any of the authors are co-authors of the present contribution). Published conference abstracts, numbered patents, preprints on recognized servers (preprints of accepted papers in the reference list should be submitted with the manuscript) and research datasets that have been assigned a digital object identifier may be included in reference list, but text, grant details and acknowledgements may not. (An exception is the highlighted references which we ask authors of Reviews, Perspectives and Insights articles to provide.) All authors should be included in reference lists unless there are more than five, in which case only the first author should be given, followed by 'et al.'. Please follow the style below in the published edition of Nature in preparing reference lists. Authors should be listed in surname first, followed by a comma and initials of given names. Titles of all cited articles are required. Titles of articles cited in reference lists should be in upright, not italic text; the first word of the title is capitalized, the title written exactly as it appears in the work cited, ending with a full stop. Book titles are italic with all main words capitalized. Journal titles are italic and abbreviated according to common usage. Volume numbers are bold. The publisher and city of publication are required for books cited. (Refer to published papers in Nature for details.) Research datasets may be cited in the reference list if they have been assigned digital object identifiers (DOIs) and include authors, title, publisher (repository name), identifier (DOI expressed as a URL). Example: Hao, Z., AghaKouchak, A., Nakhjiri, N. &amp; Farahmand, A. global Integrated Drought Monitoring and Prediction System (GIDMaPS) data sets. figshare http://dx.doi.org/10.6084/m9.figshare.853801 (2014). Recognized preprints may be cited in the reference list. Example: Babichev, S. A., Ries, J. &amp; Lvovsky, A. I. Quantum scissors: teleportation of single-mode optical states by means of a nonlocal single photon. Preprint at https://arXiv.org/quant-ph/0208066 (2002). References to web-only journals should give authors, article title and journal name as above, followed by URL in full - or DOI if known - and the year of publication in parentheses. References to websites should give authors if known, title of cited page, URL in full, and year of posting in parentheses. Work in Progress","link":"/2021/tutorial/Nature-Formatting-Guide/"},{"title":"Reserved Port Range on Windows","text":"Reference: Stack Overflow Hyper-V reserves some random ports, causing binding problems for other programs. To check the reserved port range: 1netsh int ip show excludedportrange protocol=tcp","link":"/2021/tutorial/Reserved-Port-Range-on-Windows/"},{"title":"YouTube 字幕的正确编辑方式","text":"说在前面 添加字幕极大地改善了视频的观感。字幕不仅仅能为观看外语视频提供必要的帮助，同时使在嘈杂或者其他无法听清 / 听见声音的情况下理解视频内容变得可能。如果应用得当，字体、颜色、位置等高级字幕提供的效果可为视频内容锦上添花。 在模拟电视时代，隐藏字幕(Closed Caption, CC) 是一个单独的模拟信号轨道，CEA-608 是美国、加拿大和墨西哥的 NTSC 电视隐藏字幕标准。如今 FCC 要求电视节目必须提供隐藏式辅助字幕 1 2，广电总局也发布了 GY/T 270-2013 作为我国数字电视隐藏字幕系统的规范。 在 HTML5 规范中，subtitles 指观众不能听懂的语言的文字转写，例如外语对话的翻译；而 captions 指没有声音或听不清时对话、环境音效、音乐提示和其他有关声音信息的文字描述，一般我们把这两者都叫做字幕。所谓隐藏字幕，表示观看者可以选择将其打开或关闭。这个概念与嵌入在视频中的固定式字幕相对。 内嵌字幕很容易理解：把字幕外观渲染成对应的像素叠在视频的上方，制作成新的视频。Adobe After Effects 等高级非编软件可以在视频中创造令人印象深刻的字幕效果。但显然，隐藏式字幕比将其直接嵌入视频更为优雅。实现隐藏字幕需要额外的保存字幕信息的文件，视频播放器在播放时渲染字幕。这种实现方法让观众可以更灵活地控制字幕的显示效果，除了能够方便地打开关闭字幕外，修改字体和其大小、颜色，甚至让字幕显示在视频之外的空间都能做到。 很多流行的视频播放器都支持常见的外部字幕，因此外部字幕在光盘或下载内容中更常见，或作为独立的文件，或被装入 MKV 容器中。外部字幕包括一般只在 DVD 中才见得到的图形数据格式和使用广泛的文本数据格式。前者将字幕以图片形式呈现，例如 SUB、SST，可以显示非常特殊的效果，但是体积较大的同时也不方便修改；后者以文本保存字幕内容和格式信息，例如简单的 SubRip、SubViewer、LRC 和功能丰富的 SAMI、TTML、SubStation Alpha 等。 视频播放软件的字幕支持经过十几年的发展已经相当成熟，如今字幕普及的瓶颈是在线视频，大多数的视频网站播放器根本没有提供 CC，所以很长时间内大家都只能选择在编辑好字幕文件之后把其内容直接渲染到视频里面，虽然可以实现众多字幕效果，但这种做法并不符合 CC 的初衷。如果嵌入视频的字幕有问题，修改起来比较麻烦，不但需要重新渲染视频，还可能要等待视频网站的重新审核。 走在前列的视频网站正着手解决这些问题。YouTube 实现了 CC，同时也提供自动字幕和翻译；bilibili 的外挂字幕系统也上线了将近一年。从我的体验来看，YouTube 的 CC 功能确实好用，尤其在智能算法的帮助下，其自动生成的字幕质量已经非常令人满意，而且 YouTube 播放器能够显示高级字幕格式，下文会介绍更多。在B站，我相信大家也都认同外挂字幕还没有到流行的程度，话特别多的视频或没有字幕，更多情况下创作者或搬运者还是选择把字幕嵌进视频中的传统做法，这当然与 bilibili 对外挂字幕的支持有密切的关系。如果在线播放器能够实现与本地软件一致的字幕支持，想必外部字幕会成为首选方案。 在线视频播放器中实现外部字幕并不是件容易的事，不过对 bilibili 来说可能相对简单一点，弹幕本身就可以做字幕，不过很容易被遮挡或清理，在外部字幕实现之前，解决方案是由视频发布者手动指定字幕弹幕。但弹幕能实现的效果对字幕来说还是不够，在自家的播放器中尽量实现字幕格式支持的效果成为各视频网站的目标。YouTube Studio 有一个简单的在线字幕编辑器，也能上传特定的字幕文件，具体的支持列表看这里。 Work in Progress","link":"/2019/tutorial/YouTube-%E5%AD%97%E5%B9%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%BC%96%E8%BE%91%E6%96%B9%E5%BC%8F/"},{"title":"《雨とカプチーノ》歌词翻译","text":"《雨とカプチーノ》是ヨルシカ的第二首单曲，2019年8月20日发售，也是乐队第二张完整专辑《エルマ》的第四曲。ぽぷりか和まごつき制作的 MV 8月1日在 YouTube 发布。 body { background-color: linen; } .sub { font-size: x-large; } .trans { font-size: large; } 灰(はい)色(いろ)に白(しら)んだ言葉(ことば)はカプチーノみたいな色してる 灰中带白的话语 颜色像是卡布奇诺 言(い)い訳(わけ)はいいよ 窓辺(まどべ)に置(お)いてきて 借口不必再说 留在窗边就好 数(かぞ)え切(き)れないよ 是数不尽的啊 灰色に白んだ心はカプチーノみたいな色してる 灰中泛白的心情 颜色像是卡布奇诺 言い訳はいいよ 呷(あお)ろうカプチーノ 不理会这些托词 大口饮尽卡布奇诺 戯(おど)けた振(ふ)りして 做着玩笑般的举动 さぁ揺蕩(たゆた)うように雨流(なが)れ 像飘忽不定的雨滴一般摇曳吧 僕らに嵐(あら)す花に溺(おぼ)れ 让我们沐浴在这花雨之中 君が褪(あ)せないような思(おも)い出(で)を 像是对你无法拂去的思念 どうか、どうか、どうか君が溢(あふ)れないように 还奢望、奢望着、奢望着它不要满溢而出 波(なみ)待(ま)つ海岸(かいがん) 紅(くれない)夕(ゆう)差(さ)す日 ... 窓(まど)に反射(はんしゃ)して ... 八月のヴィスビー 潮騒(しおさい) ... 待ちぼうけ 海風一(ひと)つで ... 夏泳(およ)いだ花の白さ、宵(よい)の雨 ... 流(なが)る夜(よる)に溺(おぼ)れ ... 誰も褪せないような花一つ ... どうか、どうか、どうか胸の内(うち)側(がわ)に挿(さ)して ... ずっとおかしいんだ ... 生(い)き方(かた)一つ教(おし)えてほしいだけ ... 払(はら)えるものなんて僕にはもうないけど ... 何も答(こた)えられないなら言葉一つでもいいよ ... わからないよ ... 本当にわかんないんだよ ... さぁ揺蕩(たゆた)うように雨流(なが)れ 像飘忽不定的雨滴一般摇曳吧 僕らに嵐(あら)す花に溺(おぼ)れ 让我们沐浴在这花雨之中 君が褪(あ)せないように書(か)く詩(うた)を ... どうか、どうか、どうか今(いま)も忘(わす)れないように ... また一つ夏が終(お)わって、花一つを胸に抱(だ)いて、 ... 流る目(ま)蓋(ぶた)の裏(うら)で ... 君が褪せないようにこの詩を ... どうか、どうか君が溢れないように ... WIP","link":"/2019/tutorial/%E3%80%8A%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%E3%80%8B%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"title":"了解 ROS image_transport 和 cv_bridge","text":"当我们需要在 ROS 节点间传递数据时，首先考虑使用 common_msgs 中已经提供的 messages。因为通用 ROS 包使用这些 msg，一般来说需要的功能已经被实现而不用自己手打。如果需要传递图片，sensor_msgs 提供了 Image 消息类型，同时有 image_pipeline 可以对 Raw 数据展开简单处理。但 OpenCV 如此流行，很多框架都准备了自带类型与 cv::Mat 相互转换的接口，ROS 也不例外。这篇文章主要探索在 ROS 中使用 OpenCV 处理图片的方法。 在 ROS 环境中使用 OpenCV catkin 只是一个基于 cmake，添加了有关 ROS 的宏的编译系统，因此要在 ROS 环境中单纯地使用 OpenCV 与常规 cmake 设置相同。 CMakeLists.txt 在包级别的 CMakeLists.txt 中加入 OpenCV 库 1234567891011...## System dependencies are found with CMake's conventionsfind_package(OpenCV REQUIRED)...## Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories(include ${catkin_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS})...add_executable(nodeName src/source.cpp ...)## Specify libraries to link a library or executable target againsttarget_link_libraries(nodeName ${catkin_LIBRARIES} ${OpenCV_LIBS}) 源文件 加入 OpenCV 头文件即可，例如 123#include &quot;opencv2/imgproc.hpp&quot;#include &quot;opencv2/imgcodecs.hpp&quot;#include &quot;opencv2/highgui.hpp&quot; AUR 中提供的 ros-melodic-desktop 依赖 opencv3-opt，版本目前为 3.4.6，与 ROS Melodic 一道安装在 /opt，与官方仓库中的 opencv 独立，不过 Ubuntu 上的情况我不太清楚。在 CMakeLists.txt 中链接 OpenCV 库之后 catkin 应该就可以编译带有 OpenCV 的程序了。 sensor_msgs/Image sensors_msgs/Image 是 ROS 中的无损图片类型，其 msg 定义如下： 1234567Header header # 图片信息，包括 timestamp, frame_id 和 originuint32 height # 图片行像素数uint32 width # 图片列像素数string encoding # 指定编码格式，参考 include/sensor_msgs/image_encodings.huint8 is_bigendian # 指定字节顺序uint32 step # 完整一行的长度，单位为字节uint8[] data # 实际图片内容矩阵，大小为 step * rows gencpp 据此生成了三个类型： 1234typedef ::sensor_msgs::Image_&lt;std::allocator&lt;void&gt; &gt; Image;typedef boost::shared_ptr&lt; ::sensor_msgs::Image &gt; ImagePtr;typedef boost::shared_ptr&lt; ::sensor_msgs::Image const&gt; ImageConstPtr; 包括类 Image，以及指向它的两个智能指针。他们分别对应 cv_bridge 处理图片的两种方式，详情见下文。 cv_bridge cv_bridge 包用于实现 sensor_msgs/Image 与 cv::Mat 的互转。 其简化结构如下： 123456789101112131415namespace cv_bridge { typedef boost::shared_ptr&lt;CvImage&gt; CvImagePtr; typedef boost::shared_ptr&lt;CvImage const&gt; CvImageConstPtr; class CvImage { public: CvImage(...); // +1 overloads std_msgs::Header header; std::string encoding; cv::Mat image; sensor_msgs::ImagePtr toImageMsg() const; }; CvImagePtr toCvCopy(...); // 4 overloads CvImageConstPtr toCvShare(...); // 2 overloads} 可以看到，cv_bridge 提供 CvImage 类，在里面直接封装了 cv::Mat，其数据成员基本上与 sensors_msgs/Image 一一对应。 image_transport ROS 推荐使用 image_transport 发布和订阅图片，理由是它有多种传输策略来实现压缩传输和视频流编解码，但是 image_transport 本身只提供 raw 传输，其余方式由插件提供，image_transport_plugins 带有 &quot;compressed&quot; 和 &quot;theora&quot;，分别用于压缩图片和视频。 通用 ROS 安装中的三个图传包为 image_transport - 通过 sensors_msgs/Image 传输原始图片 compressed_image_transport - 使用 JPEG 或 PNG 压缩 theora_image_transport - 应用 Theora 编解码器传输视频 使用配置 要使用上述工具，需修改包级别的 package.xml 和 CMakeLists.txt 以添加依赖并告诉 catkin 导入库并生成相关文件。 package.xml 123456789101112131415...&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;build_depend&gt;image_transport&lt;/build_depend&gt;&lt;build_depend&gt;cv_bridge&lt;/build_depend&gt;&lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;&lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;&lt;exec_depend&gt;sensor_msgs&lt;/exec_depend&gt;&lt;exec_depend&gt;image_transport&lt;/exec_depend&gt;&lt;exec_depend&gt;cv_bridge&lt;/exec_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 在 package.xml 中添加有关依赖，roscpp 用于生成 C++ 代码，std_msgs 是基本消息类型，在构建时需要 message_generation，而运行时只需要 message_runtime。 CMakeLists.txt 1234567891011121314151617181920212223242526272829...## Find catkin macros and librariesfind_package(catkin REQUIRED COMPONENTS roscpp std_msgs sensor_msgs message_generation image_transport cv_bridge)...## Generate added messages and services with any dependencies listed heregenerate_messages( DEPENDENCIES std_msgs sensor_msgs)...## CATKIN_DEPENDS: catkin_packages dependent projects also needcatkin_package( ... CATKIN_DEPENDS sensor_msgs image_transport cv_bridge ...)...add_executable(nodeName src/source.cpp ...)target_link_libraries(nodeName ${catkin_LIBRARIES} ${OpenCV_LIBS})## Add cmake target dependencies of the libraryadd_dependencies(nodeName ${PROJECT_NAME}_gencpp)... 源文件 在源文件中引用相关头文件。 123#include &quot;ros/ros.h&quot;#include &quot;image_transport/image_transport.h&quot;#include &quot;cv_bridge/cv_bridge.h&quot; 其中 cv_bridge.h 已经包含了 sensor_msgs 的头文件： 123#include &lt;sensor_msgs/Image.h&gt;#include &lt;sensor_msgs/CompressedImage.h&gt;#include &lt;sensor_msgs/image_encodings.h&gt;","link":"/2019/tutorial/%E4%BA%86%E8%A7%A3-ROS-image_transport-%E5%92%8C-cv_bridge/"},{"title":"如何使用 Hexo 博客","text":"这篇文章的目的是为本博客的博文作者提供指导，介绍需要准备的工具、写作流程和发布方法。 Hexo 文档 安装 生产环境 Hexo 是静态博客框架，请访问 nodejs.org 或使用包管理器获取 Node.js 8.3 以上版本，同时附带包管理器 npm。 123456# Debian or Ubuntuapt install nodejs# Archpacman -S nodejs npm# Windowswinget install nodejs 之后即可使用 npm 安装 Hexo，建议设置为全局安装： 1npm install -g hexo-cli 请不时更新以获得 bug 修补和新功能。 为方便部署，我们使用 Git 管理版本，访问 git-scm 或使用包管理器安装它。 clone 仓库后首先获取主题： 1$ git submodule update --init --recursive 然后安装依赖： 1$ npm install Hexo 使用 Markdown 创作博文，因此建议使用带有 Markdown 预览的编辑器。准备工作结束之后，就能开始愉快地写作了。 生产环境设置 修改 Icarus 主题 更换 hexo-renderer-markdown-it 服务器 Serverless (GitHub) GitHub Pages 设置 参考 .github/workflow/build_deploy.yml。 每次推送提交到 GitHub 时将自动构建一次以检查错误，推送标注日期的标签同时会触发同步至 Github Pages 和 WaferLab。 WaferLab 服务器 GitLab 设置 流程 1. 新建页面 1$ hexo new [layout] [option] &lt;title&gt; 在制定布局的基础上新建文章，可用选项有 Option Description -p, --path 自定义文章路径 -r, --replace 覆盖指定博文 -s, --slug 自定义文章URL 要新建草稿，使用： 1$ hexo new draft &lt;title&gt; 草稿将不会被渲染，亦不会被展示。草稿完成后可用 publish 发布： 1$ hexo publish [layout] &lt;title&gt; 2. 写博文 使用 Markdown 撰写文章，同时可以使用 HTML 元素实现更灵活的布局和其他功能，Hexo 插件提供了例如资源文件夹管理等实用工具。 使用折叠： 123456&lt;details&gt;&lt;summary&gt;Summary&lt;/summary&gt;Details here.{% codeblock lang:md %}Even code blocks are supported.{% endcodeblock %}&lt;/details&gt; Summary Details here. 1Even code blocks are supported. 高级功能 数学公式支持 使用 \\\\(Tex\\\\)、插入行内公式， $$Tex$$、\\\\[Tex\\\\] 插入行间公式。 公式渲染使用 \\(\\KaTeX\\)。 插入目录 在 Front-matter 中指定 1toc: true Hexo 将在预设位置渲染页面目录，方便长文章的浏览。 标签助手 标签插件的概念来源于 Octopress，可以通过简单的 ejs 标签方便地在文章中插入想要的内容，详情参考文档。 Justified Gallery 展示画廊，将多个图片包裹在 &lt;div class=&quot;justified-gallery&quot;&gt; 与 &lt;/div&gt; 的 HTML 标签对中，如果使用 Markdown 语法来引用图片的话，请在 HTML 标签和 Markdown 之间添加空行。例如： 12345678910&lt;div class=&quot;justified-gallery&quot;&gt;![Elephant](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/leopard.jpeg)&lt;/div&gt; 炫酷的页面元素或样式 这些东西都是 Bulma 框架提供的，请查阅其文档使用各种元素。 3. 发布 写作完成后让 Hexo 渲染更改过的页面： 1hexo g -b: 抛出错误 -w: 跟踪文件更改 source 文件夹中的源文件将被转换为网页，保存在 publish 文件夹中。 在本地预览更改的效果，在发布前及时修改错误： 1hexo s -o: 使用浏览器打开链接 使用 Hexo 的部署功能将网页推送到服务器： 123hexo d# 或者连续完成渲染和部署hexo g -d Hexo 部署使用 git 将网页文件推送至远程的 publish 分支。在服务器上，git hooks 会在接收推送后自动将网站复制到 nginx 的根目录，可以立即在公网上查看更改。 注意直接部署并不会推送博客配置文件以及文章源文件，要备份整个工作区，保存最近对主题或配置的更改，请手动推送 master 分支到服务器，这个过程与部署相独立。 Work in Progress","link":"/2019/tutorial/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E5%8D%9A%E5%AE%A2/"},{"title":"脉搏信号传感器","text":"完成跨阻放大器设计之后，下一步的要求是使用光电传感器检测脉搏信号。本文将介绍关于脉搏信号传感器的知识并展示若干设计方案。 脉搏信号传感器的原理 脉搏信号传感器，或称心率检测器 (HRM)，是用于记录实时心跳信息的装置。 记录心率的意义想必无须赘述。HRM 检测与脉搏有关的特征，分析记录即可得到心率。依不同检测技术而定，HRM 除推断心率以外还能获取更多有关心脏健康情况的信息。 WIP","link":"/2019/tutorial/%E8%84%89%E6%90%8F%E4%BF%A1%E5%8F%B7%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"跨阻放大器 (Transimpedance Amplifier) 简介","text":"模拟电路中的放大模块一般都围绕着运算放大器设计，而运算放大器是直流耦合、差模输入的高增益电压放大器 1。虽然运放本身只能放大差分电压，但通过引入著名的反馈，可以改变增益的物理意义，实现各种形式的转换。 本学期本科生们都会选择加入学院的实验室做实践学习，我翻遍学院教师目录，决定争取跟谢教授研究生物电子方向。与两位小伙伴讨论之后，我花了一下午雕琢出一篇英文咨询邮件表明我们加入的意向，然而我收到的回复竟是 写邮件还不如加微信群，时代变了。 实验室老师和研究生们为有意加入的所有同学开了一场理论讲座，要求是完成按阶段布置的任务，按报告质量排名选择最优秀的同学。Fine，我最不怕的挑战就是这类了，只有付出努力坚持到底的人才得能到最终的胜利。 然而实际的任务要求远没有这么令人热血沸腾，第一个实践是所谓电子信息方向理论实践，在两个月内完成，其要求是 实现 $0\\sim100\\mu A$ 直流电流放大至 $0\\sim3.3V$。 Pretty simple right? 一个有基本电学常识的人能很快地由欧姆定律得到 $100\\mu A$ 的电流乘 $33k$ 的电阻等于 $3.3V$ 电压的等式，那么直接让输入电流通过一个 $33k$ 的电阻流向参考地，那么电阻电流流入一端就是所需的电压输出点了。 这个事实显得此题的问法非常弱智，然而确实应该这样解决吗？答案是 是 亦不是。 跨阻放大器的概念及原理 说使用欧姆定律从电流得到电压的思路正确，是因为这确实是一个理论上可行且简单的方案。在早期的集成电路或是现在我们这些 awful circuit designer 的设计中，可以见到使用大阻值电阻串联从电源轨道上分得参考电压的场景，这种做法可以理解为流过分压电阻的小电流在其两端产生对应压降。值得注意的是，利用分压电阻所得到的电压只作为参考电压，并非为驱动负载而设计。一旦从参考点接入低阻抗的负载，或是受到较强噪声的影响，参考电压将变得不再准确。 解决方案是使用运算放大器，其高输入电阻、低输出电阻的特点帮助正确放大输入信号。 WIP","link":"/2019/tutorial/%E8%B7%A8%E9%98%BB%E6%94%BE%E5%A4%A7%E5%99%A8-Transimpedance-Amplifier-%E7%AE%80%E4%BB%8B/"},{"title":"转录组学分析","text":"这是一篇关于使用 Trinity 进行无参转录组分析的文章，首先会简单介绍转录组学，接着会介绍 Trinity 软件的使用，最后会记录相关的下游分析。 一、转录组学 概述： 转录组广义上指在某一生理条件下，细胞内所有转录组产物的集合，包括：mRNA、ncRNA、rRNA 等；狭义上指所有 mRNA 的集合。 转录组测序的研究对象为特定细胞在某一功能状态下所能转录出来的所有 RNA 的总和，主要包括 mRNA 和 ncRNA。 转录组具有时间特异性、组织特异性、空间特异性等特点。 类型 特点 分析策略 有参转录组 需要所研究的物种有组装注释质量较好基因组序列，一般来说比对效率达到 70% 以上才能满足后续分析。 比对—定量—差异分析—功能富集分析（下游分析） 无参转录组 缺乏相应的质量较高的基因信息，需要从零开始组装分析 组装—定量—差异分析—功能富集分析（下游分析） 下游分析包括：GO 基因功能注释、KEGG 通路分析、mRNA 表达量计算、差异基因筛选、功能和通路富集分析、时间序列分析、共表达网络分析等。 二、Trinity 介绍与使用 基本介绍 Trinity 是由 Broad Institute 开发的转录组 de novo 组装软件，由三个独立的软件模块组成：Inchworm （虫）（C++） 、Chrysalis （蛹）（C++）、Butterfly （蝶）（Java）。三个软件依次来处理大规模的 RNA-seq 的 reads 数据。 组成部分 作用 工作过程 Inchworm （虫）（C++） 序列延伸 a. 将 reads 切为 k-mers (k bp 长度的短片段)b. 利用 Overlap 关系对k-mers 进行延伸 (贪婪算法)c. 输出所有的序列 (“contigs”) Chrysalis （蛹）（C++） 构建 de Brujin graph a. 聚类所有相似区域大于 k-1bp 的 contigsb. 构图 (区分不同的 “components”)c. 将 reads 比对回 components，进行验证 Butterfly （蝶）（Java） 解图，列举转录本 a. 拆分 graph 为线性序列b. 使用 reads 以及 pairs 关系消除错误序列 Trinity使用 1. 下载与安装 trinity 最新版本是 v2.4.0，下载。 123$ nohup wget -c https://github.com/trinityrnaseq/trinityrnaseq/archive/Trinity-v2.4.0.tar.gz 1&gt;trinity.o 2&gt;trinity.e &amp; # 下载$ tar -zxvf Trinity-v2.4.0.tar.gz # 解压$ make # 编译 2. 使用 命令： Trinity --seqType fq --left reads_1.fq --right reads_2.fq --CPU 6 --max_memory 20G 几个重要参数介绍： --seqType 支持输入数据格式为 fq 或者 fa 双端测序：--left 为read1，--right 为 read2，多个样品的 reads 由逗号隔开，不允许出现空格（依版本而定） 单端测序：--single 加上文件 多个样品的 reads 由逗号隔开，不允许出现空格（依版本而定） --CPU 软件所用 CPU 数量 --max_memory 内存控制（组装过程中，jellyfish 这一步是最耗费资源的一步 所以这个内存主要由 jellyfish 控制） --SS_lib_type RF 链特异性文库需要加上这个参数，其中 RF 表示文库的构建方法，点这了解，最好看看 --no_run_butterfly 不进行 butterfly 步骤，在 Chrysalis 这一步完成后中断 --no_run_quantifygraph 不进行 quantifygraph 这一步 --output trinity 的输出文件夹，默认在trinity_out_dir/Trinity.fasta --no_version_check 不汇报版本信息 结果 最终会得到一个 Trinity.fasta 的文件，在同文件夹下还会有其他的中间过程产生的文件，其中这个文件最为重要，是最终的组装结果。 三、下游分析（有待完善） 1. GO功能注释 2. KEGG通路分析 3. 差异基因分析与筛选 4. 功能和通路富集分析 5. 结果可视化（火山图、箱线图、MAplot、pheatmap等） 参考资料 官方文档 介绍博客 无参转录组分析 转录组学知识点 可视化分析（重点火山图） 介绍博客（Trinity参数）","link":"/2019/tutorial/%E8%BD%AC%E5%BD%95%E7%BB%84%E5%AD%A6%E5%88%86%E6%9E%90/"},{"title":"选择合适的测距传感器","text":"常用测距传感器比较表 内容摘录自北醒论坛🙃。 传感器 应用 优势 劣势 超声波传感器 工业质量监控、直径和尺寸检测液位检测机器人避障汽车避障智能家居 无任何机械传动部件，不怕电磁干扰，不怕酸碱等强腐蚀性液体，稳定性较强。 频率高、波长短、绕射现象小，特别是方向性好，能够成为射线而定向传播。 对液体、固体的穿透本领很大，尤其在阳光下不透明的固体。 抗干扰能力弱，任何声学噪声都可能干扰传感器的正常输出，两个相同频率的超声波传感器放在一起，会产生声学串扰。同时会受到烟雾、灰尘、雨滴的干扰。 报错率较高，发射角度较大，针对障碍物较多时，反射回来的声波较多，干扰较多。 测量范围有限，测量范围通常在百米以内，不适合超远距离探测。 测量精度低，超声波测距传感器的测量精度通常是厘米级的。 只能检测平面介质，例如声波被58度斜面接收到声音之后，声波无法正常传回接收器。 不利于测量高速移动的物体，由于超声波利用声音速度传播，相较于利用光学传感器测量，响应时间比较长。 毫米波传感器 汽车辅助驾驶智能交通工业安防无人机定高智能家居 探测距离远，通常都可以在百米外探测。 抗干扰能力强，全天候工作，穿透雾、烟、灰尘的能力强。 针对多目标探测有优势。 探测精度低，好的线性调频不易获得，影响距离分辨率。 易受电磁干扰，产生误报。 针对细小或者微小的物体测距识别较差。 在防空环境中，不可避免的会出现距离模糊和速度模糊。 激光雷达 物位计 (物料、液体)智能交通汽车辅助驾驶工业安防无人机定高、仿地飞行智能家居 精度高，在测距、识别障碍物方面最为准确，黑夜中也可工作。 内部无任何机械传动部件，寿命较旋转激光雷达高，稳定性较强。 探测距离适中。 测量方式多样，包括单点测量及面阵测量。 安装便捷，具有体积小、质量轻，功耗小，价格优势非常明显。 在雨雪雾霾天，沙尘暴等恶劣天气中开启会影响测距量程。 量程有限，针对200米以内的目标探测精准。 针对黑色高亮物体识别量程有衰减。","link":"/2019/tutorial/%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%B5%8B%E8%B7%9D%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"不定式","text":"在寻找涉及单一独立变量的函数的极限时，如果可以把它表示为多个函数通过基本初等函数运算的组合，通常可以代入每个函数的极限求得结果。如果在代入每个函数的极限后仍无法确定极限的值，则待求极限的函数被称为不定式 (Indeterminate form)[1][2]。 为什么代入各极限后仍无法确定极限呢，只可能因为出现了未定义的运算。这些表达式通常涉及 \\(0\\), \\(1\\), \\(\\infty\\)，常见的不定式类型如下： \\[\\frac{0}{0},\\ \\frac{\\infty}{\\infty},\\ 0\\times\\infty,\\ \\infty-\\infty,\\ 0^0,\\ \\infty^0\\text{ and }1^\\infty\\] Quotient Indeterminate Forms 除式是最常见的不定式形式，即在计算两个函数的比值 \\(\\frac{f(x)}{g(x)}\\) 的极限时出现 \\(\\frac{0}{0}\\) 或 \\(\\frac{\\infty}{\\infty}\\)。这一类型最经典的例子是微分，考虑如下极限： \\[ \\lim\\limits_{\\Delta\\to0}\\frac{f(x+\\Delta)-f(x)}{\\Delta} \\] 这种定义下的微分计算是 \\(\\frac{0}{0}\\) 型的不定式。 若分子和分母都可微，分母导数不为零，即可使用洛必达法则计算不定式极限。但在使用洛必达法则前，也可以考虑如下解决方法。 0/0 型不定式 尝试因式分解，约去使分母变成零的因子。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to1}\\frac{x^2+x-2}{x^2-1}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to1}\\frac{x^2+x-2}{x^2-1}&amp;= \\lim\\limits_{x\\to1}\\frac{(x-1)(x+2)}{(x-1)(x+1)} \\\\ &amp;=\\lim\\limits_{x\\to1}\\frac{x+2}{x+1} \\\\ &amp;= \\frac{3}{2} \\end{aligned} \\] 这里只能约去分子分母上相同的因式，而且因式的极限存在。在使用上述微分定义推导导数时，目标是去掉分母上的无穷小后再求极限，但到底能不能直接约去无穷小是个值得思考的问题。在牛顿和莱布尼茨的时代，对无穷小的处理存在前后矛盾，令人难以理解微积分的逻辑，直到十九世纪柯西和魏尔施特拉斯的工作建立了严格的极限和实数理论，才解决了微积分的严密性问题，把微积分的无矛盾性问题归结为实数系统的无矛盾问题。所以说，微积分得以严密化的基础是：实数域的完备性（或连续性）。 ∞/∞ 型不定式 分子分母同时除以自变量的最高次幂。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\frac{4x^4+2x^2-1}{3x^4-5x^3}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to\\infty}\\frac{4x^4+2x^2-1}{3x^4-5x^3}&amp;= \\lim\\limits_{x\\to\\infty} \\cfrac{4+\\cfrac{2}{x^2}-\\cfrac{1}{x^4}} {3-\\cfrac{5}{x}} \\\\ &amp;= \\frac{4}{3} \\end{aligned} \\] 显然，对趋于无穷的极限而言，当分母幂次高于分子，极限为零；分子幂次高于分母，极限为无穷；只有分子分母幂次相等，极限才是最高次幂系数的商。 当然使用洛必达法则能更快解决问题。 Other Indeterminate Forms 其他形式的不定式可以通过恒等变形转换为除式形式，再使用以上方法计算极限。 0 × ∞ 型不定式 \\(0\\times\\infty=\\cfrac{0}{\\frac{1}{\\infty}}=\\cfrac{\\infty}{\\frac{1}{0}}\\) 例：求 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x\\cdot\\ln(x)\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to0^+}x\\cdot\\ln(x)&amp;= \\lim\\limits_{x\\to0^+}\\cfrac{\\ln(x)}{\\cfrac{1}{x}} \\quad\\left(\\frac{\\infty}{\\infty}\\right) \\\\ &amp;= \\lim\\limits_{x\\to0^+}\\cfrac{\\cfrac{1}{x}}{-\\cfrac{1}{x^2}} \\quad\\text{(L’Hopital)} \\\\ &amp;= \\lim\\limits_{x\\to0^+}\\cfrac{1}{-\\cfrac{1}{x}} \\\\ &amp;= 0 \\end{aligned} \\] ∞ - ∞ 型不定式 通分或进行分子有理化。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to1}\\left(\\frac{x}{x-1}-\\frac{2}{x^2-1}\\right)\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to1}\\left(\\frac{x}{x-1}-\\frac{2}{x^2-1}\\right)&amp;= \\lim\\limits_{x\\to1}\\frac{x(x+1)-2}{(x-1)(x+1)} \\quad\\left(\\frac{0}{0}\\right) \\\\ &amp;= \\lim\\limits_{x\\to1}\\frac{(x-1)(x+2)}{(x-1)(x+1)} \\\\ &amp;= \\frac{3}{2} \\end{aligned} \\] 例：求 \\(\\displaystyle\\lim\\limits_{x\\to+\\infty}\\sqrt{x+1}-\\sqrt{x}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to+\\infty}\\sqrt{x+1}-\\sqrt{x}&amp;= \\lim\\limits_{x\\to+\\infty}\\cfrac{x+1-x}{\\sqrt{x+1}+\\sqrt{x}} \\\\ &amp;= 0 \\end{aligned} \\] 指数型不定式 剩下三种不定式类型 \\(0^0\\)、\\(\\infty^0\\)、\\(1^\\infty\\)。注意不要靠直觉判断其极限，可以使用对数函数的性质将其转换为容易处理的形式。 \\[ \\begin{aligned} y(x) &amp;= e^{\\ln{y(x)}} \\\\ \\lim\\limits_{x\\to c}f(x)^{g(x)}&amp;= \\lim\\limits_{x\\to c}\\exp\\left(g(x)\\cdot\\ln{f(x)}\\right) \\end{aligned} \\] 如果转换为乘法后仍不足以解决问题，可以再变形为除式。因此处理这类问题的方法是令待求极限的函数为 \\(y(x)\\)，然后试求 \\(\\ln{y(x)}\\) 的极限，最后求指数函数。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\left(1+\\frac{5}{x}\\right)^x\\) 令 \\(y = \\left(1+\\frac{5}{x}\\right)^x\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to\\infty}\\ln{y}&amp;= \\lim\\limits_{x\\to\\infty}x\\cdot\\ln\\left(1+\\frac{5}{x}\\right) \\quad(\\infty\\times0) \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{\\ln\\left(1+\\frac{5}{x}\\right)}{\\frac{1}{x}} \\quad(\\frac{0}{0}) \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{\\frac{1}{1+\\frac{5}{x}}\\left(-\\frac{5}{x^2}\\right)} {-\\frac{1}{x^2}}\\quad\\text{(L’Hopital)} \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{5}{1+\\frac{5}{x}} \\\\ &amp;= 5 \\end{aligned} \\] 则 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\left(1+\\frac{5}{x}\\right)^x=e^5\\) 例：求 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x^{\\frac{1}{\\ln{x}}}\\) 令 \\(y = x^{\\frac{1}{\\ln{x}}}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to0^+}\\ln{y}&amp;= \\lim\\limits_{x\\to0^+}\\frac{1}{\\ln{x}}\\cdot\\ln{x} \\\\ &amp;= 1 \\end{aligned} \\] 则 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x^{\\frac{1}{\\ln{x}}}=e\\) 如果不属于以上所述的七种类型，其他形似不定式的形式都是可以直接判断结果的，它们并不是不定式，例如： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\infty\\times\\infty=\\infty \\\\ 0^{\\infty}=0 \\\\ 0^{-\\infty}=\\infty \\\\ \\infty^{\\infty}=\\infty \\\\ \\infty^{-\\infty}=0 \\\\ \\end{array} \\] 所有指数函数的例子中要求底数非负，否则指数函数未定义。 Wikipedia ↩︎ Brilliant ↩︎","link":"/2020/note/Advanced-Mathematics/%E4%B8%8D%E5%AE%9A%E5%BC%8F/"},{"title":"数列和函数的极限","text":"数列 Wikipedia 数列指的是一列数。“一列”指出其至少具有一维，即有序性。我们用正整数为每一项编号，\\(a_1,a_2,\\dotsc,a_n,\\dotsc\\) 表示无穷数列，简称数列，记作 \\({a_n}\\)。 如果有通项 \\(a_n\\) 的解析式，那么数列可以看成定义在正整数集上的函数 \\(f:\\Z^+\\to y\\)：\\[f(n)=a_n,\\ n=1,2, \\dotsc\\] 数列的极限 Wikipedia \\(\\epsilon-N\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{n\\to\\infty}a_n=l \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist N&gt;0,\\ \\forall n&gt;N\\implies |a_n-l|&lt;\\epsilon \\end{array} \\] 若极限 \\(l\\) 存在，则称数列收敛 (convergent)，否则发散 (divergent)。 数列极限的性质 夹逼定理 (squeeze theorem) \\[ \\def\\arraystretch{1.5} \\begin{array}{l} \\exist N_0\\in\\Z^+,\\text{ if } a_n\\leqslant b_n\\leqslant c_n,\\forall n&gt;N_0,\\\\ \\text{ and}\\lim\\limits_{n\\to\\infty} a_n=\\lim\\limits_{n\\to\\infty}b_n=l,\\\\ \\text{ then}\\lim\\limits_{n\\to\\infty}c_n=l \\end{array} \\] 不等式：极限 \\(\\implies\\) 数列 2 的推论：由极限判断数列符号 不等式：数列 \\(\\implies\\) 极限 四则运算 注意四则运算的前提是两个数列都收敛。 四则运算可以推广到有限个数列的四则运算，但对无限次运算不一定成立。 数列收敛的充要条件是所有子数列都收敛，所有极限与原数列极限相同。 证明数列发散的方法 利用 6，由子数列发散或收敛与不同值证明原数列发散。 证明数列收敛的方法 利用定义。\\(N\\) 的取值决定于 \\(\\epsilon\\)，不需要求得最小的 \\(N\\)。 利用实数域的完备性：单调有界数列必有极限，但没有给出求极限的方法。 夹逼定理。 通过四则运算得到重要极限的组合。 重要极限 例：证明 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n\\) 存在。 证明： 证明 \\(a_n=\\left(1+\\frac{1}{n}\\right)^n\\) 递增，即 \\[ \\begin{aligned} \\left(1+\\frac{1}{n}\\right)^n&amp;&lt;\\left(1+\\frac{1}{n+1}\\right)^{n+1}\\\\ \\implies\\sqrt[n+1]{\\left(1+\\frac{1}{n}\\right)^n}&amp;&lt;\\frac{n+2}{n+1} \\end{aligned} \\] 在不等关系中遇到 \\(\\sqrt[n]{x^n}\\)，即几何平均值，可以考虑使用均值不等式： \\[ \\sqrt[n+1]{\\left(1+\\frac{1}{n}\\right)^n} &lt;\\frac{n\\left(1+\\frac{1}{n}\\right)+1}{n+1} =\\frac{n+2}{n+1} \\] which is amazing, 为什么不等式在这里恰好合适呢，我暂时没有头绪。 根据实数域的完备性，还需要给出数列有界的条件，试证明 \\(a_n&lt;4\\)： \\[ 1+\\frac{1}{n}&lt;\\sqrt[n]{4} \\] 在这里直接使用均值不等式方向不对，所以需要交换一下位置。 \\[ \\begin{gathered} \\frac{1}{4}&lt;\\left(\\frac{n}{n+1}\\right)^n\\\\ \\implies\\sqrt[n]{\\frac{1}{4}}= \\sqrt[n]{\\frac{1}{2}\\sdot\\frac{1}{2}\\cdot 1\\dotsm 1} &lt;\\frac{\\frac{1}{2}+\\frac{1}{2}+n-2}{n} =\\frac{n-1}{n}\\\\ =1-\\frac{1}{n}&lt;1-\\frac{1}{n+1}=\\frac{n}{n+1} \\end{gathered} \\] 这里需要拼一下根号下的乘积，应该只有这种组合可以简单地得到结论，属于技巧性操作。 由例题我们得知 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n\\) 存在，这个极限值记为 \\(e\\)： \\[\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n=e\\] 也就是著名的自然对数的底数，这一极限是 \\(e\\) 的定义式。 \\(e\\approx2.718281828\\)，小数点后九位非常有规律所以其近似值并不难记。相信大家看过一些关于 \\(e\\) 意义的精彩解读，它无疑是数学中最重要的常数之一，尤其对理工科而言，它是联系不同域的桥梁。 例：求 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n\\) 解：观察通项形式，思路应该是通过四则运算将其分解为重要极限。 \\[ \\begin{aligned} \\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n &amp;=\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{\\frac{n+1}{2}}\\right) ^{\\frac{n+1}{2}\\cdot 2-1}\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\left[\\left(1+\\frac{1}{\\frac{n+1}{2}}\\right) ^\\frac{n+1}{2}\\right]^2\\left(1+\\frac{2}{n+1}\\right)^{-1} \\end{aligned} \\] 注意每一项的极限都存在，因此 \\[ \\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n=e^2 \\] 函数的极限 趋于无穷：\\(\\epsilon-X\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to+\\infty}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist X&gt;0,\\ \\forall x&gt;X\\implies |f(x)-A|&lt;\\epsilon \\end{array} \\] \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to-\\infty}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist X&gt;0,\\ \\forall x&lt;-X\\implies |f(x)-A|&lt;\\epsilon \\end{array} \\] 趋于有限值：\\(\\epsilon-\\delta\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } 0&lt;|x-x_0|&lt;\\delta \\end{array} \\] 注意：函数极限存在与否与函数在 \\(x_0\\) 点是否有定义没有关系，\\(x\\) 落在 \\(x_0\\) 的去心邻域中。 单侧极限： 左极限： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0^-}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } x_0-\\delta&lt;x&lt;x_0 \\end{array} \\] 右极限： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0^+}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } x_0&lt;x&lt;x_0+\\delta \\end{array} \\] 函数极限的性质 极限存在定理 \\[ \\def\\arraystretch{1.5} \\begin{array}{l} \\lim\\limits_{x\\to x_0}f(x)=A \\iff\\\\ \\lim\\limits_{x\\to x_0^-}f(x) =\\lim\\limits_{x\\to x_0^+}f(x) =A \\end{array} \\] 左右极限存在且相等 \\(\\iff\\) 函数极限存在 四则运算 有关不定式的情况请参考Post not found: Note/Advanced-Mathematics/不定式 这里。","link":"/2020/note/Advanced-Mathematics/%E6%95%B0%E5%88%97%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/"},{"title":"高等数学目录","text":"简介 第一章：初等函数 1.3,4：Post not found: Note/Advanced-Mathematics/数列和函数的极限 WIP","link":"/2020/note/Advanced-Mathematics/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E7%9B%AE%E5%BD%95/"},{"title":"C# Cheat Sheet","text":"C# (pronounced &quot;see sharp&quot;) is a modern, object-oriented, and type-safe programming language. C# features: Object-oriented Garbage collection: Automatically reclaims memory occupied by unreachable unused objects. Nullable types: guard against variables that don't refer to allocated objects. Exception handling: provides a structural and extensible approach to error detection and recovery. Lambda expressions: support functional programming techniques. Language integrated query (LINQ): a syntax that creates a common pattern for working with data from any sources. Asynchronous operations: provides syntax for building distributed systems. Unified type system: all types including primitive types inherit from a single root object type. Dynamic allocation of objects In-line storage of lightweight structure Generic methods and types Iterators C# programs run on .NET, a virtual execution system that called the common language runtime (CLR) and a set of class libraries. The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard. The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly. Source code written in C# is compiled into an intermediate language (IL) that conforms to the CLI specification. The IL code and resource are stored in an assembly, typically with an extension of .dll. An assembly contains a manifest that provides information about the assembly's types, version and cultures. When the C# program is executed, the assembly is loaded into the CLR. The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions. Code that's executed by the CLR is sometimes referred to as &quot;managed code&quot;. &quot;Unmanaged code&quot; is compiled into native machine language that targets a specific platform. C# Hello World 1234567using System;class Hello { static void Main() { Console.WriteLine(&quot;Hello, World!&quot;); }} Types and Variables Value types Simple types Signed integral: sbyte, short, int, long Unsigned integral: byte, short, int, ulong Unicode characters: char, which represents a UTF-16 code unit IEEE binary floating-point: float, double High-precision decimal floating-point: decimal Boolean: bool, which represents Boolean values - values that are either true or false Enum types: User defined types of the form enum E {...}. An enum type is a distinct type with named constants. Every enum type has an underlying type, which must be one of the eight integral types. Struct types: User defined types of the form struct S {...} Nullable value types Extensions of all other types with a null value Tuple value types User-defined types of the form (T1, T2, ...) Reference types class types Ultimate base class of all other types: object Unicode strings: string, which represents a sequence of UTF-16 code units User-defined types of the form class C {...} Interface types User-defined types of the form interface I {...} Array types Single-dimensional, multi-dimensional, and jagged. For example: int[], int[,], and int[][] Delegate types User defined types of the form delegate int D {...} C# keyword int is an alias of the .NET Class Library type System.Int32. decimal has more precision than float and double while consuming more memory. m or M : literal suffix. String Formatting String concatenation 1string str = &quot;There are &quot; + 12 + &quot; apples.&quot;; // There are 12 apples. String interpolation 123string name = &quot;Speed&quot;;string value = &quot;120&quot;;string message = $&quot;{name}: {value}&quot;; // Speed: 120 String interpolation can be combined with verbatim literal. String interpolation symbol $ should be placed before verbatim literal prefix symbol @. 12string projectName = &quot;C#-Cheat-Sheet&quot;;string path = $@&quot;C:\\Output\\{projectName}\\Data&quot;; // C:\\Output\\C#-Cheat-Sheet\\Data Mathematical Operation Basic operation Decimal type 1decimal quotient = 7.0m / 3; // 2.3333333333333333333333333333 Calling Methods From the .NET Class Library Creating an instance of a class 1Random dice = new Random(); Stateless method (static method) 1Console.Write(&quot;abc&quot;); Stateful method (instance method) 1dice.Next(); // Depends on system time. Execution Flow if-else statement 1234567if (condition1) { // Do sth.} else if (condition2) { // Do others.} else { // What to do.} foreach statement 1234string[] names = {&quot;Alex&quot;, &quot;Bill&quot;, &quot;Charlie&quot;};foreach (var name in names) { // Alex Console.WriteLine(name); // Bill} // Charlie Conditional operator (ternary conditional operator) 12int saleAmount = 100;int discount = saleAmount &gt; 50 ? 20 : 10; switch-case statement 1234567891011121314int dataCategory = 1;switch (dataCategory) { case 1: case 2: // Do sth. break; case 3: // Do others. break; default: // Default action. break;} for statement 123456for (int i = 0; i &lt; 10; i++) { Console.WriteLine(i); if (i == 5) { break; }} do-while statement 1234567Random random = new Random();int current = 0;do { current = random.Next(1, 11); Console.WriteLine(current);} while (current != 5); while statement 123456789101112Random random = new Random();int current = random.Next(1, 11);while (current != 5) { if (current &gt; 6) { continue; } Console.WriteLine(current); current = random.Next(1, 11);}Console.WriteLine($&quot;Last number: {current}&quot;); Data Structure Array 12string[] slogans = new string[3];string[] studentIDs = { &quot;A123&quot;, &quot;B234&quot;, &quot;C345&quot; }; Properties Length 1int len = studentIDs.Length; Scope and Namespace 123456789using System;namespace MyNewApp { class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); } }} Child-namespace 123namespace MyNewApp.Data { // Classes} Calling a method in the same class 1234567891011121314151617using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Calling a method from a different class 12345678910111213141516171819using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Utility.Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } } class Utility { public static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Referencing a class in a different namespace 123456789101112131415161718192021using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Utilities.Utility.Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } }}namespace MyNewApp.Utilities { class Utility { public static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Work in Progress","link":"/2021/note/C-Sharp/C-Sharp-Cheat-Sheet/"},{"title":"Basic MOS Device Physics","text":"MOS I/V Characteristics Derive the current through MOSFETs as a function of the terminal voltages. Threshold Voltage A channel of charge carriers is formed under the gate oxide between source and drain when the gate voltage \\(V_G\\) reaches a sufficiently positive value, the threshold voltage \\(V_{TH}\\). The transistor is said to be &quot;turn on&quot; and the interface is &quot;inverted&quot;. If \\(V_G\\) continues to rise, the charge in the depletion region remains relatively constant while the channel charge density increases, meaning lower resistance between source and drain. In reality, the &quot;turn-on&quot; behavior is a continuous function of the gate voltage, leaving no unambiguous \\(V_{TH}\\) out there. For practice, it can be proved that \\[ V_{TH}=\\Phi_{MS}+2\\Phi_F+\\frac{Q_{dep}}{C_{ox}} \\tag{2.1} \\] where \\(\\Phi_{MS}\\) is the difference between the work function of the polysilicon gate and the silicon substrate, \\(\\Phi_F=(kT/q)\\ln(N_{sub}/n_i)\\), \\(k\\) is Boltzmann's constant, \\(q\\) is the electron charge, \\(N_{sub}\\) is the doping density of the substrate, \\(n_i\\) is the density of electrons in undoped silicon, \\(Q_{dep}\\) is the charge in the depletion region, and \\(C_{ox}\\) is the gate-oxide capacitance per unit area. Derivation of I/V Characteristics For NMOS: Linear Region \\(V_{DS}&lt;V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=\\mu_nC_{ox}\\frac{W}{L} \\left[(V_{GS}-V_{TH})V_{DS} -\\frac{1}{2}V_{DS}^2\\right] \\tag{2.8}\\] Saturation Region \\(V_{DS}\\geqslant V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=\\frac{1}{2}\\mu_nC_{ox}\\frac{W}{L} (V_{GS}-V_{TH})^2\\tag{2.13}\\] For PMOS: Linear Region \\(V_{DS}&lt;V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=-\\mu_pC_{ox}\\frac{W}{L} \\left[(V_{GS}-V_{TH})V_{DS} -\\frac{1}{2}V_{DS}^2\\right] \\tag{2.15}\\] Saturation Region \\(V_{DS}\\geqslant V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=-\\frac{1}{2}\\mu_pC_{ox}\\frac{W}{L} (V_{GS}-V_{TH})^2\\tag{2.16}\\] MOS Transconductance In saturation region: \\[ \\begin{aligned} g_m&=\\left.\\frac{\\partial I_{DS}} {\\partial V_{GS}}\\right|_{\\text{VDS const.}} \\\\ &=\\mu_nC_{ox}\\frac{W}{L}(V_{GS}-V_{TH}) \\end{aligned} \\tag{2.18} \\] or: \\[ \\begin{aligned} g_m&amp;=\\sqrt{2\\mu_nC_{ox}\\frac{W}{L}I_D} \\\\ &amp;=\\frac{2I_D}{V_{GS}-V_{TH}} \\end{aligned} \\tag{2.20} \\] Second-Order Effects Body Effect When the bulk voltage of an NFET drops below the source voltage, wider depletion region is formed. As \\(V_B\\) drops and \\(Q_d\\) increases, \\(V_{TH}\\) also increases. This phenomenon is called the body effect or the back-gate effect. It can be proved that with body effect, \\[ V_{TH}=V_{TH0}+\\gamma\\left(\\sqrt{2\\Phi_F+V_{SB}}-\\sqrt{|2\\Phi_F|}\\right) \\tag{2.23} \\] where \\(V_{TH0}\\) is given by \\((2.1)\\), \\(\\gamma=\\sqrt{2q\\epsilon_{si}N_{sub}}/C_{ox}\\) denotes the body effect coefficient, and \\(V_{SB}\\) is the source-bulk voltage difference. Channel-Length Modulation The actual length of the channel gradually decreases as the potential difference between the gate and the drain decreases. In \\((2.13)\\), \\(L\\) is in fact a function of \\(V_{DS}\\). This effect is called channel-length modulation. We have, in saturation, \\[ I_{DS}\\approx\\frac{1}{2}\\mu_nC_{ox}\\frac{W}{L}(V_{GS}-V_{TH})^2 (1+\\lambda V_{DS})\\tag{2.27} \\] where \\(\\lambda\\) is the &quot;channel-length modulation coefficient&quot;. Notice that with channel-length modulation, some of the expressions derived for \\(g_m\\) must be modified. Subthreshold Conduction In reality, for \\(V_{GS}\\approx V_{TH}\\), a &quot;weak&quot; inversion layer still exists and some current flows from drain to source. Even for \\(V_{GS}&lt;V_{TH}\\), \\(I_{DS}\\) is present but it exhibits an exponential dependence on \\(V_{GS}\\). Voltage Limitations A high gate-source voltage can breaks down the gate oxide irreversibly. In short-channel devices, an excessively large drain-source voltage widens the depletion region around the drain so much that it touches that around the source, creating a very large drain current. MOS Device Models WIP","link":"/2020/note/Design-of-Analog-Integrated-Circuit/Basic-MOS-Device-Physics/"},{"title":"Homework1","text":"某公司设计的某款芯片面积为 1mm\\(\\times\\)1mm，于某 12 寸晶圆厂流片生产， 忽略划片槽占用面积，每片晶圆大概能产出多少颗芯片裸片？ 如果划片槽宽度为 100μm，每片晶圆大概能产出多少颗芯片？ 如果划片槽宽度减少为 50μm，每片晶圆大概能产出多少颗芯片？ 如果通过优化电路设计，芯片面积可以缩减至 0.8mm\\(\\times\\)0.8mm，在划片槽宽度分别为 100μm 和 50μm 时，每片晶圆大概能产出多少颗芯片？ 针对以上问题，做出相应图表并进行相关分析和论述。 关键点 12 寸晶圆的直径实际上是 300mm，从中心开始向边缘刻画芯片。因为芯片通常是矩形，并不能完全覆盖晶圆，因此需要考虑多种因素减少浪费的晶圆面积。 芯片面积 芯片面积是影响晶圆生产芯片数量的最主要因素。实现相同功能的前提下，更先进的制造技术和电路设计可以缩小芯片的面积。 20mm Die 10mm Die 145 624 观察在晶圆上分别制造边长为 20mm 和 10mm 的方形芯片的排列效果。在芯片紧密排列时，单块芯片更小的面积可以增加晶圆利用率。这可以近似为割圆为方，De Vries 博士在他的论文 Investigation of gross die per wafer formulas 中给出的近似公式之一是 \\[ DPW=\\frac{\\pi d^2}{4S}-\\frac{\\pi d}{\\sqrt{2S}} \\] 其中 \\(d\\) 指晶圆直径，\\(S\\) 指方形芯片面积。 划片槽宽度 当然芯片间需要留出划片槽 (scribe-line) 方便切割芯片，显然划片槽越宽，可用的晶圆面积越少。下面是边长 10mm 的方形芯片间分别留出 1mm 和 500μm 划片槽的效果。 1mm Scribe-line 500μm Scribe-line 537 593 考虑划片槽的存在，把芯片右侧和下侧的划片槽面积并入芯片面积计算，仍然可以使用相同的近似公式。 对齐方式 划分芯片网格的时候，中心对齐方式对排列芯片的结果有一点影响，主要有 Die Centering 和 Wafer Centering 两种方式，前者使晶圆中点对齐纵横划片槽的交点，后者使晶圆中点对齐最中心芯片的中心点。对边长 25mm、划片槽宽 1mm 的方形芯片，两种对齐方式的效果如下。 Die Centering Wafer Centering 80 89 不过芯片面积越小，对齐方式对芯片总数的影响越小，近似计算时可以忽略。 结论 现在使用近似公式估计芯片数量，为衡量估计的准确度可以写一个程序计算接近乎精确的结果，我修改了一个 Javascript 计算器让其能够给出题目条件下的芯片数量，同时还可以生成图形以直观地观察芯片的排列，本文中所有的图片都是该程序生成的。 近似计算 近似公式中 \\(d\\) = 300mm，设芯片边长为 \\(a\\)，则 \\(S_0=a^2\\)。设划片槽宽度为 \\(t\\)，可考虑 \\(S_1=(a+t)^2\\)。将题目中的各种情况带入近似公式得到结果如下： 1mm Die 0.8mm Die 100μm Scribe-line 57812 86525 50μm Scribe-line 63479 97051 No Scribe-line 70019 109614 精确计算 程序计算的结果如下，布局使用 Wafer Centering： 1mm Die 0.8mm Die 100μm Scribe-line 57928 86668 50μm Scribe-line 63561 97192 No Scribe-line 70089 109712 1mm\\(\\times\\)1mm 芯片、100μm 划片槽和 0.8mm\\(\\times\\)0.8mm 芯片、50μm 划片槽两种组合的布局示例如图。 似乎近似计算的结果总是略小于精确值，但相对误差不超过 2‰，这对估算而言已经足够好用。","link":"/2020/note/Design-of-Analog-Integrated-Circuit/Homework1/"},{"title":"模拟集成电路设计目录","text":"Introduction We are back to analog design again! It is said that we are living in a digital world. Most of the devices that we used everyday have a digital processor inside. So what's the point of learning analog design? Although from the perspective of quantum mechanics, the basic building elements of the world are discrete, from a macro perspective, human is analog, our perception and behaviors are continuous. The world around us is analog, things would not change instantly since it will require infinite energy. As long as the circuit is still interacting with the real world, an analog portion is necessary. This course focuses on modern analog design with CMOS technology. The reference books are: Razavi, B. (2017). Design of Analog CMOS Integrated Circuits (2nd ed.). New York: McGraw-Hill Education. Baker, R. J. (2010). CMOS Circuit Design, Layout, and Simulation (3rd ed.). Hoboken, NJ: IEEE Press. Chapter 1: Post not found: Note/Design-of-Analog-Integrated-Circuit/Basic-MOS-Device-Physics WIP","link":"/2020/note/Design-of-Analog-Integrated-Circuit/%E6%A8%A1%E6%8B%9F%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95/"},{"title":"VHDL 基本语法","text":"这里只列出可能要考的语句。 并行语句 并行信号赋值 (&lt;=) 使用运算符 &lt;= 为端口或信号赋值。 注意信号赋值语句在顺序语句中也存在，在进程中的信号赋值语句是顺序语句，在进程外的信号赋值语句是并行语句。 1Y &lt;= not (A and B); 条件赋值 (when...else) 优先顺序的条件判断。从第一条条件表达式开始顺序判断，直到最后一个 else。 例：实现三态门 1234architecture when_else of three_state isbegin Z &lt;= A when ENABLE = '1' else 'Z';end architecture when_else; 例：实现 2-4 译码器 1234567architecture when_else of decoder isbegin Z &lt;= &quot;0001&quot; when A = &quot;00&quot; else &quot;0010&quot; when A = &quot;01&quot; else &quot;0100&quot; when A = &quot;10&quot; else &quot;1000&quot;;end architecture when_else; 例：实现带使能的 2-4 译码器 12345678architecture when_else of decoder isbegin Z &lt;= &quot;0001&quot; when (A = &quot;00&quot; and EN = '1') else &quot;0010&quot; when (A = &quot;01&quot; and EN = '1') else &quot;0100&quot; when (A = &quot;10&quot; and EN = '1') else &quot;1000&quot; when (A = &quot;11&quot; and EN = '1') else &quot;0000&quot;;end architecture when_else; 选择赋值 (with...select) 同时进行条件判断。在结尾使用 when others 以包含全部情况。 例：实现七段显示译码器 12345678910111213141516architecture with_select of seven_seg isbegin with A select Z &lt;= &quot;1110111&quot; when &quot;0000&quot;, &quot;0010010&quot; when &quot;0001&quot;, &quot;1011101&quot; when &quot;0010&quot;, &quot;1011011&quot; when &quot;0011&quot;, &quot;0111010&quot; when &quot;0100&quot;, &quot;1101011&quot; when &quot;0101&quot;, &quot;1101111&quot; when &quot;0110&quot;, &quot;1010010&quot; when &quot;0111&quot;, &quot;1111111&quot; when &quot;1000&quot;, &quot;1111011&quot; when &quot;1001&quot;, &quot;1101101&quot; when &quot;1010&quot;|&quot;1011&quot;|&quot;1100&quot;|&quot;1101&quot;|&quot;1110&quot;|&quot;1111&quot;, &quot;0000000&quot; when others;end architecture with_select; 进程语句 (process) 进程语句本身是并行的，其内部的语句按顺序执行，因此可以按软件编程的思想实现算法。必须为进程提供完整的敏感信号表，在敏感信号表中出现的变量和信号发生变化时进程即被激活。 例：使用进程实现优先编码器 123456789101112131415161718architecture sequential of priority_encoder isbegin process (A) is begin if A(3) = '1' then Y &lt;= &quot;11&quot;; elsif A(2) = '1' then Y &lt;= &quot;10&quot;; elsif A(1) = '1' then Y &lt;= &quot;01&quot;; elsif A(0) = '1' then Y &lt;= &quot;00&quot;; else Y &lt;= &quot;00&quot;; end if; end process; VALID &lt;= '1' when A(0) = '1' or A(1) = '1' or A(2) = '1' or A(3) = '1' else '0';end architecture sequential; 元件例化语句 (component) 元件例化体现了 VHDL 模块化设计的思想，通过使用已经定义的元件的实例可以简化设计流程。 例：并联两个 8 bits 加法器实现 16 bits 加法器 12345678910111213141516171819202122232425library IEEE;use IEEE.std_logic_1164.all;use IEEE.numeric_std.all;entity BIT16ADDER is Port(CIN : in std_logic; A : in std_logic_vector(15 downto 0); B : in std_logic_vector(15 downto 0); SUM : out std_logic_vector(15 downto 0); COUT : out std_logic);end BIT16ADDER;architecture Behavioral of BIT16ADDER is component NBitAdder is generic (n : natural := 4); port(A, B : in std_logic_vector(n-1 downto 0); Cin : in std_logic; Sum : out std_logic_vector(n-1 downto 0); Cout : out std_logic); end component NBitAdder; signal CC : STD_LOGIC;begin U1: NBITADDER generic map(n =&gt; 8) port map(A(7 downto 0), B(7 downto 0), CIN, SUM(7 downto 0), CC); U2: NBITADDER generic map(n =&gt; 8) port map(A(15 downto 8), B(15 downto 8), CC, SUM(15 downto 8), COUT);end Behavioral; 顺序语句 顺序语句必须放在进程或子程序中，定义进程和子程序的算法，即并行语句包含顺序语句。 顺序赋值语句 (&lt;= 和 :=) 使用运算符 &lt;= 为端口或信号赋值，使用 := 为变量赋值。 变量的声明的赋值只能在顺序语句中进行，例如进程、函数和过程。 1variable var : std_logic := '0'; if-else 语句 if-else 是最常用的顺序语句，用于流程控制。 123456789if condition1 then block1elsif condition2 then block2elsif condition3 then block3else block4end if; case-when 语句 case-when 语句也是顺序语句，只能在进程中使用，用来选择有明确描述的信号。 例：使用 case-when 实现多路复用器。 12345678910111213architecture case_statement of mux isbeginprocess(A, B, C, D, S) begin case S is when &quot;00&quot; =&gt; Y &lt;= A; when &quot;01&quot; =&gt; Y &lt;= B; when &quot;10&quot; =&gt; Y &lt;= C; when &quot;11&quot; =&gt; Y &lt;= D; when others =&gt; null; end case; end process;end architecture case_statement;","link":"/2019/note/Digital-Integrated-Circuit/VHDL-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"VHDL 简介","text":"背景 VHDL (VHSIC Hardware Description Language, VHSIC (Very High Speed Integrated Circuits)) 是一种硬件描述语言，它可以描述硬件电路的行为，并由综合工具生成相应的网表。主流的 EDA (Electronic Design Automation) 工具都支持 VHDL，其主要的竞争对象是 Verilog HDL，VHDL 可以用于所有数字硬件设计，包括系统级设计、板级设计、ASIC、CPLD 和 FPGA 设计。 VHDL 方法论 硬件描述语言为硬件设计提供了仿真功能，无需真实硬件电路即可观察逻辑行为，错误可以在流片之前修正；同时它也具有模块化设计，能构建可重用的代码。 与一般软件编程语言不同，VHDL 代码有顺序执行和并发执行两种行为。 顺序执行 语句一个接一个被执行，与软件编程语言相同 可以覆盖先前表达式的效果 并发执行 语句同时执行 表达式出现的顺序无关紧要 适合硬件的并发性的建模 VHDL 的方法论包括 抽象 描述系统的不同部分 在抽象层，只关注必要的信息，忽略其他不重要的内容。 模块化 拆分大的组件，使用模块构建每个部分。 层级结构 用子模块构建设计，每个层级可能包含来自不同抽象层的模块。 VHDL 组件 实体和结构 实体 (Entity) 和结构 (Architecture) 是 VHDL 不可或缺的两大组件。 实体 黑盒子 描述输入输出接口和它们的类型 结构 描述电路的功能和/或结构 一个实体可以用多个结构来实现 VHDL 保留字 参考 Xilinx 文档 VHDL 标识符、空格和注释 VHDL 对大小写不敏感。 语句用分号结束。 不要覆盖预定义标识符，例如 std_logic、TIME。 可以使用任意数量的空格、回车来分隔元素。当然建议使用统一的缩进排版增强可读性。 行注释以 -- 开头，正如其他编程语言，鼓励书写规范的注释。 VHDL 常量和开路接口 未使用的组件输入和输出应指定为 open 连接到电源或地：'1' 或 '0' 例 1U1: universal port map(X, Y, open, A, '1'); VHDL Testbench Testbench 用来验证设计的正确性，位于设计层级的最顶层。它有自己的 VHDL 风格，只可用于仿真而不能被综合。 VHDL 标准库 标准逻辑包 IEEE standard logic 1164 九值逻辑枚举类型 'U' - Uninitialized 'X' - Forcing unknown '0' - Forcing 0 '1' - Forcing 1 'Z' - High impedance 'W' - Weak unknown 'L' - Weak 0 'H' - Weak 1 '-' - Don't care 标准逻辑类型的定义为 12type std_ulogic is('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-'); IEEE 1164 标准类型 std_logic 是 std_ulogic 解析后的信号类型 1subtype std_logic is resolved std_ulogic; 这个包位于 IEEE 库内，与工作库相分隔 12library IEEE;use IEEE.std_logic_1164.all; 逻辑向量类型 1type std_logic_vector is array(natural range&lt;&gt;) of std_logic; natural: 预定义子类型，表示从 0 到最大的整数 range&lt;&gt;: 指未定义的范围 例 12std_logic_vector(3 downto 0);std_logic_vector(0 to 7); 数值计算 进行标准逻辑向量的运算 12use IEEE.std_logic_arith.all;use IEEE.std_logic_unsigned.all; VHDL 描述方式 数据流描述123456789101112library IEEE;use IEEE.std_logic_1164.all;entity comb_function is port (A, B, C : in std_logic; Z : out std_logic);end entity comb_function;architecture expression of comb_function isbegin Z &lt;= (not A and B) or (A and C);end architecture expression; 结构化描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172library IEEE;use IEEE.std_logic_1164.all;entity or2 is port (X, Y : in std_logic; Z : out std_logic);end entity or2;architecture ex1 of or2 isbegin Z &lt;= X or Y;end architecture ex1;library IEEE;use IEEE.std_logic_1164.all;entity not1 is port (X : in std_logic; Z : out std_logic);end not1;architecture ex1 of not1 isbegin Z &lt;= not X;end ex1;library IEEE;use IEEE.std_logic_1164.all;entity and2 is port (X, Y : in std_logic; Z : out std_logic);end entity and2;architecture ex1 of and2 isbegin Z &lt;= X and Y;end architecture ex1;library IEEE;use IEEE.std_logic_1164.all;Entity comb_function is port (A, B, C : in std_logic; Z : out std_logic);End entity comb_function;architecture netlist of comb_function is component and2 is port (X, Y : in std_logic; Z : out std_logic); end component and2; component or2 is port (X, Y : in std_logic; Z : out std_logic); end component or2; component not1 is port (X : in std_logic; Z : out std_logic); end component not1; signal P, Q, R : std_logic;begin G1: not1 port map (A, P); G2: and2 port map (P, B, Q); G3: and2 port map (A, C, R); G4: or2 port map (Q, R, Z);end architecture netlist;","link":"/2019/note/Digital-Integrated-Circuit/VHDL-%E7%AE%80%E4%BB%8B/"},{"title":"数字集成电路设计目录","text":"课程介绍 其实有关 FPGA 和 VHDL 的内容有很多，以后可能会更深入地研究下去，但现在只是记录一些应付考试的知识点。 Chapter 0: 可编程逻辑器件 可编程逻辑阵列 (Programmable Logic Array, PLA) 的实现原理是任何组合逻辑函数都可以由积之和 (Sum of Products, SoP) 表示，通过建造大型与或门阵列和可编程内部连结，即可实现可编程组合逻辑。 常见的可编程器件主要有 可编程只读存储器 (Programmable Read Only Memory, PROM) 可编程阵列逻辑 (Programmable Array Logic, PAL) 通用阵列逻辑 (Generic Array Logic, GAL) 复杂可编程逻辑器件 (Complex Programmable Logic Device, CPLD) 现场可编程门阵列 (Field Programmable Gate Array, FPGA) FPGA / CPLD 设计流程 Chapter 1: Post not found: Note/Digital-Integrated-Circuit/组合逻辑与时序逻辑 Chapter 2: Post not found: Note/Digital-Integrated-Circuit/VHDL-简介 Chapter 3: Post not found: Note/Digital-Integrated-Circuit/VHDL-基本语法 Chapter 4: Post not found: Note/Digital-Integrated-Circuit/组合逻辑模块的-VHDL-实现","link":"/2019/note/Digital-Integrated-Circuit/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95/"},{"title":"组合逻辑与时序逻辑","text":"布尔代数基础 逻辑信号只有两个值：0 和 1 正值逻辑：0 表示低电压，1 表示高电压 基本的逻辑门：与、或、非、异或 AND: C = AB OR: C = A + B NOT: C = A' EXCLUSIVE OR: C = A ⊕ B = A'B + AB' 逻辑电路的两种表示方法：真值表和逻辑表达式 具体内容大家应该都知道这里不说了。 逻辑表达式的两种简化方法：布尔代数和卡诺图 单变量定理 X + 0 = X X * 1 = X X + 1 = 1 X * 0 = 0 X + X = X X * X = X (X')' = X X + X' = 1 X * X' = 0 二、三变量定理 X + Y = Y + X X * Y = Y * X (X + Y) + Z = X + (Y + Z) (X * Y) * Z = X * (Y * Z) X * Y+ X * Z = X * (Y + Z) (X + Y) * (X + Z) = X + Y * Z X + X * Y = X X * (X + Y) = X X * Y + X * Y' = X (X + Y) * (X + Y') = X X * Y + X' * Z + Y * Z= X * Y + X' * Z (X + Y) * (X' + Z) * (Y + Z) = (X + Y) * (X' + Z) X + X' * Y = X + Y 多变量定理 德摩根定律 卡诺图大家也懂，按真值表画，暂不提 现代硬件实现：NAND 和 NOR 根据目前的工艺，NAND 门和 NOR 门比 AND 门和 OR 门更容易制造，速度也更快。 AND-OR 逻辑可以转换为 NAND-NAND 逻辑 C = (AB)' = A' + B' OR-AND 逻辑可以转换为 NOR-NOR 逻辑 C = (A + B)' = A'B' 竞争与冒险 组合逻辑与时序逻辑的区别 组合逻辑 时序逻辑 没有存储器件，输出只由当前输入决定。 有记忆功能，输出取决于当前输入和过去的状态。 时序逻辑的两种实现 同步时序 异步时序 所有寄存器都连接至同一个时钟源，所有触发器的状态都在相同时钟沿发生变化。 触发器的时钟来源不全相同，状态变化发生在不同时钟沿。 基本组合逻辑模块 译码器 Decoder 将二进制码翻译成特定对象 编码器 Encoder 与译码器相反，将输入转换为二进制码 优先编码器 Priority encoder 多个输入有效时根据优先级编码 多路复用器 Multiplexer 单向电子开关，从多个输入中选择一个输出 比较器 Comparator 正如其名 加法器 Adder 半加器 将两个二进制比特相加，提供和及进位输出 S = X ⊕ Y Co = X * Y 全加器 将两个二进制比特和进位输入相加，产生和及进位输出 S = X ⊕ Y ⊕ Ci Co = X * Y + X * Ci + Y * Ci 波纹进位加法器 Ripple adder 级联 n 个 1 比特全加器，最坏延迟可从 LSB 直到 MSB 超前进位加法器 Carry-lookahead adder 无需等待低位的运算结果 时序逻辑 触发器和锁存器 触发器 Flip-flop 锁存器 Latch 边缘触发 电平触发 SR 锁存器 S-R latch 锁存器中最简单的一种，也是其他触发器的基本组成部分 带使能端的 SR 锁存器 S-R latch with enable D 锁存器 D latch 使能有效时，输出随输入变化 触发器 Flip-flop D 触发器 D flip-flop 只在边缘触发 下降沿触发 D 触发器 D flip-flop with negative-edge trigger 异步预置重置 D 触发器 D flip-flops with asynchronous preset and clear 同步预置重置 D 触发器 D flip-flops with synchronous preset and clear T 触发器 Trigger flip-flop 仅时钟输入，在每个上升沿变换状态 JK 触发器 JK flip-flop Q = K'Q + JQ' 三态门 Tri-state logic 输出有三种状态：0、1、高阻态 Z 基本时序逻辑模块 计数器 Counter 波纹进位计数器 Ripple counter 同步串行计数器 Synchronous serial counter 同步并行计数器 Synchronous parallel counter 移位寄存器 Shift-register","link":"/2019/note/Digital-Integrated-Circuit/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E4%B8%8E%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/"},{"title":"组合逻辑模块的 VHDL 实现","text":"多路复用器 (Multiplexer) 下面的例子尝试构建 4 to 1 Mux。 使用 with...select 语句 12345678architecture with_select of mux isbegin with S select Y &lt;= A when &quot;00&quot;, B when &quot;01&quot;, C when &quot;10&quot;, D when others;end architecture with_select; 使用 when...else 语句 1234567architecture when_else of mux isbegin Y &lt;= A when S = &quot;00&quot; else B when S = &quot;01&quot; else C when S = &quot;10&quot; else D;end architecture when_else; 使用三态门实现 1234567architecture tri_state of mux isbegin Y &lt;= A when S = &quot;00&quot; else 'Z'; Y &lt;= B when S = &quot;01&quot; else 'Z'; Y &lt;= C when S = &quot;10&quot; else 'Z'; Y &lt;= D when S = &quot;11&quot; else 'Z';end architecture tri_state; 使用 case...when 语句 12345678910111213architecture case_when of mux isbegin process(A, B, C, D, S) is begin case S is when &quot;00&quot; =&gt; Y &lt;= A; when &quot;01&quot; =&gt; Y &lt;= B; when &quot;10&quot; =&gt; Y &lt;= C; when &quot;11&quot; =&gt; Y &lt;= D; when others =&gt; null; end case; end process;end architecture case_when; 编码器 (Encoder) 下面的例子尝试实现 4 to 2 Encoder 使用 with...select 语句 123456789architecture with_select of encoder isbegin with S select Y &lt;= &quot;00&quot; when &quot;0001&quot;, &quot;01&quot; when &quot;0010&quot;, &quot;10&quot; when &quot;0100&quot;, &quot;11&quot; when &quot;1000&quot;, &quot;00&quot; when others;end architecture with_select; 使用 when...else 语句 12345678architecture when_else of encoder isbegin Y &lt;= &quot;00&quot; when S = &quot;0001&quot; else &quot;01&quot; when S = &quot;0010&quot; else &quot;10&quot; when S = &quot;0100&quot; else &quot;11&quot; when S = &quot;1000&quot; else &quot;00&quot;;end architecture when_else; 优先编码器 (Priority encoder) 利用 when...else 语句顺序判断的特性。 123456789architecture when_else of priority_encoder isbegin Y &lt;= &quot;11&quot; when A(3) = '1' else &quot;10&quot; when A(2) = '1' else &quot;01&quot; when A(1) = '1' else &quot;00&quot; when A(0) = '1' else &quot;00&quot;; VALID &lt;= '1' when A(0) = '1' or A(1) = '1' or A(2) = '1' or A(3) = '1' else '0';end architecture when_else; 加法器 (Adder) 使用库提供的 + 运算符。 12345678910111213141516171819202122library IEEE;use IEEE.std_logic_1164.all;use IEEE.std_logic_arith.all;use IEEE.std_logic_unsigned.all;entity NBitAdder is generic (n: natural := 4); port(A, B: in std_logic_vector(n-1 downto 0); Cin : in std_logic; Sum : out std_logic_vector(n-1 downto 0); Cout : out std_logic);end entity NBitAdder;architecture behavioral of NBitAdder is signal result : std_logic_vector(n downto 0); signal carry : std_logic_vector(n downto 0);begin carry &lt;= (0 =&gt; Cin, others =&gt; '0'); result &lt;= ('0' &amp; A) + ('0' &amp; B) + carry; Sum &lt;= result(n-1 downto 0); Cout &lt;= result(n);end architecture behavioral; generic: 声明参数并指定默认值，表明其在例化中可能被赋予其他值。 &amp;: 双目运算符，级联两侧的 bits。 +: 库中对标准逻辑向量重载的加法，得到相同位数的结果，不生成进位。 乘法器 (Multiplier) 使用库提供的 * 运算符。 123456789101112131415library IEEE;use IEEE.std_logic_1164.all;use IEEE.std_logic_ARITH.all;use IEEE.std_logic_UNSIGNED.all;entity unsgnmul4 is Port (A : in std_logic_vector(3 downto 0); B : in std_logic_vector(3 downto 0); PAB : out std_logic_vector(7 downto 0));end unsgnmul4;architecture Behavioral of unsgnmul4 isbegin PAB &lt;= A * B;end Behavioral;","link":"/2019/note/Digital-Integrated-Circuit/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9D%97%E7%9A%84-VHDL-%E5%AE%9E%E7%8E%B0/"},{"title":"Digital Image Fundamentals","text":"Image Sampling and Quantization Representing Digital Image The continuous image is represented by function \\(f(s, t)\\) with two continuous variables, \\(s\\) and \\(t\\). The continuous image can be converted into a digital image, \\(f(x, y)\\), containing \\(M\\) rows and \\(N\\) columns, by sampling and quantization, where \\((x, y)\\) are discrete coordinates. The section of the real plane spanned by the coordinates of an image is called spatial domain, with \\(x\\) and \\(y\\) being referred to as spatial variables or spatial coordinates. In computer processing, the representation of a digital image is an numerical array or matrix: \\[ f(x,y)= \\begin{bmatrix} f(0, 0) &amp; f(0, 1) &amp; \\cdots &amp; f(0, N-1) \\cr f(1, 0) &amp; f(1, 1) &amp; \\cdots &amp; f(1, N-1) \\cr \\vdots &amp; \\vdots &amp; &amp; \\vdots \\cr f(M-1, 0) &amp; f(M-1, 1) &amp; \\cdots &amp; f(M-1, N-1) \\cr \\end{bmatrix} \\tag{2-9} \\] \\[ \\mathbf{A}= \\begin{bmatrix} \\mathnormal{a} _ {0, 0} &amp; \\mathnormal{a} _ {0, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {0, N-1} \\cr \\mathnormal{a} _ {1, 0} &amp; \\mathnormal{a} _ {1, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {1, N-1} \\cr \\vdots &amp; \\vdots &amp; &amp; \\vdots \\cr \\mathnormal{a} _ {M-1, 0} &amp; \\mathnormal{a} _ {M-1, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {M-1, N-1} \\cr \\end{bmatrix} \\tag{2-10} \\] Each element of the matrix is called an image element, picture element, pixel, or pel. We use the terms image and pixel to denote a digital image and its elements. We define the origin of an image at the top left corner. This is a convention based on the fact that many image displays sweep an image starting at the top left and moving to the right, one row at a time. And the first element of a matrix is by convention at the top left of the array. The positive \\(x\\)-axis extends downward and the positive \\(y\\)-axis extends to the right, which is precisely the right-handed Cartesian coordinate system rotated by 90° clockwise. The center of an \\(M \\times N\\) image with origin at \\((0, 0)\\) is obtained by dividing \\(M\\) and \\(N\\) by 2 and rounding down to the nearest integer. Some programing languages (e.g., MATLAB) start indexing at 1 instead of 0. The center in that case is \\((x_c, y_c)=(\\operatorname{floor}(M/2)+1, \\operatorname{floor}(N/2)+1)\\). Obviously, the number of discrete intensity levels, \\(L\\), is usually an integer power of 2. The range of values spanned by the grey scale is referred to as the dynamic range. In digital image processing, we define the dynamic range of an image to be the ratio of the maximum measurable intensity to the minimum measurable intensity level in the system. Another concept is image contrast, which we define as the difference in intensity between the highest and lowest intensity levels in an image. The contrast ratio is the ratio of these two quantities. Linear vs. Coordinate Indexing The convention we mentioned before that uses a 2D coordinate to give a location of a pixel is referred to as coordinate indexing, or subscript indexing. Another type of indexing used intensively in programming image processing algorithm is linear indexing, which consists of a 1-D array based on computing offsets from coordinates \\((0, 0)\\). The matrix used to store a pixel could be row-major or column-major order. And there are two principal types of linear indexing correspondingly. Here is an illustration of column scanning for generating linear indices. Some Basic Relationships Between Pixels Neighbors of a pixel A pixel \\(p\\) at coordinates \\((x, y)\\) has two horizontal and two vertical neighbors with coordinates \\[(x+1, y), (x-1, y), (x, y+1), (x, y-1)\\] This set of pixels, called 4-neighbors of \\(p\\), is denoted \\(N_4(p)\\). The four diagonal neighbors of \\(p\\) have coordinates \\[(x+1, y+1), (x+1, y-1), (x-1, y+1), (x-1, y-1)\\] and are denoted \\(N_D(p)\\). These neighbors, 8 in total, are called the 8-neighbors of \\(p\\), denoted by \\(N_8(p)\\). The set of image locations of neighbors of a point \\(p\\) is called the neighborhood of \\(p\\). The neighborhood is said to be closed if it contains \\(p\\). Otherwise, the neighborhood is said to be open. Adjacency Let \\(V\\) be the set of intensity levels used to define adjacency. If we are dealing with the adjacency of pixels whose values are ranged from \\(0\\) to \\(n-1\\), set \\(V\\) can contain any subset of these \\(n\\) values. We consider three types of adjacency: 4-adjacency: Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are 4-adjacent if \\(q\\) is in the set \\(N_4( p)\\). 8-adjacency: Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are 8-adjacent if \\(q\\) is in the set \\(N_8( p)\\). m-adjacency (aka mixed adjacency): Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are m-adjacent if \\(q\\) is in \\(N_4( p)\\), or \\(q\\) is in \\(N_D( p)\\) and the set \\(N_4( p) \\cap N_4( q)\\) has no pixels whose values are from \\(V\\). Mixed adjacency is a modification of 8-adjacency, and is introduced to eliminate the ambiguities that may result from using 8-adjacency. Connectivity, Regions and Boundaries A digital path (or curve) from pixel \\(p\\) with coordinate \\((x_0, y_0)\\) to pixel \\(q\\) with coordinate \\((x_n, y_n)\\) is a sequence of distinct pixels with coordinates \\[(x_0, y_0), (x_1, y_1),\\dotsc,(x_n, y_n)\\] where points \\((x_i, y_i)\\) and \\((x_{i-1}, y_{i-1})\\) are adjacent for \\(1 \\leqslant i \\leqslant n\\). In this case, \\(n\\) is the length of the path. Notice that there are actually \\(n+1\\) pixels along the path. If \\((x_0, y_0)=(x_n, y_n)\\) the path is a closed path. 4-, 8-, and m-paths are defined depending on the type of adjacency specified. Let \\(S\\) represent a subset of pixels in an image. Two pixels \\(p\\) and \\(q\\) are said to be connected in \\(S\\) if there exists a path between them consisting entirely of pixels in \\(S\\). For any pixel \\(p\\) in \\(S\\), the set of pixels that are connected to \\(p\\) in \\(S\\) is called a connected component of \\(S\\). If it only has one component, and that component is connected, then \\(S\\) is called a connected set. Notice that the number of components is the number of sets, not pixel count. Let \\(R\\) represent a subset of pixels in an image. We call \\(R\\) a region of the image if \\(R\\) is a connected set. Two regions, \\(R_i\\) and \\(R_j\\) are said to be adjacent if their union forms a connected set. Regions that are not adjacent are said to be disjoint. We consider 4- and 8-adjacency when referring to regions. Suppose an image contains \\(K\\) disjoint regions, \\(R_k\\), \\(k=1,\\dotsc,K\\), none of which touches the image border. Let \\(R_u\\) denote the union of all the \\(K\\) regions, and let \\((R_u)^c\\) denote its complement. We call all the points in \\(R_u\\) the foreground, and all the points in \\((R_u)^c\\) the background of the image. The boundary (aka border or contour) of a region \\(R\\) is the set of pixels in \\(R\\) that are adjacent to pixels in the complement of \\(R\\). Stated another way, the border of a region is the set of pixels in the region that have at least one background neighbor. As a rule, adjacency between points in a region and its background is defined using 8-adjacency. The preceding definition sometimes is referred to as the inner border of the region to distinguish it from its outer border, which is the corresponding border in the background. If \\(R\\) happens to be an entire image, then its boundary (or border) is defined as the set of pixels in the first and last rows and columns of the image. Distance Measure For pixels \\(p\\), \\(q\\), and \\(s\\), with coordinates \\((x, y)\\), \\(u, v\\), and \\(w, z\\), respectively, \\(D\\) is a distance function or metric if \\(D(p, q)\\geq 0 \\quad \\)(\\(D(p, q)=0\\) iff \\(p=q\\)), \\(D(p, q)=D(q, p)\\), and \\(D(p, s)\\leq D(p, q) + D(q, s)\\). The Euclidean distance between \\(p\\) and \\(q\\) is defined as \\[ D_e(p,q)=\\left[(x-u)^2+(y-v)^2\\right]^{\\frac{1}{2}} \\tag{2-19} \\] Image Interpolation Interpolation is the process of using known data to estimate values at unknown locations, which is basically image resampling methods for image resizing. Work in Progress","link":"/2020/note/Image-Processing/Digital-Image-Fundamentals/"},{"title":"Image Processing Syllabus","text":"Textbook Digital Image Processing, Fourth Edition, ISBN 978-0-13-335672-4, by Rafael C. Gonzalez and Richard E. Woods, published by Pearson Education © 2018. Content Chapter 1: Digital Image Introduction Chapter 2: Digital Image Fundamentals Chapter 3: Post not found: note/Image-Processing/Intensity Transformation and Spatial Filtering Work in Progress","link":"/2020/note/Image-Processing/Image-Processing-Syllabus/"},{"title":"Intensity Transformations and Spatial Filtering","text":"Background The Basic of Intensity Transformations and Spatial Filtering \\[ g(x, y)=T[f(x, y)] \\tag{3-1} \\] \\[ s=T(r) \\tag{3-2} \\] For simplicity in notation, we use \\(s\\) and \\(r\\) to denote, respectively, the intensity of \\(g\\) and \\(f\\) at any point \\((x, y)\\). Some Basic Intensity Transformation Functions Image Negatives \\[ s=L-1-r \\tag{3-3} \\] Log Transformations \\[ s=c\\log(1+r) \\tag{3-4} \\] Power-law (Gamma) Transformations \\[ s=cr^{\\gamma} \\tag{3-5} \\] By convention, the exponent in a power-law equation is referred to as gamma [hence the use of this symbol in Eq.\\((3-5)\\)]. The process used to correct these power-law response phenomena is called gamma correction or gamma encoding. Piecewise Linear Transformation Functions Contrast Stretching Intensity-Level Slicing Bit-Plane Slicing Histogram processing Let \\(r_k\\), for \\(k=0,1,2,\\dotsc,L-1\\), denotes the intensities of an \\(L\\)-level digital image, \\(f(x,y)\\). The unnormalized histogram of \\(f\\) is defined as \\[ h(r_k)=n_k\\quad \\text{for }k=0, 1, 2,\\dotsc,L-1 \\tag{3-6} \\] where \\(n_k\\) is the number of pixels in \\(f\\) with intensity \\(r_k\\), and the subdivisions of the intensity scale are called histogram bins. Similarly, the normailzed histogram of \\(f\\) is defined as \\[ p(r_k)=\\frac{h(r_k)}{MN}=\\frac{n_k}{MN} \\tag{3-7} \\] where, as usual, \\(M\\) and \\(N\\) denote the number of image rows and columns, respectively. Mostly, we work with normalized histograms, which we refer to simply as histograms or image histograms. The components of \\(p_k\\) are estimates of the probabilities of intensity levels occurring in an image. The sum of \\(p_k\\) for all values of \\(k\\) is always 1. Histogram shape is related to image appearance. Histogram Equalization Assuming initially continuous intensity values, let the variable \\(r\\) denote the intensities of an image to be processed. As usual, we assume that \\(r\\) is in range \\([0, L-1]\\), with \\(r=0\\) representing black and \\(r=L-1\\) representing white. For \\(r\\) satisfying the conditions, we focus attention on transformations (intensity mapping) of the form \\[ s=T(r)\\quad 0\\leq r\\leq L-1 \\tag{3-8} \\] The intensity of an image can be viewed as a random variable in the interval \\([0, L-1]\\). Let \\(p_r(r)\\) and \\(p_s(s)\\) denote the PDFs of intensity values \\(r\\) and \\(s\\) in two different images. A fundamental result from probability theory is that if \\(p_r(r)\\) and \\(T(r)\\) are known, and \\(T(r)\\) is continuous and differentiable over the range of interest, then the PDF of the transformed (mapped) variable \\(s\\) can be obtained as \\[ p_s(s)=p_r(r)\\left|\\frac{dr}{ds}\\right| \\tag{3-10} \\] A transformation function of particular importance in image processing is \\[ s=T(r)=(L-1)\\int_0^rp_r(w)dw \\tag{3-11} \\] where \\(w\\) is a dummy variable of integration. The integral on the right side is the cumulative distribution function (CDF) of random variable \\(r\\). \\[ \\begin{aligned} \\frac{ds}{dr}&amp;=\\frac{T(r)}{dr}\\cr &amp;=(L-1)\\frac{dr}{r}\\left[\\int_0^rp_r(w)dw\\right]\\cr &amp;=(L-1)p_r(r) \\tag{3-12} \\end{aligned} \\] \\[ \\begin{aligned} p_s(s)&amp;=p_r(r)\\left|\\frac{dr}{ds}\\right|\\cr &amp;=p_r(r)\\left|\\frac{1}{(L-1)p_r(r)}\\right|\\cr &amp;=\\frac{1}{L-1}\\quad 0\\leq s \\leq L-1 \\tag{3-13} \\end{aligned} \\] We recognize the form of \\(p_s(s)\\) in the last line of the equation as a uniform probability density function. Thus, performing the intensity transformation in Eq.\\((3-11)\\) yields a random variable, \\(s\\), characterized by a uniform PDF. What is important is that \\(p_s(s)\\) in Eq.\\((3-13)\\) will always be uniform, independently of the form of \\(p_r(r)\\). Histogram Matching (Specification) Local Histogram Processing Fundamentals of Spatial Filtering Spatial filtering modifies an image by replacing the values of each pixel by a function od values of the pixel and its neighbors. If the operation performed on the image pixels is linear, then the filter is called linear spatial filter. Otherwise, the filter is a nonlinear spatial filter. The Mechanics of Linear Spatial Filtering A linear spatial filter performs a sum-of-product operations between a image \\(f\\) and a filter kernel, \\(w\\). The kernel is an array whose size defines the neighborhood of operation, and whose coefficients determine the nature of the filter. Other terms used to refer to a spatial filer kernel are mask, template, and window. Our focus is on kernels of odd size in both directions. In general, linear spatial filtering of an image of size \\(M \\times N\\) with a kernel of size \\(m \\times n\\) is given by the expression \\[ g(x, y)=\\sum_{s=-a}^{a}\\sum_{t=-b}^{b}w(s, t)f(x+s, y+t) \\tag{3-31} \\] where \\(x\\) and \\(y\\) are varied so the center (origin) of the kernel visits every pixel in \\(f\\) once. Spatial Correlation and Convolution Work in Progress","link":"/2020/note/Image-Processing/Intensity-Transformations-and-Spatial-Filtering/"},{"title":"Digital Image Introduction","text":"What is Digital Image Processing? Well, I think we all know what digital image processing is to some extent. So without further ado, let's jump right into it. Form Image Processing to Computer Vision A useful paradigm that considers three types of computerized processes in the continuum from image processing at one end to computer vision at the other: Low-level processes: both its inputs and outputs are images, such as image preprocessing to reduce noise, contrast enhancement, and image sharpening. Mid-level processes: the inputs generally are images, but its outputs are attributes extracted from those images, such as segmentation and classification fo individual objects. High-level processes: &quot;making sense&quot; of an ensemble of recognized objects. Fundamental Steps in Digital Image Processing Components of an Image Processing System","link":"/2020/note/Image-Processing/Introduction/"},{"title":"集成电路设计方法学课程目录","text":"Work in Progress","link":"/2021/note/Methodology-of-Integrated-Circuit-Design/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"title":"Video Scripting Tools","text":"Python Environment Anaconda: https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ VapourSynth Official site: http://www.vapoursynth.com/ Documentation: http://www.vapoursynth.com/doc/index.html Repository: https://github.com/vapoursynth/vapoursynth Plugins VCB-S archive Move python scripts to .\\envs, Move filters to .\\envs\\vapoursynth64\\plugins. VSRepo: Repository: https://github.com/vapoursynth/vsrepo Database: https://vsdb.top/ Use -p for a portable VapourSynth install. Plugin list: muvsfunc: Muonium's VapourSynth functions. Documentation: https://github.com/WolframRhodium/muvsfunc/wiki/muvs-tutorial LSMASHSource: A general source plugin based on FFmpeg. Can open MP4, MOV, ISO base media without having to create an index file. Documentation: https://github.com/AkarinVS/L-SMASH-Works/blob/master/VapourSynth/README VapourSynth Editor Official repository: https://bitbucket.org/mystery_keeper/vapoursynth-editor x264 https://github.com/jpsdr/x264 x265 http://www.msystem.waw.pl/x265/ OKEGui Official repository: https://github.com/vcb-s/OKEGui Miscellaneous Tools MediaInfo MediaInfo GUI: https://mediaarea.net/en/MediaInfo/Download/Windows MediaInfo Project NG: https://github.com/vcb-s/MediainfoProjectNg VCB-S Tutorial &amp; Specification https://vcb-s.nmm-hd.org/ https://github.com/vcb-s/VCB-S_Collation Aegisub Official repository: https://github.com/Aegisub/Aegisub wangqr's build: https://github.com/wangqr/Aegisub Daydream Cafe Edition: https://github.com/Ristellise/AegisubDC Work in Progress","link":"/2021/note/Video-Scripting/Video-Scripting-Tools/"},{"title":"Detection and Estimation in Additive Gaussian Noise","text":"A.1 Gaussian Random Variables A.1.1 Scalar Real Gaussian Random Variables For a standard Gaussian random variable \\(w\\). The mean of \\(w\\) is zero and the variance is 1. A general Gaussian random variable \\(x\\) is of the form \\(x=\\sigma w+\\mu\\). Its probability density function (PDF) is \\[ f(x)=\\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp{\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)} \\text{,}\\quad x\\in\\real\\text{.} \\tag{A.3} \\] The random variable \\(x\\) is denoted by \\(\\mathcal{N}(\\mu, \\sigma^2)\\). The tail of the standard Gaussian random variable \\(w\\) is \\[ Q(a)\\coloneqq\\mathbb{P}{w&gt;a} \\text{.}\\tag{A.4} \\] The tail decays exponentially fast as evident by the following upper and lower bounds: \\[ \\frac{1}{\\sqrt{2\\pi a^2}}\\left(1-\\frac{1}{a^2}\\right) e^{-\\frac{a^2}{2}}&lt;Q(a)&lt;e^{-\\frac{a^2}{2}} \\text{,}\\quad a&gt;1\\text{.} \\tag{A.5} \\] An important property of Gaussianity is that it is preserved by linear transformations: linear combinations of independent Gaussian random variables are still Gaussian. If \\(x_1,\\dotsc,x_n\\) are independent and \\(x_i\\sim\\mathcal{N}(\\mu_i,\\sigma_i^2)\\), then \\[ \\sum_{i=1}^nc_ix_i\\sim \\mathcal{N}\\left(\\sum_{i=1}^nc_i\\mu_i,\\sum_{i=1}^nc_i^2\\sigma_i^2\\right) \\text{.}\\tag{A.6} \\] A.1.2 Real Gaussian Random Vectors A standard Gaussian random vector \\(\\mathbf{w}\\) is a collection of \\(n\\) independent and identically distributed (i.i.d.) standard Gaussian random variables \\(w_1,\\dotsc,w_n\\). The vector \\(\\mathbf{w}=(w_1,\\dotsc,w_n)^t\\) takes values in the vector space \\(\\real^n\\). The PDF of \\(\\mathbf{w}\\) is: \\[ f(\\mathbf{w})=\\frac{1}{\\left(\\sqrt{2\\pi}\\right)^n} \\exp{\\left(-\\frac{|\\mathbf{w}|^2}{2}\\right)} \\text{,}\\quad\\mathbf{w}\\in\\real^n\\text{.} \\tag{A.7} \\] \\(|\\mathbf{w}|\\) is the Euclidean distance from the origin to \\(\\mathbf{w}\\): \\(|\\mathbf{w}|=\\sqrt{\\sum_{i=1}^nw_i^2}\\). The PDF depends only on the magnitude of \\(\\mathbf{w}\\). Since an orthogonal transformation \\(\\mathbf{O}\\) (i.e., \\(\\mathbf{O}^t\\mathbf{O}=\\mathbf{O}\\mathbf{O}^t=\\mathbf{I}\\)) preserves the magnitude of a vector, we can immediately conclude: \\[ \\boxed{\\text{If }\\mathbf{w}\\text{ is standard Gaussian, then }\\mathbf{Ow}\\text{ is also standard Gaussian.}} \\tag{A.8} \\] What this result says is that \\(\\mathbf{w}\\) has the same distribution in any orthonormal basis. The density of the standard Gaussian vector \\(\\mathbf{w}\\) experiences isotropic behavior.","link":"/2020/note/Wireless-Communication/Detection-and-Estimation-in-Additive-Gaussian-Noise/"},{"title":"The Wireless Channel","text":"A defining characteristic of the mobile wireless channel is the variations of the channel strength over time and over frequency. The variations can be roughly divided into two types: Large-scale fading, due to path loss of signal as a function of distance and shadowing by large objects such as buildings and hills. This occurs as the mobile moves through a distance of the order of the cell size, and is typically frequency independent. Small-scale fading, due to the constructive and destructive interference of the multiple signal paths between the transmitter and receiver. This occurs at the spatial scale of the order of the carrier wavelength, and is frequency dependent. Large-scale fading is more relevant to issues such as cell-site planning. Small-scale multipath fading is more relevant to the design of reliable and efficient communication systems. Physical modeling for wireless channels Free space, fixed transmit and receive antennas It is important to observe that, as the distance r increases, the electric field decreases as \\(r^{-1}\\) and thus the power per square meter in the free space wave decreases as \\(r^{-2}\\). In response to a transmitted sinusoid \\(\\cos{2\\pi ft}\\), we can express the electric far field at time \\(t\\) as \\[ E(f, t, (r, \\theta, \\psi))=\\frac {\\alpha_s(\\theta, \\psi, f)\\cos{2\\pi f(t-r/c)}}{r} \\text{.}\\tag{2.1} \\] The far field is the field sufficiently far away from the antenna so that (2.1) is valid. For cellular systems, it is a safe assumption that the receiver is in the far field. \\((r, \\theta, \\psi)\\) represents the point \\(\\mathbf{u}\\) in space at which the electric field is being measured, where \\(r\\) is the distance from the transmit antenna to \\(\\mathbf{u}\\) and where \\((\\theta, \\psi)\\) represents the vertical and horizontal angles from the antenna to \\(\\mathbf{u}\\) respectively. The constant \\(c\\) is the speed of light, and \\(\\alpha_s(\\theta, \\psi, f)\\) is the radiation pattern of the sending antenna at frequency \\(f\\) in the direction \\((\\theta, \\psi)\\); it also contains a scaling factor to account for antenna losses. Note that the phase of the field varies with \\(fr/c\\), corresponding to the delay caused by the radiation traveling at the speed of light. Next, suppose there is a fixed receive antenna at the location \\(\\mathbf{u}=(r, \\theta, \\psi)\\). The received waveform (in the absence of noise) in response to the above transmitted sinusoid is then \\[ E_r(f, t, \\mathbf{u})=\\frac {\\alpha(\\theta, \\psi, f)\\cos{2\\pi f(t-r/c)}}{r}\\text{,} \\tag{2.2} \\] where \\(\\alpha(f, \\theta, \\psi)\\) is the product of the antenna patterns of transmit and receive antennas in the given direction. Now suppose, for the given \\(\\mathbf{u}\\), that we define \\[ H(f)\\coloneqq\\frac{\\alpha(\\theta, \\psi, f)e^{-j2\\pi fr/c}}{r} \\text{.}\\tag{2.3} \\] We then have \\(E_r(f, t, \\mathbf{u})=\\real\\left[H(f)e^{-j2\\pi ft}\\right]\\). \\((2.1)\\) and \\((2.2)\\) are both linear in the input. That is, the received field (waveform) at \\(\\mathbf{u}\\) in response to a weighted sum of transmitted waveforms is simply the weighted sum of responses to those individual waveforms. Thus, \\(H(f)\\) is the system function for an LTI (linear time-invariant) channel, and its inverse Fourier transform is the impulse response. Free space, moving antenna Next consider the fixed antenna and free space model above with a receive antenna that is moving with speed \\(v\\) in the direction of increasing distance from the transmit antenna, we have \\[ E(f, t, (r_0+vt, \\theta, \\psi))=\\frac {\\alpha_s(\\theta, \\psi, f)\\cos{2\\pi f(t-r_0/c-vt/c)}} {r_0+vt} \\text{.}\\tag{2.4} \\] We can rewrite \\(f(t-r_0/c-vt/c)\\) as \\(f(1-v/c)t-fr_0/c\\). Thus, the sinusoid at frequency \\(f\\) has been converted to a sinusoid of frequency \\(f(1-v/c)\\); there has been a Doppler shift of \\(-fv/c\\) due to the motion of the observation point. Reflecting wall, fixed antenna \\[ E_r(f,t)=\\frac{\\alpha\\cos{2\\pi f(t-r/c)}}{r} -\\frac{\\alpha\\cos{2\\pi f(t-(2d-r)/c)}}{2d-r} \\]","link":"/2020/note/Wireless-Communication/The-Wireless-Channel/"},{"title":"Wireless Communication Index","text":"Reference book Fundamentals of Wireless Communication by David Tse and Pramod Viswanath. Contents Chapter 2: Post not found: Note/Wireless-Communication/The-Wireless-Channel Appendix A: Post not found: Note/Wireless-Communication/Detection-and-Estimation-in-Additive-Gaussian-Noise","link":"/2020/note/Wireless-Communication/Wireless-Communication-Index/"},{"title":"心肌细胞生物学基础及传感器检测原理","text":"本文内容摘录自浙江大学博士学位论文《心肌细胞多参数复合传感器与系统及其在药物和毒素检测中的应用》的第二章。论文作者是浙江大学生物医学工程与仪器科学学院生物医学工程专业黎洪波博士 1，论文提交于 2018 年 4 月。 说在前面 这是Post not found: Tutorial/跨阻放大器-Transimpedance-Amplifier-简介 之前提到的实验室研究项目的参考资料之一。胡宁副教授和黎洪波博士目前都在我院生物医学电子团队工作。 心肌细胞生物学基础 心脏 (Heart) 推动血液，人类和其他动物循环系统中重要肌造器官。人类、其他哺乳类和鸟类的心脏可分为四个腔室：左右心房（上半部分）、左右心室（下班部分）。心脏搏动使静脉血回流至右心房，之后进入右心室。右心室将血液泵入肺部完成肺循环。血液离开肺回到左心房，之后由左心室推动进入主动脉，完成一个心动周期 (Cardiac cycle)。 心脏主要由心肌细胞 (Cardiomyocytes) 组成，根据功能可分为工作心肌细胞和自律心肌细胞。工作心肌细胞执行收缩。自律心肌细胞失去了收缩性，但它们的一个特点是自律性：离体的心脏仍表现出自律的收缩舒张运动，因为自律心肌细胞可自发产生和传递动作电位。 本文中，心机细胞一般指工作心肌细胞。 心机细胞的动作电位 跨膜电位 (Membrane potential) 是细胞膜内外的电压差。按惯例，细胞膜外的电压被定义为零，跨膜电位是细胞膜内电压相较细胞膜外电压的差。心肌细胞的动作电位 (Cardiac action potential) 是其跨膜电位的短暂变化。动作电位的变化是带电离子通过细胞膜上称为离子通道的蛋白质离开或进入细胞的结果。与肌肉细胞不同，心肌细胞的动作电位不是由神经细胞发起的，而是来自于自律心肌细胞。 心肌细胞的动作电位可分为 5 个时间阶段： &nbsp;&nbsp; PHYSIOLOGY OF CARDIAC CONDUCTION AND CONTRACTILITY Work in Progress","link":"/2019/note/bioelectronics/%E5%BF%83%E8%82%8C%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86/"},{"title":"中国共产党的使命","text":"新民主主义革命时期 新中国成立至改革开放时期 新中国成立后，党的使命是全面恢复经济，建立社会主义制度。 1950 中国土地改革法 社会主义改造总路线：一化三改 制度保障：社会主义制度的建立 根本政治制度 改革开放时期 1978 - 2012 1978 - 1984 农村改革：家庭联产承包责任制 1984 - 1992 十二届三中全会至十四大 城市经济体制改革 1992 - 2003 十四大：建立社会主义市场经济体制 2003 - 2012 十六届三中全会至十八大 新时代党的使命 2012 至今 问题 需要更多理论上的论证 数据要注明出处 各个方面的做法 为实现中华民族伟大复兴的具体步骤 四个伟大，五位一体总体布局，四个全面战略布局 第二小组：党的领导 坚持党的领导 问题：有人认为西方政党大多轮流执政，中国共产党是一党专政， 除了历史实践和人民的选择之外，从无产阶级专政的理论来看，为什么需要坚持中国共产党的领导 需要领导核心，代表无产阶级利益 阶级斗争已经不是中国社会的主要矛盾，不需要多个政党代表各个阶级。 新时代中国特色社会主义中的政治建设与党的政治建设有什么区别 政治信仰：共产主义信仰 党的政治建设是什么 不要泛泛而谈，选一个角度，需要有点深度。 政治建设与思想建设的区别 党的政治建设指政治建设指政治信仰、政治立场、政治原则等 思想建设与政治建设中的政治信仰部分有重叠","link":"/2021/note/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%9A%84%E4%BD%BF%E5%91%BD/"},{"title":"软件无线电基础原理","text":"引言 软件无线电 (Software-defined radio, SDR) 的基本思想是把信号处理的部分尽可能在数字处理器中完成，而模拟前端和射频收发部分使用通用硬件实现。SDR 实现的理论基础是复基带等效定理和多采样率数字信号处理技术。 复基带等效定理 现代无线通信系统所传输的信号为数字带通信号，一个数字带通信号可以表示为 $$s(t)=A(t)\\cos(\\omega t+\\varphi(t)) \\label{Digital bandpass signal} \\tag{1.1}$$ $A(t)$ 表示带通信号的包络，$\\varphi(t)$ 表示信号的相位，$\\ref{Digital bandpass signal}$ 的复数表达为 $\\ref{complex form}$ $$s(t)=\\operatorname{Re}\\{A(t)e^{j\\varphi(t)}e^{j\\omega t}\\}=\\operatorname{Re}\\{S(t)e^{j\\omega t}\\} \\label{complex form} \\tag{1.2}$$ 其中 $S(t)$ 为复数基带信号，将其展开为两路正交基带信号 $$S(t)=A(t)e^{j\\varphi(t)}=A(t)\\cos(\\varphi(t))+jA(t)\\sin(\\varphi(t))=I(t)+jQ(t) \\label{orthogonal baseband signals} \\tag{1.3} $$ 其中 $I$ 是信号的同相 (in-phase) 分量，$Q$ 是信号的正交 (quadrature) 分量。复数基带信号 $S(t)$ 包含了带通信号 $s(t)$ 的全部信息，这意味着带通信号的处理可以等效为对应复数基带信号的处理，当复数基带信号的处理完成后，通过把复数基带信号的实部和虚部分别与两路正交的同频载波相乘恢复到带通信号。这个方法被称为复基带等效定理。 I/Q 调制 那么所谓同相和正交分量到底是什么东西？首先从时域观察一个载波信号 它表明正弦信号由幅度、频率和相位决定，因此这三个参数可以用来携带信息。由于频率是相位对时间的导数，它们可统称为角度。在极坐标系中，我们可以用一个点表示一个正弦信号的瞬时值，它到原点的距离表示信号当前的幅度，它与水平轴的夹角表示角度。 时间 $t$ 以 $dt$ 速度增加，该点从初相位 $\\varphi$ 出发，以角速度 $\\omega$ 绕原点逆时针转动，期间它到原点的距离由 $A_c(t)$ 决定。 --WIP-- 根据此方法进行信号处理的第一步是从接收到的信号 $s(t)$ 中分离出两路正交的 $I/Q$ 信号。首先在接收端生成一个与发送端同频同相的载波信号 $\\cos(\\omega t)$ 和对该载波信号移相 90° 的信号 $\\sin(\\omega t)$，将其分别与接收到的信号相乘 $$\\begin{align*} s(t)\\cos(\\omega t) &= A(t)\\cos(\\omega t+\\varphi(t))\\cos(\\omega t) \\\\ &= \\frac{1}{2}A(t)[\\cos(\\omega t+\\varphi(t)+\\omega t)+\\cos(\\omega t + \\varphi(t)-\\omega t)] \\\\ &= \\frac{1}{2}A(t)[\\cos(2\\omega t)\\cos(\\varphi(t))-\\sin(2\\omega t)\\sin(\\varphi(t))+\\cos(\\varphi(t))] \\\\ &= \\frac{1}{2}I(t)+\\frac{1}{2}I(t)\\cos(2\\omega t)+\\frac{1}{2}Q(t)\\sin(2\\omega t) \\tag{1.5} \\\\ s(t)\\sin(\\omega t) &= A(t)\\cos(\\omega t+\\varphi(t))\\sin(\\omega t) \\\\ &= \\frac{1}{2}A(t)[\\sin(\\omega t+\\varphi(t)+\\omega t)-\\sin(\\omega t + \\varphi(t)-\\omega t)] \\\\ &= \\frac{1}{2}A(t)[\\sin(2\\omega t)\\cos(\\varphi(t))+\\cos(2\\omega t)\\sin(\\varphi(t))-\\sin(\\varphi(t))] \\\\ &= -\\frac{1}{2}Q(t)+\\frac{1}{2}I(t)\\sin(2\\omega t)+\\frac{1}{2}Q(t)\\cos(2\\omega t) \\tag{1.6} \\end{align*}$$ 将相乘后的信号进行低通滤波即可得到同相和正交分量。 http://www.ni.com/tutorial/4805/en/","link":"/2019/note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"},{"title":"通信原理目录","text":"课程简介 第一章：绪论 第二章：确知信号 第三章：随机过程 第四章：信道 第五章：模拟调制系统 第六章：数字基带传输系统 第七章：数字带通传输系统 第十章：信源编码 第十一章：差错控制编码 第十三章：同步原理 WIP","link":"/2019/note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%9B%AE%E5%BD%95/"},{"title":"传输线与反射","text":"引起反射的原因是什么？如何消除反射？（详细讨论每种方法的优缺点） 信号沿传输线传播时，只要瞬时阻抗突变，信号就会发生反射。反射信号的产生是为了满足交界面两侧电压和电流的连续性，表述为两个重要的边界条件，即 \\[ \\begin{aligned} V_{inc}+V_{refl}&amp;=V_{trans} \\\\ I_{inc}-I_{refl}&amp;=I_{trans} \\end{aligned} \\] 根据边界条件可以推导反射系数 \\(\\rho\\) \\[ \\rho=\\frac{V_{refl}}{V_{inc}}=\\frac{Z_2-Z_1}{Z_2+Z_1} \\] 变化的信号通过阻抗不同的两个区域时，不能满足电压和电流的连续性，为了使系统平衡，区域一中产生了反射回源端的电压，以吸收入射信号和传输信号之间不匹配的电压和电流。 消除反射的根本方法是减小阻抗突变，第一层含义是保持互连的瞬时阻抗恒定，制造阻抗可控电路板。其中几个设计规则是减小桩线长度，使用菊花链代替分支结构，使用点到点拓扑；第二层是在传输线总端进行阻抗匹配。对点到点拓扑有四种常用的端接方式；第三层是维持线性布线拓扑，线上不要有分支和桩线。 首先是使用阻抗可控传输线。目前一般采用 50Ω 特性阻抗互连，这个要求是比较容易满足的。其优点是从根源上解决阻抗突变的问题，但布线时难免会出现线宽改变、折角或过孔等阻抗突变的情况。 使用菊花链拓扑并尽可能减小桩线长度，能在非点到点拓扑中改善时延和反射，其缺点是增加了设计难度。 源端串联端接把电阻串联在驱动器端，端接电阻和驱动器内阻之和等于传输线的特性阻抗。其特点是驱动器输出电压最初到达传输线时只有端接电阻和传输线特性阻抗串联分压后剩余的一半，当反射电压返回源端时才上升到正常值。在远端，信号没有振铃。串联匹配减小反射量，降低 EMI，在各种匹配方式中能耗最小。但在源端，信号呈现台阶状，需要等待反射电压经过一个往返时间回到源端后才能升到驱动器输出电压值，因此源端不能有接收器，这种特点增大了上升边，不适用于高速传输和分布负载。 远端并联端接在接收器前并联一个与传输线特性阻抗一致的端接电阻，信号不会在接收器上反射，而是通过端接电阻到达地。串联端接可用于分布负载，吸收全部的反射波，但它把信号直接并联到地，增加了电路的功耗，也对驱动器的驱动能力提出了更高的要求。 远端戴维南端接用上拉电阻和下拉电阻构成分压以消除反射。与并联端接不同，这种方法不需要驱动器提供额外电流，因此减少了对驱动能力的要求，可获得最快的电路性能，驱动分布负载。但这种端接仍要消耗更多功率，更多元件也增加了布线难度。 远端 RC 端接在并联端接的基础上串联一个电容。端接电阻值等于特性阻抗，电容值满足 RC 时间常数大于两倍信号时延。电容的存在使端接功耗降低，可用于分布负载和总线传输，但降低了高速系统的速度。 电路板有哪些常见的不可避免的突变互连？当这些突变互连长度达到何种程度就必须采取措施？ 线的两端 封装引线 输入门电容 信号层之间的过孔 拐角 桩线 分支 测试焊盘 返回路径上的间隙 过孔区的颈状 线交叉 如果时延远小于上升边，那么多次反射将被掩盖在上升边沿中，不会对信号质量造成影响。 当传输线时延 \\(TD\\) 大于信号上升沿的 20% 时就要控制反射来避免振铃。经验法则是不需要端接的传输线长度约为 \\[ Len_{max} &lt; RT \\] 长度单位为 \\(in\\)，上升边单位为 \\(ns\\)。互连长度超过此值就要采取措施。 什么是补偿设计？其基本原则是什么？ 电路中串联回路电感是不可避免的，补偿的概念就是尽量不让信号感受到很大的感性突变，而是觉得遇到了与导线特性阻抗相匹配的一段传输线。 导线的特性阻抗是 \\(Z_0=\\sqrt{\\frac{L}{C}}\\)，则补偿的原则是在感性突变的两则各加小电容器，将其转变为一段传输线，电容值 \\(C_1=\\frac{L_1}{Z_0}\\)。对感性突变增加电容，对容性突变增加电感，补偿至传输线的特性阻抗。 如何从测量或时域仿真的波形中分辨容性突变和感性突变？ 电容器的阻抗为 \\(Z_{cap}=\\frac{RT}{C}\\)，面对上升边时，电容充电，电压变化量由大变小，其阻抗由低变高。源端和远端的信号波形为： 可见容性突变使信号下凹。 电感阻抗为 \\(Z_{ind}=\\frac{L}{RT}\\)，面对上升边，电流变化量由大变小，其阻抗由高变低。源端和远端的信号波形为： 可见感性突变使信号上凸。","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E4%BC%A0%E8%BE%93%E7%BA%BF%E4%B8%8E%E5%8F%8D%E5%B0%84/"},{"title":"时域与频域","text":"概念解析：信号带宽、测量带宽、模型带宽、互连带宽 带宽指波形频谱中最高的有效正弦波频率分量。 信号带宽：对上升边有限的数字信号而言，“有效”指的是其谐波幅度高于相同基频理想方波中对应谐波幅度的 70%，信号带宽是其频谱中谐波幅度下降为 70% 的那一点的谐波频率值。 测量带宽指测量结果有足够准确度的最高正弦波频率分量。测量带宽不同于元器件本身的可用带宽。 模型带宽指模型能被准确地用于预估实际结构真实性能的最高正弦波频率分量。 互连带宽指能被互连传输且未造成有效损耗的最高正弦波频率分量，“有效”指的是互连能够传输满足应用技术条件的正弦波频率范围。 信号带宽的近似估算法 用上升边估算带宽 用 \\(RT\\) 表示 \\(10%\\sim90%\\) 上升边时间，由实验数据分析得到直线拟合的带宽与上升边关系： \\[ BW=\\frac{0.35}{RT} \\] 用时钟频率估算带宽 对时钟信号而言，上升边不会短于脉冲长度的 \\(10%\\)： \\[ BW_{Clock}=5\\times F_{Clock} \\] 带宽对上升沿有什么影响 WIP","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F/"},{"title":"阻抗与电器模型","text":"引言 在高速数字系统中，信号是指变化的电压或变化的电流。所有信号完整性问题都是由模拟信号与互连电气特性之间的相互作用引起的，而影响信号的关键电气特性是互连的阻抗。 阻抗定义为电压与电流之比，通常用大写字母 \\(Z\\) 表示： \\[Z=V/I\\] 当信号沿互连传播时，它将不断地探测互连的阻抗，并做出相应的反应。 简述阻抗在信号完整性分析与设计中的重要意义 在高速数字系统中，信号指变化的电压或变化的电流。信号传输中遇到的完整性问题都是由模拟信号与互连电气特性之间的相互作用引发的，而互连的阻抗是影响信号的关键电气特性之一。这说明了研究阻抗在研究互连对信号传输的影响中的必要性。 阻抗定义为电压与电流之比，这个定义可用于任何元件，如贴片电阻、去耦电容、封装中的引线和 PCB 中的线条，而且无论何种元件的阻抗，在时域和频域中的表示都是适用的。这说明了阻抗定义的普适性。 当信号沿互连传播时，它将不断地探测互连的阻抗，并做出相应的反应。因此如果在产品制造前的设计阶段就知道互连的阻抗，就能准确预估信号的失真程度，判断设计是否能满足性能指标。同理，由对性能和信号的要求可以确定互连阻抗的技术规范，如果掌握了材料特性和几何形状对互连阻抗的影响，就有依据设计拓扑结构、材料横截面，选择合适的元件让产品的设计在第一次就能达到要求。 阻抗突变引起电压信号的反射和失真的问题，两条相邻信号线条之间电场与磁场的耦合引起的信号串扰问题，芯片电流切换时在电源与地之间形成压降的问题和电磁干扰这四类基本信号完整性问题都可以用阻抗加以描述。阻抗是连接物理设计与电气性能的桥梁，是解决信号完整性问题方法学的核心。 阻抗是描述互连的电气特性的关键。它不仅可以用于描述与信号完整性相关的问题，而且还可以用于寻找信号完整性问题的解决方案和设计方法。若信号的传播路径没有阻抗突变，则可以避免不必要的失真。知道了互连的阻抗和传播时延，也就知道了它几乎所有的电气特性。这是阻抗在信号完整性分析与设计中的重要性。 概念解析：建模，实际模型、理想模型 建模是在满足准确度和带宽的要求下把所设计的物理结构转化为用理想元件构建的等效电路模型的过程。 实际模型是实际存在的事物，它们是构成现实硬件系统的互连或元件，是可以被测量的，例如贴片电阻和电容。 理想模型是具体电路元件的数学描述，具有详细准确的数学定义，电路理论可用于理想模型实现电路仿真。例如理想电阻器和电容器。","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E9%98%BB%E6%8A%97%E4%B8%8E%E7%94%B5%E5%99%A8%E6%A8%A1%E5%9E%8B/"},{"title":"高速电路设计与信号完整性分析目录","text":"课程介绍 随着时钟频率的不断提高，信号完整性 (Signal Integrity) 成为产品开发的关键问题。课程主要介绍理解和解决信号完整性 (SI) 和电源完整性 (PI) 问题的基本原理。 第一章：信号完整性分析概论 第二章：Post not found: Note/高速电路设计与信号完整性分析/时域与频域 第三章：Post not found: Note/高速电路设计与信号完整性分析/阻抗与电器模型 第四章：电阻的物理基础 第五章：电容的物理基础 第六章：电感的物理基础 第七章：传输线的物理基础 第八章：Post not found: Note/高速电路设计与信号完整性分析/传输线与反射 第九章：有损线、上升边退化与材料特性 第十章：传输线的串扰 第十一章：差分对与差分阻抗 第十二章：S 参数在信号完整性中的应用 第十三章：电源分配网络 WIP","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90%E7%9B%AE%E5%BD%95/"}],"tags":[{"name":"changelog","slug":"changelog","link":"/tags/changelog/"},{"name":"info","slug":"info","link":"/tags/info/"},{"name":"antenna","slug":"antenna","link":"/tags/antenna/"},{"name":"HFSS","slug":"HFSS","link":"/tags/HFSS/"},{"name":"wave guide","slug":"wave-guide","link":"/tags/wave-guide/"},{"name":"QR Code","slug":"QR-Code","link":"/tags/QR-Code/"},{"name":"electronic","slug":"electronic","link":"/tags/electronic/"},{"name":"robot","slug":"robot","link":"/tags/robot/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Hyper-V","slug":"Hyper-V","link":"/tags/Hyper-V/"},{"name":"YouTube","slug":"YouTube","link":"/tags/YouTube/"},{"name":"subtitle","slug":"subtitle","link":"/tags/subtitle/"},{"name":"Aegisub","slug":"Aegisub","link":"/tags/Aegisub/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"config","slug":"config","link":"/tags/config/"},{"name":"transcript","slug":"transcript","link":"/tags/transcript/"},{"name":"sensor","slug":"sensor","link":"/tags/sensor/"},{"name":"sequence","slug":"sequence","link":"/tags/sequence/"},{"name":"limit","slug":"limit","link":"/tags/limit/"},{"name":"课程目录","slug":"课程目录","link":"/tags/%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Analog","slug":"Analog","link":"/tags/Analog/"},{"name":"CMOS","slug":"CMOS","link":"/tags/CMOS/"},{"name":"VHDL","slug":"VHDL","link":"/tags/VHDL/"},{"name":"syllabus","slug":"syllabus","link":"/tags/syllabus/"},{"name":"Digital logic","slug":"Digital-logic","link":"/tags/Digital-logic/"},{"name":"Info","slug":"Info","link":"/tags/Info/"},{"name":"normal distribution","slug":"normal-distribution","link":"/tags/normal-distribution/"},{"name":"fading","slug":"fading","link":"/tags/fading/"},{"name":"SDR","slug":"SDR","link":"/tags/SDR/"},{"name":"bandwidth","slug":"bandwidth","link":"/tags/bandwidth/"},{"name":"impedance","slug":"impedance","link":"/tags/impedance/"},{"name":"model","slug":"model","link":"/tags/model/"}],"categories":[{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"Log","slug":"Log","link":"/categories/Log/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Tip","slug":"Tip","link":"/categories/Tip/"},{"name":"Walk-through","slug":"Walk-through","link":"/categories/Walk-through/"},{"name":"Tutorial","slug":"Tutorial","link":"/categories/Tutorial/"},{"name":"Advanced Mathematics","slug":"Note/Advanced-Mathematics","link":"/categories/Note/Advanced-Mathematics/"},{"name":"Language Reference","slug":"Note/Language-Reference","link":"/categories/Note/Language-Reference/"},{"name":"Design of Analog Integrated Circuit","slug":"Note/Design-of-Analog-Integrated-Circuit","link":"/categories/Note/Design-of-Analog-Integrated-Circuit/"},{"name":"Digital Integrated Circuit","slug":"Note/Digital-Integrated-Circuit","link":"/categories/Note/Digital-Integrated-Circuit/"},{"name":"Image Processing","slug":"Note/Image-Processing","link":"/categories/Note/Image-Processing/"},{"name":"Methodology of Integrated Circuit Design","slug":"Note/Methodology-of-Integrated-Circuit-Design","link":"/categories/Note/Methodology-of-Integrated-Circuit-Design/"},{"name":"Video Scripting","slug":"Note/Video-Scripting","link":"/categories/Note/Video-Scripting/"},{"name":"Wireless Communication","slug":"Note/Wireless-Communication","link":"/categories/Note/Wireless-Communication/"},{"name":"Bioelectronics","slug":"Note/Bioelectronics","link":"/categories/Note/Bioelectronics/"},{"name":"新时代中国特色社会主义理论与实践","slug":"Note/新时代中国特色社会主义理论与实践","link":"/categories/Note/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"name":"通信原理","slug":"Note/通信原理","link":"/categories/Note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"Bioinformatics","slug":"Tutorial/Bioinformatics","link":"/categories/Tutorial/Bioinformatics/"},{"name":"高速电路设计与信号完整性分析","slug":"Note/高速电路设计与信号完整性分析","link":"/categories/Note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/"}]}