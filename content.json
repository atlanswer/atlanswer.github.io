{"pages":[{"title":"404 Page","text":"The website encounters an unresolvable link. It maybe caused by errors written in the blog's source. You click back, or go to the home page.","link":"/404"},{"title":"关于","text":"这里可以介绍一下本博客和各位作者。 博客的建设可能会慢，但绝不会坑掉🙃。 尝试遵循的排版规则： 中、英文和中文、数字间添加空格，优化视觉分布 中文句子内均使用全角括号，即使括号内为英文 列表句子末尾不添加句号","link":"/about/index.html"}],"posts":[{"title":"《习近平关于“不忘初心、牢记使命”论述摘编》学习心得","text":"有些学生企图用一个晚上通读《习近平关于“不忘初心、牢记使命”论述摘编》.jpg 第二批“不忘初心、牢记使命”主题教育从 2019 年 9 月开始到 11 月底基本结束，包括高等学校在内。围绕学习贯彻习近平新时代中国特色社会主义思想的主线，各党员要深入学习主题教育精神，以理论滋养初心、以理论引领使命，增强“四个意识”、坚定“四个自信”、做到“两个维护”，以彻底的自我革命精神解决违背初心和使命的各种问题，努力实现理论学习有收获、思想政治受洗礼、干事创业敢担当、为民服务解难题、清正廉洁作表率的目标。 为配合第二批主题教育，《习近平关于“不忘初心、牢记使命”论述摘编》出版，供基层党员学习使用。其内容包括习近平同志 2012 年 十一月至 2019 年七月的 362 段论述，共分十个专题。下面是我对这本书的总结和学习心得。 body { background-color: #DE2910; } 专题总结 一、中国共产党人的初心和使命，就是为中国人民谋幸福，为中华民族谋复兴 这一专题说明了中国共产党人的目标与责任，强调了“不忘初心、牢记使命”的主体维度。 二、新时代中国共产党的历史使命 本专题指出中国特色社会主义进入新时代这一新的历史方位，部署了实现伟大梦想的工作，强调党的建设和加强党的领导的重要性。 三、用新时代中国特色社会主义思想武装全党 强调深入学习中国特色社会主义理论体系，坚持和发展马克思主义科学理论，阐述了新时代中国特色社会主义思想的内容，说明在新时代坚持和发展中国特色社会主义的十四个基本方略，要求学习贯彻党的十九大精神。 四、坚定理想信念，始终是共产党人安身立命的根本 坚定理想信念与第一专题不忘初心相似。 五、把政治建设摆在首位，不断增强“四个意识”、坚定“四个自信”、做到“两个维护” 强调在思想上政治上行动上同党中央保持高度一致，坚持党性原则，严守党的政治纪律。 六、坚持以人民为中心，把群众观点和群众路线深深根植于思想具体落实到行动上 群众路线是党的生命线和根本工作路线，党的一切工作都是为了实现好、维护好、发展好最广大人民群众的根本利益。 七、勇于自我革命，同一切影响党的先进性、弱化党的纯洁性的问题作坚决斗争 开展党的自身建设，廉洁自律，反腐倡廉。强调先进性和纯洁性是马克思主义政党的本质属性，加强党内监督，开展批评与自我批评，保持自我革命精神。 八、坚决整治形式主义、官僚主义，加强真抓实干的作风建设 反对形式主义，讲求实效 九、加强学习、深入开展调查研究，全面增强执政本领 强调不断学习，深入调查研究的重要性。 十、新时代要有新气象，更要有新作为 与第二专题差不多，重点是要有“新作为”，给人身心振奋的感觉。 我的学习心得 论述摘编的内容面向全体基层党员，涵盖了围绕学习贯彻习近平新时代中国特色社会主义思想的主线，深入学习主题教育精神，以理论滋养初心、以理论引领使命，增强“四个意识”、坚定“四个自信”、做到“两个维护”的方方面面的内容。这次报告我分享对与高校学生关系比较密切的三个方面的心得。 首先是第一专题和第四专题讲到的中国共产党人的初心和使命以及坚定理想信念的问题。我认为其中的重要一点是认识“不忘初心、牢记使命”的主体维度。历史告诉我们，中华民族的命运与中国共产党紧密相连，实现中华民族的伟大复兴是中国共产党的崇高使命和历史责任，它着眼于中国人民和中华民族。这也就意味着我们看待中国问题要从中国角度出发，既关注每位中国人民的个人观点，也囊括中华民族的总体范畴。总书记在论述共产党人为中国人民谋幸福，为中华民族谋复兴这一中国共产党人的初心和使命时，强调了在历史维度上加强党的自身建设的宝贵经验的传承，由中国情况出发，在实践中丰富和发展马克思主义科学理论。他在有关内容的讲话中提到历史上的优秀例子和他自己在福州、宁德当市委、地委书记时实践走访每个乡县的切身体会，给我最大的感受就是守初心、担使命不是被束之高阁的概念，每位共产党员都必须时时刻刻牢记践行。在价值维度上把人民的价值诉求作为党的价值追求，让人民同享改革成果，把人民的观点作为判断决策成果优劣的标准。在实践维度上在新时代贯彻新发展理念，满足人民日益增长的美好生活需要，这要求我们敢于承担风险、勇于承担责任、乐于迎接挑战、勤于开创事业。明确了以上解决坚持和发展中国特色社会主义的动力和源泉问题，我们才能始终充满奋勇前进的强大动力。 第二是第六专题论述的，群众路线是党的生命线和根本工作路线。党的一切工作都是为了实现好，维护好，发展好最广大人民群众的根本利益。既要看到人民群众中先进的优秀的成分，自觉学习发扬优良传统和社会主义新风尚，也要意识到现实情况下的不足，看到落后与跟不上时代的部分，并在自己的行动中有意识地做出改变。不要忘记现在良好的学习条件来自党的领导和人民群众的辛勤劳动。我们在学习生活中也要紧密团结同学，起到先进表率作用，积极了解学生群体中的情况，解决现实的困难。 第三是第九章中对学习和调查的观点，强调不断学习深入调查研究的重要性，同时结合第八章反对形式主义的观点。学习不是为学而学，在新知识新事物层出不穷的当今时代，更加要注意全方面的学习。其一是通过掌握知识掌握本领，克服面对困难时恐慌退缩的不足；其二是扎实学习，避免形式主义突击学习；第三是学有所用与实践结合。在应用中加深对所学知识的理解。这让我联想到在科研实践中，我们应当夯实基础能力，挑战核心技术，避免盲目追求前沿，走花拳绣腿的套路。","link":"/2019/diary/%E3%80%8A%E4%B9%A0%E8%BF%91%E5%B9%B3%E5%85%B3%E4%BA%8E%E2%80%9C%E4%B8%8D%E5%BF%98%E5%88%9D%E5%BF%83%E3%80%81%E7%89%A2%E8%AE%B0%E4%BD%BF%E5%91%BD%E2%80%9D%E8%AE%BA%E8%BF%B0%E6%91%98%E7%BC%96%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"},{"title":"庆祝祖国七十华诞-🇨🇳","text":"1949 - 2019 热烈庆祝中华人民共和国成立 70 周年 🇨🇳","link":"/2019/diary/%E5%BA%86%E7%A5%9D%E7%A5%96%E5%9B%BD%E4%B8%83%E5%8D%81%E5%8D%8E%E8%AF%9E-%F0%9F%87%A8%F0%9F%87%B3/"},{"title":"党的历史决议的逻辑演进和启示","text":"党的三个历史决议的逻辑演进 1945 党的扩大的六届七中全会《关于若干历史问题的决议》 1981 党的十一届六中全会《关于建国以来党的若干历史问题的决议》 2021 党的十九届六中全会《中共中央关于党的百年奋斗重大成就和历史经验的决议》 《关于若干历史问题的决议》 历史背景 1921-1935 年，我们党在幼年时期曾受“左”倾或右倾思想统治和影响 1931 年党的六届四中全会后，以王明为代表的“左”倾教条主义错误给党带来极大的危害 1934 年 10 月，由于“左”倾错误思想的干扰，中央革命根据地第五次反“围剿”失败。红军不得不进行战略转移，开始艰苦卓绝的长征，给党的革命事业带来巨大的冲击，严重削弱了党的力量 1935 年，遵义会议结束了“左”倾错误在党内的统治地位，但并没有来得及从思想上进行清算 王明的“左”倾错误 第一次是 1931 年 1 月到 1935 年 1 月，1929 年 3 月王明从莫斯科回来，通过各种关系进入中央领导层，从此之后王明的“左”倾教条主义在党内占据了统治地位。导致中央苏区工作带来一些问题，更为严重的是导致第五次反“围剿”失败。直到遵义会议召开，王明的“左”倾错误思想才得以被清除。 第二次是 1937 年到 1940 年，从“左”倾冒险主义错误转变为对国民党“右倾投降主义”错误，片面强调“一切依靠统一战线，一切为了统一战线”，忽视了对群众的积极发动和党的独立自主性。他经常假借共产国际名义，他撰写的《为中共更加布尔什维克化而斗争》有一定的迷惑性，党内很多干部仍然没有认清楚王明教条主义危害和实质。 六大之后的思想变化 1940 年下半年，毛泽东编辑了历史文献集《六大以来》 1940 年 12 月 4 日，毛泽东指出“右”、“左”的错误。是由于马列主义没有和实际联系起来 1941 年 9 月 10 日至 10 月 22 日，王稼祥和毛泽东起草的文献公开，许多人认识到“左”倾错误思想的危害性 1941 年，毛泽东领导高级干部整风学习，研究马克思主义思想方法和六大以来的决议 1942 年 3 月，毛泽东：“研究党史上的错误，不应该只恨几个人。如果只恨几个人，那是把历史看成是少数人创造的。马克思主义的历史观不是主观主义，应该找出历史事件的实质和它的客观原因。” 1943 年 9 月 7 日至 11 月 27 日，对十年抗时期和抗战初期王明的错误路线进行严肃批评 1944 年 4 月 12 日，毛泽东：“处理历史问题，不应着重于一些个别同志的责任方面，而应着重于当时环境的分析，当时错误的内容，当时错误的社会根源、历史根源和思想根源，实行惩前毖后、治病救人的方针，借以达到既要弄清思想又要团结同志这两个目的。对于人的处理问题取慎重态度，既不含糊敷衍，又不损害同志，这是我们的党兴旺发达的标志之一。” 党的第一个历史决议的起草与通过 1944 年 5 月 10 日，中央书记处会议决定成立党内历史问题决议准备委员会，任弼时为召集人 5 月，任弼时写成决议草案稿，以毛泽东起草的《关于四中全会以来中央领导路线问题结论草案》为基础，同时又反映了其后各次会议取得的新认识。此后，毛泽东和其他高级干部多次讨论，对决议稿进行多次修改 1945 年 4 月 20 日，党的六届七中全会原则上通过《关于若干历史问题的决议》 8 月 9 日，党的七届一中全会第二次会议一致通过该决议 主要内容 马克思列宁主义的普遍真理和中国革命的具体实践相结合为自己一切工作的指针 大革命时期、土地革命战争时期党的历史的简要阐述 1927 年到遵义会议，党内的“左”倾、“右”倾错误，对第三次“左”倾路线错误的思想根源做出深刻分析 论述了党内“左”倾路线错误在政治上、军事上、组织上、思想上的表现及其发展过程、主要内容、社会根源及其给中国革命所造成的严重危害 强调对于党内历史问题应采取“从团结出发，而又达到团结”的原则 高度评价毛泽东同志运用马克思列宁主义基本原理解决中国革命问题的杰出贡献 历史意义 我们党不在 1935 年作关于历史问题的决议，就是为了把全党同志团结起来，我们要等待犯错误的同志觉悟到自己的错误。如果我们在 1935 年作结论，这些同志是不会接受的。毛主席的路线是正确路线尚且需要等待，那么并不那么正确的路线，就更不待说了。 邓小平 《关于建国以来党的若干历史问题的决议》 简要回顾新中国成立以前二十八年的历史 社会主义革命和建设时期党的历史做了系统总结 结束“文化大革命”以来党和国家事业实现的伟大转折 党的十一届三中全会以来， 《中共中央关于党的百年奋斗重大成就和历史经验的决议》 党的百年奋斗的历史意义 党的百年奋斗从根本上改变了中国人民的前途命运 党的百年奋斗的历史经验 十个坚持 两大特点 总结党的百年奋斗重大成就和历史经验 三个亮点 共同特点 形成于重要的历史关头 中国全面抗战进入关键时刻 “文化大革命”结束后中国实行改革开放新探搜 中国共产党成立 100 周年，世界处于百年未有之大变局 发挥着重要的历史作用 对历史经验进行深刻总结 围绕在一个经济文化落后的东方大国 凝聚了全党的共识 历史启示","link":"/2021/history/%E5%85%9A%E7%9A%84%E5%8E%86%E5%8F%B2%E5%86%B3%E8%AE%AE%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%94%E8%BF%9B%E5%92%8C%E5%90%AF%E7%A4%BA/"},{"title":"博客日志","text":"本文记录博客的变更信息。 Web 服务器： 博客托管于美国加州圣何塞 域名：https://waferlab.tk Github Pages: https://atlanswer.github.io 2019年7月26日：博客上线，使用 Hexo 框架，服务器位于东京。 2019年7月27日：采用 Icarus 主题，完成基本布局。发布了第一篇文章“跨阻放大器简介”。 2019年7月30日：完善博客部署流程，修改Post not found: tutorial/Hexo-博客写作流程 “博客写作流程”介绍文章。 2019年10月7日：更新 Icarus 2.6.1。 2019年10月9日：迁移博客服务器。 2019年10月11日：Markdown 渲染器切换到 hexo-renderer-markdown-it，提升了页面渲染速度的同时解决了一些错误排版问题。 2019年10月12日：修改博文页面布局，新增最近更改时间。现在博文将按照最后修改的时间排序。 2019年10月13日：中文字体更改为 Noto Sans SC。 2019年10月21日：修复了页面目录链接错误的 bug。 2019年10月23日：更改字体 CDN 为 Google Fonts，博客页面字体配置为 Roboto、Noto Sans SC、Noto Sans JP。 2020年2月4日：迁移博客服务器。 2020年3月4日：博客同时托管在 Github Pages，补充了 404 页面。 2020年4月10日：更新 Icarus 3。 2020年4月9日：更新字体配置，衬线字体为 Roboto、Noto Sans SC，等宽字体为 Roboto Mono。 2020年8月10日：迁移博客服务器。 2020年9月5日：更新 Icarus 4。 2021年7月17日：添加 GitHub Actions，实现自动构建并同步至 GitHub Pages。 2021年7月20日：更新 GitHub Actions，实现自动同步至 WaferLab。 2021年10月12日：服务器后端更改为 GitLab。","link":"/2019/log/blog-log/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2019/log/hello-world/"},{"title":"ArchLinux on Windows Subsystem for Linux","text":"Prerequisites Update Windows Head to Windows Features, enable Windows Subsystem for Linux Set WSL 2 as th default version when installing a new Linux distribution: 123&gt; wsl --set-default-version 2For information on key differences with WSL 2 please visit https://aka.ms/wsl2The operation completed successfully. Installation ArchWSL Install the appx package. Setup Initialize 12345&gt; Arch.exeUsing: C:\\Program Files\\WindowsApps\\yuk7.archwsl_21.8.28.0_x64__35zwpb4sx6e50\\rootfs.tar.gzInstalling...Installation completePress enter to continue... User settings Set the root password. 12345&gt; Arch.exe[root@EM-Workstation ~]# passwdNew password:Retype new password:passwd: password updated successfully Edit /etc/sudoers file. 1[root@EM-Workstation ~]# EDITOR=vim visudo Add user. 12345[root@EM-Workstation ~]# useradd -m -G wheel -s /bin/bash atlanswer[root@EM-Workstation ~]# passwd atlanswerNew password:Retype new password:passwd: password updated successfully Set to default user. 123[root@EM-Workstation ~]# exitlogout&gt; Arch.exe config --default-user atlanswer Initialize keyring 123&gt; Arch.exe[atlanswer@EM-Workstation ~]$ sudo pacman-key --init[atlanswer@EM-Workstation ~]$ sudo pacman-key --populate Pacman settings Add ParallelDownloads = 5 to /etc/pacman.conf to enable parallel downloads.","link":"/2021/note/ArchLinux-on-Windows-Subsystem-for-Linux/"},{"title":"Endless Word List","text":"An ever growing word list to help memorization. Errata noun: a list of errors in a printed work discovered after printing and shown with corrections 勘误 encompass verb: to include different types of things 包含，包括（尤指不同事物） patrilineal adj: in a patrilineal society or relationship, the fact that someone belonging to a particular family depends only on male relatives 父系的 phonetic adj: using special signs to represent the different sounds made by the voice in speech 语音的 syllabary noun: a set of written characters representing syllables and (in some languages or stages of writing) serving the perpose of an alphabet 音节表 literate adj: able to speak and write 识字的 adj: having knowledge or a particular subject, or a particular type of knowledge 掌握（某个领域或某方面）知识的；通晓...的 auspicious suggesting a positive and successful future 吉利的；吉祥的 flourish verb: to grow or develop successfully 茁壮成长；繁荣；蓬勃发展 verbatim adv: using exactly the same words as were originally used 一字不差地；逐字地","link":"/2022/note/Endless-Word-List/"},{"title":"Git Detached Work Tree","text":"Separate work tree from the git directory, useful when the git repository is a bare git repository located on a git server. Synopsis 1git [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] &lt;command&gt; [&lt;args&gt;] Example 12git --git-dir=/home/git/hexo-blog.git --work-tree=/var/www/blog checkout -f publishgit --git-dir=/home/git/hexo-blog.git --work-tree=/var/www/blog reset --hard HEAD","link":"/2021/note/Git-Detached-Work-Tree/"},{"title":"GitLab Configuration","text":"Installation Docker Compose File Configuration Let's Encrypt Integration Should be disabled because of the server configuration. /etc/gitlab/gitlab.rb1letsencrypt['enable'] = false Nginx Prevent the bundled Nginx from handling SSL termination. /etc/gitlab/gitlab.rb12345nginx['listen_port'] = 80nginx['listen_https'] = falsenginx['real_ip_trusted_addresses'] = [ '192.168.1.0/24', '172.22.0.1/24', '2001:0db8::/32' ]nginx['real_ip_header'] = 'X-Real-IP'nginx['real_ip_recursive'] = 'on' OmniAuth /etc/gitlab/gitlab.rb12345678910111213141516171819202122232425gitlab_rails['omniauth_enabled'] = truegitlab_rails['omniauth_allow_single_sign_on'] = ['github']gitlab_rails['omniauth_sync_email_from_provider'] = ['github']gitlab_rails['omniauth_sync_profile_from_provider'] = ['github']gitlab_rails['omniauth_sync_profile_attributes'] = ['name', 'email', 'location']gitlab_rails['omniauth_auto_link_user'] = ['github']gitlab_rails['omniauth_allow_bypass_two_factor'] = ['github']gitlab_rails['omniauth_auto_sign_in_with_provider'] = 'github'gitlab_rails['omniauth_block_auto_created_users'] = truegitlab_rails['omniauth_providers'] = [ { 'name' =&gt; 'github', 'app_id' =&gt; 'APP_ID', 'app_secret' =&gt; 'APP_SECRET', 'args' =&gt; { 'scope' =&gt; 'user:email' } }]#### SSH```ruby /etc/gitlab/gitlab.rbgitlab_rails['gitlab_ssh_host'] = 'git.waferlab.dev:port'gitlab_rails['gitlab_ssh_user'] = 'git' Optimize Puma Start only a single Puma process. /etc/gitlab/gitlab.rb1puma['worker_processes'] = 0 Optimize Sidekiq It is advised to configure it to use a significantly smaller value of 5 or 10 (preferred). /etc/gitlab/gitlab.rb1sidekiq['max_concurrency'] = 8 Optimize Gitaly Gitaly is a storage service that allows efficient access to Git-based repositories. It is advised to configure a maximum concurrency and memory limits enforced by Gitaly. /etc/gitlab/gitlab.rb12345678910111213gitaly['ruby_max_rss'] = 200_000_000gitaly['concurrency'] = [ { 'rpc' =&gt; &quot;/gitaly.SmartHTTPService/PostReceivePack&quot;, 'max_per_repo' =&gt; 3 }, { 'rpc' =&gt; &quot;/gitaly.SSHService/SSHUploadPack&quot;, 'max_per_repo' =&gt; 3 }]gitaly['env'] = { 'GITALY_COMMAND_SPAWN_MAX_PARALLEL' =&gt; '2'} Disable monitoring GitLab enables all services by default to provide a complete DevOps solution without any additional configuration. Some of the default services, like monitoring, are not essential for GitLab to function and can be disabled to save memory. /etc/gitlab/gitlab.rb1prometheus_monitoring['enable'] = false Action Cable Don't know how it works. /etc/gitlab/gitlab.rb1actioncable['enable'] = true Backups To prune old backups: /etc/gitlab/gitlab.rb1gitlab_rails['backup_keep_time'] = 604800 Database Automatic database reindexing /etc/gitlab/gitlab.rb1gitlab_rails['database_reindexing']['enable'] = true SMTP QQ exmail /etc/gitlab/gitlab.rb12345678910gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = &quot;hwsmtp.exmail.qq.com&quot;gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = &quot;xxxx@xx.com&quot;gitlab_rails['smtp_password'] = &quot;password&quot;gitlab_rails['smtp_authentication'] = &quot;login&quot;gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['gitlab_email_from'] = 'gitlab@waferlab.dev'gitlab_rails['smtp_domain'] = &quot;exmail.qq.com&quot; Container Registry We don't need it currently. /etc/gitlab/gitlab.rb1registry['enabled'] = false Logging Docker’s default logging driver is json-file, which performs no log rotation by default. As a result of this lack of rotation, log files stored by the json-file driver can consume a significant amount of disk space for containers that generate a lot of output. This can lead to disk space exhaustion. To address this, use journald as the logging driver when available, or another supported driver with native rotation support.","link":"/2021/note/GitLab-Config/"},{"title":"Linux Quick Reference","text":"进入 Linux 环境 本地 Native 选择适合相应工作流的 Linux 发行版，例如 Arch Linux。 创建系统镜像，推荐使用 Rufus，参照发行版指南安装至本地计算机。 VM 在虚拟机中使用 Linux 发行版，例如 Oracle VM VirtualBox。 推荐使用 Windows Subsystem for Linux。 远程 Linux 服务 使用 OpenSSH -p 指定 SSH 端口 在校园网内访问服务器 1ssh &lt;username&gt;@&lt;server&gt; 例如 1ssh asic_21210000@222.200.181.71 第一次登录时会提示验证服务器身份，选择确认记住服务器 终端快捷方式 打开终端窗口 ctrl + alt + t 或 super + t（macOS） 以下操作仅对符合 POSIX 标准的 shell 有效（例如 bash，sh，zsh） 快速移动指针 ctrl + a 移动到行首 ctrl + e 移动到行尾 ctrl + xx 在当前位置和行首间切换 alt + f 前移一词 alt + b 后移一词 终端控制 tab 启动自动补全 tab tab 显示所有自动补全选项 up &amp; down 浏览命令历史记录 ctrl + l 清除终端内容 ctrl + c 终止正在运行的进程，回到提示符 ctrl + z 暂停当前正在运行的前台进程，回到提示符；可以继续使用 bg 指令让进程在后台继续运行。使用 fg 指令让后台进程回到前台。使用 jobs 指令查看所有后台进程 常用文件系统操作 本文中，&lt;参数&gt; 表示必填参数，[参数] 表示可选参数，... 表示可列举多个选项 .. 表示上级目录，. 表示当前目录 文件名开头为 . 的文件被视为隐藏文件（例如 .bashrc） 帮助与手册 help [-dms] [pattern] 显示 shell 内置指令的用法 man &lt;name&gt; ...（manual）查阅与 name 有关的使用手册 apropos &lt;editor&gt; 显示描述内包含 &lt;editor&gt; 字样的程序名，在不记得程序名称的时候非常好用 whatis &lt;editor&gt; 显示程序的简要描述 导航 pwd（print working directory） 显示当前工作目录 cd [-L|-P] [dir]（change directory）切换目录至 dir cd - 切换至上次工作目录 cd ~ 或仅用 cd 切换至用户主目录 cd .. 切换至当前目录的上级目录 列举文件 ls [option]... [FILE...]（list）显示目录内容 -l 使用长表格格式显示当前目录内的文件信息 -d, --directory &lt;dir-name&gt; 显示 dir-name 文件夹本身的信息而非其内容 -a, --all 显示所有文件，包括隐藏文件 -F, --classify 在文件名后添加其类型（* 可执行文件，/ 文件夹，@ 符号链接，= socket，| named pipe，&gt; door） -t 按最后修改时间排序，最近修改的文件在前 -h, --human-readable 可结合 -l，显示易读的文件大小 -R, --recursive 递归列出所有子目录 tree 使用树形格式显示目录内容 创建、复制、删除文件或文件夹 touch [option]... FILE... 原本用于更改文件时间戳，但也可用于创建新文件 12// 新建 `newfile` 文件touch newfile cp [option]... [-T] &lt;source&gt; &lt;dest&gt;，cp [option]... &lt;source&gt;... &lt;directory&gt; 或 cp [option]... -t &lt;directory&gt; &lt;source&gt;...（copy）可复制文件 source 到 dest，或多个文件 source 到文件夹 directory -R, -r, --recursive 递归复制目录内容 -i, --interactive 覆盖文件前显示提示 mv（move）可用于重命名文件或是移动文件 12// 将 `file1` 重命名/移动为 `file2`mv file1 file2 rm 用于删除文件 -i 交互式删除，会提示确认每个文件 -R 递归删除文件夹内的所有文件 -f 强制删除而不提示 rmdir 用于删除文件夹，默认仅用于删除空文件夹 mkdir（make directory）新建文件夹 -p dir_name/dir_name 新建文件夹目录，目录中不存在的层级将被自动创建 文件权限 Linux 是多用户操作系统，使用权限系统控制文件 chmod 可更改文件/文件夹权限 -R 递归应用于文件夹内所有文件 更改文件权限，可用标记为 + 增加权限 - 移除权限&quot; = &amp; u 拥有此文件的用户 g 文件所有组 o 其他用户 r 可读 w 可写 x 可执行 增减、作用域和权限类型组合成一个标记，例如 123chmod &lt;specification&gt; filenamechmod u+x script.shchmod go=+r chown 用于更改文件所有者 1chown owner1 filename chgrp 用于更改文件所有组 1chgrp grp_owner filename 压缩解压文件 tar 用于创建和解压压缩文件 -c 创建新压缩文件 -x 解压 -t 列举压缩包内的文件 -f, --file=&lt;ARCHIVE&gt; 指向文件或文件夹 &lt;ARCHIVE&gt; -v 详细输出 -a, --auto-compress 自动判断压缩程序 -j 使用 bzip2 -J, --xz, --lzma 使用 xz -z --gzip 使用 gzip --exclude 压缩或解压时跳过文件/文件夹 压缩文件夹 使用 gzip 1tar -czvf archive.tar.gz folder-to-be-compress 查看压缩文件内容 1234$ tar -tf archive.tar.gzFolder/Folder/file1Folder/file2 解压文件 1tar -xvzf archive.tar.gz -C directory/destination 传输文件 使用 scp 传输文件 将本地文件复制到远程计算机 1scp local_archive.tar.gz asic_21215000@222.200.181.71:~/ 将远程文件复制到本地 1scp asic_21215000@222.200.181.71:~/archive.tar.gz . 常用 Linux 命令行工具 echo 可打印信息，例如 12$ echo &quot;Hello World&quot;Hello World more 和 less 是显示文件内容的常用工具，使用交互式的操作只读地浏览文件内容 12// 显示所有已安装的软件包（Debian）less /var/lib/dpkg/available head 显示文件的头几行，tail 显示文件的后几行 hostname 显示计算机名，用于网络访问 passwd 可用于更改用户密码 whoami 查看当前用户名 who 列举所有已登录的用户 last 最近登录的用户 last root root 用户最后一次登录的时间 lastb 列举最近失败的登录尝试 top &amp; htop 查看当前运行的进程，按 q 退出 ps 列出当前 shell 内运行的进程 -u 查看某个用户运行的程序 aux 列举所有用户运行的所有程序 在命令行中编辑文本文件，可使用 vi 或 vim，或是 nano 等传统编辑器 vi 系列的编辑器可在不同模式间切换，i 进入输入模式，ESC 退回到命令模式，v 进入选择模式，在命令模式下使用 :w 保存，:q 退出 更多操作 查看文件大小 du 1du [OPTION]... [FILE]... du（disk usage） 显示 FILE 占用的空间，如果 FILE 是文件夹，则遍历其中所有的文件。 通常使用 -sh 选项 -s, --summarize 仅显示文件夹整体大小 -h, --human-readable 使用易读的格式显示（例如 1K，234M，2G） 例如，显示当前目录下每个文件夹的大小 123456$ du -sh *143K Documents107M Downloads52M Musics625K Pictures5,0K Templates 同时统计隐藏文件 1234567891011$ du -sh .[!.]* *4,0K .bash_history4,0K .bash_logout8,0K .bashrc520M .cache128M .config143K Documents107M Downloads52M Musics625K Pictures5,0K Templates 使用 -c 选项统计总大小 12345678910$ du -sch .[!.]* *...520M .cache128M .config143K Documents107M Downloads52M Musics625K Pictures5,0K Templates808M total 环境变量和执行上下文 . &lt;filename&gt; [arguments] 或 source &lt;filename&gt; [argument] 在当前 shell 内读取并执行 filename 所指的文件，并返回其最后一条命令的退出状态。如果 filename 中不包含右划线 /，则在环境变量 PATH 中寻找可执行文件 filename bg [jobspec ...] 在后台恢复暂停的任务 jobspec，类似于使用 &amp; 启动它，不提供 jobspec 则恢复当前任务 fg [jobspec] 在前台恢复任务 jobspec，将其标记为当前任务 echo [-neE] [arg ...] 使用空格分隔各 arg，加入回车并打印到标准输出 exit [n] 使用状态 n 退出当前 shell export [-fn] [name[=word]] ...，export -p 将 name 加入环境变量，对在该指令之后执行的指令生效，不提供选项或使用 -p 选项则显示当前 shell 内所有使用 export 引入的环境变量 用户文件夹下的 .bashrc 是 bash 的初始化文件，可在其中定义初始环境变量和别称 alias command_alias='actual command' 可为指令赋予别名 更改默认 Shell 查看当前 Shell 12$ echo $SHELL/usr/bin/fish 列举可用 Shell 12345678// or use `cat /etc/shells`$ chsh -l/bin/sh/bin/bash/sbin/nologin/use/bin/sh/usr/bin/bash/usr/bin/fish 更改 Shell 1234$ chsh -s /usr/bin/fishChanging shell for user.Password:Shell changed. 查看系统信息 1234$ lsb_release -aNo LSB modules are available.Distributor ID: Debian... 或查看 123456789$ cat /etc/issueUbuntu 20.04.01 LTS \\n \\l$ cat /etc/os-releaseNAME=Fedora...$ (source /etc/os-release &amp;&amp; echo &quot;$PRETTY_NAME&quot;)Fedora 26 (Workstation Edition)$ cat /etc/redhat-releaseFedora release 26 (Twenty Six) uname（unix name）查看内核信息 12$ uname -aSunOS hope 5.7 Generic_106541-08 sun4m sparc SUNW,SPARCstation-10 mpstat 2 10 查看 CPU 信息 vmstat 2 10 &amp; free 查看内存信息 iostat -kx 2 查看硬盘状态 netstat 查看网络端口状态 iftop 实时监控网络状态 lscpu &amp; lshw 查看 CPU 和系统硬件的详细信息 推荐使用 screenfetch 快速浏览系统信息 查看系统服务 service -status-all 列举所有服务 systemd 是许多 Linux 发行版使用的服务管理器 systemctl 列举运行的服务 systemctl start/restart/stop 运行/重启/停止响应服务 systemctl enable/disable 允许/禁止自动启动 查看日志 Debian 家族的操作系统使用 jourald 记录日志 journalctl -u sshd 查看 sshd 模块日志 搜索文件 使用文件名搜索文件 12$ find /var/www -name '*.html'/var/www/html/index.html 在文件内搜索字符串 123$ grep font /var/www/html/style.cssfont-weight: bold;font-family: monospace; 在文件夹内搜索字符串 1grep -R font /var/www/html 推荐使用 ag 执行搜索 渲染本文件 安装 Markdown 渲染器 1npm install -g markdown-it 渲染为 HTML 1markdown-it Linux-Quick-Reference.md -o Linux-Quick-Reference.html 可使用浏览器保存为 PDF 等格式","link":"/2021/note/Linux-Quick-Reference/"},{"title":"QR Code Standard: ISO&#x2F;IEC 18004:2015","text":"Excerpted form ISO/IEC 18004:2015 QR Code Standard, modified. 11 Decoding procedure overview Locate and obtain an image of the symbol. Recognize dark and light modules as an array of “0” and “1” bits. Identify reflectance polarity from finder pattern module colouring. Read format information. … Read the version information (where applicable), … Release the data masking by XORing the encoding region bit pattern with the data mask pattern. The reference of which has been extracted from the format information. Read the symbol characters according to the placement rules for the model and restore the data and error correction codewords of the message. Detect errors using the error correction codewords corresponding to the Level Information. If any error is detected, correct it. Divide the data codewords into segments according to the mode indicators and character count indicators. Finally, decode the Data Characters in accordance with the mode(s) in use and output the result. 12 Reference decode algorithm for QR Code This reference decode algorithm finds the symbol in an image and decodes it. The decode algorithm refers to dark and light states in the image. Determine a Global Threshold by taking a reflectance value midway between the maximum reflectance and minimum reflectance in the image. Convert the image to a set of dark and light pixels using the Global Threshold. Locate the finder pattern. The finder pattern in QR Code consists of three identical finder patterns located at three of the four corners of the symbol. The finder pattern in Micro QR Code is a single finder pattern. As described in 6.3.3, module widths in each finder pattern form a dark-light-dark-light-dark sequence the relative widths of each element of which are in the ratios 1 : 1 : 3 : 1 : 1. For the purposes of this algorithm the tolerance for each of these widths is 0.5 (i.e. a range of 0.5 to 1.5 for the single module box and 2.5 to 3.5 for the three module square box). When a candidate area is detected note the position of the first and last points A and B respectively at which a line of pixels in the image encounters the outer edges of the finder pattern (see Figure 31). Repeat this for adjacent pixel lines in the image until all lines crossing the central box of the finder pattern in the x axis of the image have been identified. Repeat step i for pixel columns crossing the central box of the finder pattern in the y axis of the image. Locate the center of the pattern. Construct a line through the midpoints between the points A and B on the outermost pixel lines crossing the central box of the finder pattern in the x axis. Construct a similar line through points A and B on the outermost pixel columns crossing the central box in the y axis. The center of the pattern is located at the intersection of these two lines. Repeat steps i to iii to locate the centers of the two other finder pattern. If no candidate areas are detected, reverse the colouring of the light and dark pixels and recommence at the beginning of step 2 to attempt the decode the symbol as as a symbol with reflectance reversal. If a single patter is identified but two further finder patterns can not be located, attempt to decode the symbol as a Micro QR Code symbol by jumping to the Micro QR Code symbols reference decode (from step 13). Determine the rotational orientation of the symbol by analysing the finder pattern center coordinates to identify which pattern is the upper left pattern in the symbol and the angle of rotation of the symbol. Determine the distance $D$ crossing the full width of the symbol between the centers of the upper left finder pattern and the upper right finder pattern and the width of the two patterns, $W_{UL}$ and $W_{UR}$ as shown in Figure 32. Calculate the nominal $X$ dimension of the symbol. $$X=(W_{UL}+W_{UR})/14$$ Provisionally determine the version V of the symbol. $$V=[(D/X)−10]/4$$ If the provisional symbol version is 6 or less, this is specified as the defined version. If the provisional symbol version is 7 or more, the version information is decoded as follows. … For Version 1 symbols, redefine $X$ as the average spacing of the center points of the dark and light modules in the upper side Timing Patterns. In a similar manner, calculate the $Y$ dimension as the average spacing of the center points of the dark and light modules in the left side Timing Pattern. WIP","link":"/2019/note/QR-Code-Standard-ISO-IEC-18004-2015/"},{"title":"如何使用 ROS","text":"并不是所有的机器人都像电子设计普及赛要求的循迹小车那样简单，要实现精确的控制，让机器人采集复杂的信息并作出准确的判断并非易事。对循迹小车级别的要求，我们一般尝试从零开始实现所有的部分，换言之就是“造轮子”。当然，不存在真正从“零”起步的工作，例如制造二极管、编写编译器等过于基础的部分显然不包含在内。所谓从基础做起，其原料都是极易获取的组件。对基础的应用，每个团队得到的结果将大同小异，是否动手实现每个环节才是评判水平高低的重要标准。对评委来说，结果要求越低，参赛者动手实现程度越为重要。 随着机器人复杂程度的提高，这种“造轮子”式的开发方法逐渐变得不现实。基本上我们会选择从之前已有的工作开始，整合各个模块实现所需功能。这是需要解决的问题是：需要那些模块，如何使用这些模块，那些部分需要亲自实现，能否让不同来源的组件整合工作。对设计一个连接各个模块的框架的要求渐渐变得明显。 实践中，有很多团队尝试完成这种框架。ROS (Robot Operating System) 正是其中之一。 Work in Progress","link":"/2019/note/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ROS/"},{"title":"学术规范与论文写作","text":"研究活动 前沿研究性活动 解决基础科学中的理论猜想和实验问题 解决应用科学和技术难题 在新的环境、材料体系中寻找应用 生物医学领域 如何开展科研活动 夯实课程中的理论和实验基础 参与导师的创新研究项目 与导师进行学术问题讨论 广泛参与你感兴趣的研究课题的讨论（学术会议） 文献检索、阅读前沿研究内容 科技写作的内容 写作范畴 以标准格式，在科技期刊上发表的原创成果。 标准格式 作者信息 摘要（Abstract） 图（Figures） 表（Extended Data Table） 科技写作的关键 了解读者：理解接受、习语 表达清晰 科技写作中的结构和语言 写作流程 调整心态 认真准备 模仿行业文献：哪几部分、顺序、各部分篇幅、图表类型？ 投稿须知 命名法（nomenclature），参考文献格式等 随时记录论文想法 团队共享 写作提纲（outlines） 文件查找、文献管理 抓紧去写 标记预留时间 设置截止日期 从最容易的部分开始 Methods，Acknowledgment，Figures，Title，Abstract 遇到问题，先做标记 选择一个解决方案，无需最优，先完成草稿 修改完善 修改时思考的问题 全部必要信息、是否需要删除、推理是否正确、内容一致、结构合理、措辞清晰、表达简单扼要、语法拼写正确、图标设计是否合理、满足投稿须知要求？ 读者反馈 业内专家、领域内人士、聪敏的普通读者 反馈修改 误解问题、多名读者不懂 没有完美的论文 论文基本概念 科技论文的定义 科技论文是一种公之于众的，描述原创科研成果的书面报道。撰写必须遵循特定规范，这取决于传统、编辑惯例、科学道德以及印刷出版规程。 文献检索 引言 文献调研： 读人：追踪领域内权威专家 读典：精度经典文章、高被引文章 读新：泛读 + 精读最新科研文章 文献检索思路 关键词搜索 Google，Web of Science，Wikipedia，知乎，SciHub 等 深入的文献调研 读人 Google Scholar，Research Gate，Web of Science，个人主页，Quora，小木虫，Scopus 研究生时期的研究工作 Researcher 后的研究方向 重要文章 不同时间段的研究方向转变 重大科学发现前后的工作内容 读典 大家都在讨论的、推荐的：实验室、同行口口相传 Google Scholar 会列出相关文章、引用率排序 论文中在引言部分经常被引用的论文 其他工具 Web of Science（ESI 高被引） PubMed 读新 arXiv 文献订阅工具： Google Scholar Publication Alert Researcher RSS 阅读器 Feedly Inoreader 文献管理 EndNote Mendeley 课程选题 本学期任务起点： 找到一个感兴趣的题目 本周开始着手去研究它 今后的课程作业都会围绕这个题目 开始可以多考虑几个方向 一般都从读文献开始 如何确定一个题目： 读好文章 跟导师聊 初步跟进：看 Wikipedia，读 review 文章，与师兄师姐讨论 前沿阶段：读 paper，关注公众号 听学术报告 选题要求： 以上提到的方法都适用 希望通过文献阅读、提升自己某个方面新的认识 终稿建议仿写英文论文 每周大家根据课堂内容，修改自己的论文，并以此参与课堂讨论 不能拷贝别人的东西 不要求理论、实验创新，但是认识可以创新，提出评价，或者某方面自己的深刻认识 最终稿没有字数限制 建议由浅入深，经过本学期的课程学习，能把问题讲清楚 文字规划 斟酌标题 撰写摘要 摘要定义 微型版论文（miniature version）—— structured abstract 研究目标和范围 Background 描述研究方法 Method 总结研究结果 Result 给出结论 Conclusion 摘要类型 信息型摘要（Informative abstract） 指示型摘要（Indicative/descriptive abstract） 作业：撰写摘要 研究背景和问题：通过阅读文献等方法，确立自己的研究问题 根据我们讨论的摘要的写法，形式性地撰写一则摘要，内容尽可能贴近现实，少量虚构也可以 注意三点：问题描述、研究方法、研究结果的表达 撰写引言部分","link":"/2021/note/%E5%AD%A6%E6%9C%AF%E8%A7%84%E8%8C%83%E4%B8%8E%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"},{"title":"Generate a UUID","text":"GUID (aka UUID) is an acronym for 'Globally Unique Identifier' (or 'Universally Unique Identifier'). It is a 128-bit integer number used to identify resources. The term GUID is generally used by developers working with Microsoft technologies, while UUID is used everywhere else. Online GUID / UUID Generatorwww.guidgenerator.com Generate a GUID in PowerShell: 1[guid]::NewGuid() or Javascript UUID Generator","link":"/2021/tip/Generate-a-UUID/"},{"title":"Windows Terminal and PowerShell","text":"What's the difference between a console, a terminal, and a shell? PowerShell Installation (Windows) https://aka.ms/PSWindows Winget 1winget install --name PowerShell --exact --source winget Profile 12code $PROFILE. $PROFILE Oh My Posh Installation (PowerShell) https://ohmyposh.dev/docs/ 12Install-Module oh-my-posh -Scope CurrentUserUpdate-Module oh-my-posh Configuration Windows Terminal Install from Microsoft Store. Configuration","link":"/2021/tip/Windows-Terminal-and-PowerShell/"},{"title":"HFSS 仿真基础","text":"HFSS 介绍 ANSYS HFSS是电磁场仿真的常用工具[1]。 HFSS 使用的数学方法 HFSS 利用有限元法（Finite element method, FEM）求解电磁场。该技术将结构划分为许多小组件，称为有限元。HFSS 划分的有限元是四面体，所有四面体的集合称为网格。HFSS 首先对有限元内的场求解，然后将各场关联起来使有限元间的边界满足麦克斯韦方程组。 式 \\((1)\\) 计算电场 \\(\\bm{E}\\)： \\[ \\nabla\\times\\left(\\frac{1}{\\mu_r}\\nabla\\times\\bm{E}\\right) -k_0^2\\epsilon_e\\bm{E}=0 \\tag{1} \\] 其中 \\(\\mu_r=\\mu/\\mu_0\\)，\\(\\epsilon_r=\\epsilon/\\epsilon_0\\)，\\(k_0^2=\\omega^2\\epsilon_0\\mu_0=\\omega_2/c^2\\)。 式 \\((2)\\) 计算磁场 \\(\\bm{H}\\)： \\[ \\bm{H}=\\frac{j}{\\omega\\mu}\\nabla\\times\\bm{E} \\tag{2} \\] Work in Progress An Introduction to HFSS: Fundamental, Principles, Concepts, and Use. A copy could be found here. ↩︎","link":"/2021/tutorial/HFSS-%E4%BB%BF%E7%9C%9F%E5%9F%BA%E7%A1%80/"},{"title":"How to Write Documentation","text":"Reference: Clear, Functional C++ Documentation with Sphinx + Breathe + Doxygen + CMake","link":"/2021/tutorial/How-to-Write-Documentation/"},{"title":"Nature Formatting Guide","text":"Reference: Nature for Authors. Nature Articles Articles are original reports whose conclusions represent a substantial advance in understanding of an important problem and have immediate, far-reaching implications. In print, they do not normally exceed 5 pages of Nature. Articles start with a fully referenced summary paragraph, ideally of no more than 200 words, which is separate form the main text and avoids numbers, abbreviations, acronyms or measurements unless essential. As a guideline, articles typically have 30-50 references, but be mindful of the space that these will occupy on the page. (There is no such constrain on any additional references associated with a Methods or Supplementary Information file.) Format of Articles Contributions should be double-spaced and written in English (spelling as in the Oxford English Dictionary). Contributions should be organized in the sequence: title, authors, affiliations (plus present addresses), bold first paragraph, main text, main references, tables, figure legends, methods (including separate data and code availability statement), methods references, acknowledgements, author contributions, competing interest declaration, additional information (containing supplementary information line (if any) and corresponding author line), extended data figure/table legends. In order to facilitate the review process, for initial submissions we encourage authors to incorporate the manuscript text and figures together in a single file (Microsoft Word or PDF, up to 30 MB in size). The figures may be inserted within the text at the appropriate positions to grouped at the end, and each figure legend should be presented together with its figure. Also, please include line numbers within the text. Title Text Our preferred format for text is Microsoft Word, with the style tags removed. TeX/LaTeX: If you have prepared your paper using TeX/LaTeX, we will need to convert this to Word after acceptance, before your paper in typeset. All textual material of the paper (including references, tables, figure captions, online methods, etc.) should be included as a single .tex file. We prefer the use of a standard font, preferably 12-point Times New Roman. For mathematical symbols, Greek letters and other special characters, use normal text or Symbol font. Word Equation Editor/MathType should be used only for formulae that cannot be produced using normal text or Symbol font. References References are each numbered, ordered sequentially as they appear in the text, tables, boxes, figure legends, online-only methods, Extended Data tables and Extended Data figure legends. When cited in the text, reference numbers are superscript, not in brackets unless they are likely to be confused with a superscript number. Do not use linked fields (produced by EndNote and similar programs). Please use the one-click button provided by EndNote to remove EndNote codes before saving your file. As a guideline, articles allow up to 30 references in the main text, but can go up to 50 references if needed and within the allocated page budget. Only one publication can be listed for each number. Only articles that have been published or accepted by a named publication, or that have been uploaded to a recognized preprint server (for example, arxiv, bioRxiv), should be in the reference list; papers in preparation should be mentioned in the text with a list of authors (or initials if any of the authors are co-authors of the present contribution). Published conference abstracts, numbered patents, preprints on recognized servers (preprints of accepted papers in the reference list should be submitted with the manuscript) and research datasets that have been assigned a digital object identifier may be included in reference list, but text, grant details and acknowledgements may not. (An exception is the highlighted references which we ask authors of Reviews, Perspectives and Insights articles to provide.) All authors should be included in reference lists unless there are more than five, in which case only the first author should be given, followed by 'et al.'. Please follow the style below in the published edition of Nature in preparing reference lists. Authors should be listed in surname first, followed by a comma and initials of given names. Titles of all cited articles are required. Titles of articles cited in reference lists should be in upright, not italic text; the first word of the title is capitalized, the title written exactly as it appears in the work cited, ending with a full stop. Book titles are italic with all main words capitalized. Journal titles are italic and abbreviated according to common usage. Volume numbers are bold. The publisher and city of publication are required for books cited. (Refer to published papers in Nature for details.) Research datasets may be cited in the reference list if they have been assigned digital object identifiers (DOIs) and include authors, title, publisher (repository name), identifier (DOI expressed as a URL). Example: Hao, Z., AghaKouchak, A., Nakhjiri, N. &amp; Farahmand, A. global Integrated Drought Monitoring and Prediction System (GIDMaPS) data sets. figshare http://dx.doi.org/10.6084/m9.figshare.853801 (2014). Recognized preprints may be cited in the reference list. Example: Babichev, S. A., Ries, J. &amp; Lvovsky, A. I. Quantum scissors: teleportation of single-mode optical states by means of a nonlocal single photon. Preprint at https://arXiv.org/quant-ph/0208066 (2002). References to web-only journals should give authors, article title and journal name as above, followed by URL in full - or DOI if known - and the year of publication in parentheses. References to websites should give authors if known, title of cited page, URL in full, and year of posting in parentheses. Work in Progress","link":"/2021/tutorial/Nature-Formatting-Guide/"},{"title":"Reserved Port Range on Windows","text":"Reference: Stack Overflow Hyper-V reserves some random ports, causing binding problems for other programs. To check the reserved port range: 1netsh int ip show excludedportrange protocol=tcp","link":"/2021/tutorial/Reserved-Port-Range-on-Windows/"},{"title":"YouTube 字幕的正确编辑方式","text":"说在前面 添加字幕极大地改善了视频的观感。字幕不仅仅能为观看外语视频提供必要的帮助，同时使在嘈杂或者其他无法听清 / 听见声音的情况下理解视频内容变得可能。如果应用得当，字体、颜色、位置等高级字幕提供的效果可为视频内容锦上添花。 在模拟电视时代，隐藏字幕(Closed Caption, CC) 是一个单独的模拟信号轨道，CEA-608 是美国、加拿大和墨西哥的 NTSC 电视隐藏字幕标准。如今 FCC 要求电视节目必须提供隐藏式辅助字幕 1 2，广电总局也发布了 GY/T 270-2013 作为我国数字电视隐藏字幕系统的规范。 在 HTML5 规范中，subtitles 指观众不能听懂的语言的文字转写，例如外语对话的翻译；而 captions 指没有声音或听不清时对话、环境音效、音乐提示和其他有关声音信息的文字描述，一般我们把这两者都叫做字幕。所谓隐藏字幕，表示观看者可以选择将其打开或关闭。这个概念与嵌入在视频中的固定式字幕相对。 内嵌字幕很容易理解：把字幕外观渲染成对应的像素叠在视频的上方，制作成新的视频。Adobe After Effects 等高级非编软件可以在视频中创造令人印象深刻的字幕效果。但显然，隐藏式字幕比将其直接嵌入视频更为优雅。实现隐藏字幕需要额外的保存字幕信息的文件，视频播放器在播放时渲染字幕。这种实现方法让观众可以更灵活地控制字幕的显示效果，除了能够方便地打开关闭字幕外，修改字体和其大小、颜色，甚至让字幕显示在视频之外的空间都能做到。 很多流行的视频播放器都支持常见的外部字幕，因此外部字幕在光盘或下载内容中更常见，或作为独立的文件，或被装入 MKV 容器中。外部字幕包括一般只在 DVD 中才见得到的图形数据格式和使用广泛的文本数据格式。前者将字幕以图片形式呈现，例如 SUB、SST，可以显示非常特殊的效果，但是体积较大的同时也不方便修改；后者以文本保存字幕内容和格式信息，例如简单的 SubRip、SubViewer、LRC 和功能丰富的 SAMI、TTML、SubStation Alpha 等。 视频播放软件的字幕支持经过十几年的发展已经相当成熟，如今字幕普及的瓶颈是在线视频，大多数的视频网站播放器根本没有提供 CC，所以很长时间内大家都只能选择在编辑好字幕文件之后把其内容直接渲染到视频里面，虽然可以实现众多字幕效果，但这种做法并不符合 CC 的初衷。如果嵌入视频的字幕有问题，修改起来比较麻烦，不但需要重新渲染视频，还可能要等待视频网站的重新审核。 走在前列的视频网站正着手解决这些问题。YouTube 实现了 CC，同时也提供自动字幕和翻译；bilibili 的外挂字幕系统也上线了将近一年。从我的体验来看，YouTube 的 CC 功能确实好用，尤其在智能算法的帮助下，其自动生成的字幕质量已经非常令人满意，而且 YouTube 播放器能够显示高级字幕格式，下文会介绍更多。在B站，我相信大家也都认同外挂字幕还没有到流行的程度，话特别多的视频或没有字幕，更多情况下创作者或搬运者还是选择把字幕嵌进视频中的传统做法，这当然与 bilibili 对外挂字幕的支持有密切的关系。如果在线播放器能够实现与本地软件一致的字幕支持，想必外部字幕会成为首选方案。 在线视频播放器中实现外部字幕并不是件容易的事，不过对 bilibili 来说可能相对简单一点，弹幕本身就可以做字幕，不过很容易被遮挡或清理，在外部字幕实现之前，解决方案是由视频发布者手动指定字幕弹幕。但弹幕能实现的效果对字幕来说还是不够，在自家的播放器中尽量实现字幕格式支持的效果成为各视频网站的目标。YouTube Studio 有一个简单的在线字幕编辑器，也能上传特定的字幕文件，具体的支持列表看这里。 Work in Progress","link":"/2019/tutorial/YouTube-%E5%AD%97%E5%B9%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%BC%96%E8%BE%91%E6%96%B9%E5%BC%8F/"},{"title":"《雨とカプチーノ》歌词翻译","text":"《雨とカプチーノ》是ヨルシカ的第二首单曲，2019年8月20日发售，也是乐队第二张完整专辑《エルマ》的第四曲。ぽぷりか和まごつき制作的 MV 8月1日在 YouTube 发布。 body { background-color: linen; } .sub { font-size: x-large; } .trans { font-size: large; } 灰(はい)色(いろ)に白(しら)んだ言葉(ことば)はカプチーノみたいな色してる 灰中带白的话语 颜色像是卡布奇诺 言(い)い訳(わけ)はいいよ 窓辺(まどべ)に置(お)いてきて 借口不必再说 留在窗边就好 数(かぞ)え切(き)れないよ 是数不尽的啊 灰色に白んだ心はカプチーノみたいな色してる 灰中泛白的心情 颜色像是卡布奇诺 言い訳はいいよ 呷(あお)ろうカプチーノ 不理会这些托词 大口饮尽卡布奇诺 戯(おど)けた振(ふ)りして 做着玩笑般的举动 さぁ揺蕩(たゆた)うように雨流(なが)れ 像飘忽不定的雨滴一般摇曳吧 僕らに嵐(あら)す花に溺(おぼ)れ 让我们沐浴在这花雨之中 君が褪(あ)せないような思(おも)い出(で)を 像是对你无法拂去的思念 どうか、どうか、どうか君が溢(あふ)れないように 还奢望、奢望着、奢望着它不要满溢而出 波(なみ)待(ま)つ海岸(かいがん) 紅(くれない)夕(ゆう)差(さ)す日 ... 窓(まど)に反射(はんしゃ)して ... 八月のヴィスビー 潮騒(しおさい) ... 待ちぼうけ 海風一(ひと)つで ... 夏泳(およ)いだ花の白さ、宵(よい)の雨 ... 流(なが)る夜(よる)に溺(おぼ)れ ... 誰も褪せないような花一つ ... どうか、どうか、どうか胸の内(うち)側(がわ)に挿(さ)して ... ずっとおかしいんだ ... 生(い)き方(かた)一つ教(おし)えてほしいだけ ... 払(はら)えるものなんて僕にはもうないけど ... 何も答(こた)えられないなら言葉一つでもいいよ ... わからないよ ... 本当にわかんないんだよ ... さぁ揺蕩(たゆた)うように雨流(なが)れ 像飘忽不定的雨滴一般摇曳吧 僕らに嵐(あら)す花に溺(おぼ)れ 让我们沐浴在这花雨之中 君が褪(あ)せないように書(か)く詩(うた)を ... どうか、どうか、どうか今(いま)も忘(わす)れないように ... また一つ夏が終(お)わって、花一つを胸に抱(だ)いて、 ... 流る目(ま)蓋(ぶた)の裏(うら)で ... 君が褪せないようにこの詩を ... どうか、どうか君が溢れないように ... WIP","link":"/2019/tutorial/%E3%80%8A%E9%9B%A8%E3%81%A8%E3%82%AB%E3%83%97%E3%83%81%E3%83%BC%E3%83%8E%E3%80%8B%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"title":"了解 ROS image_transport 和 cv_bridge","text":"当我们需要在 ROS 节点间传递数据时，首先考虑使用 common_msgs 中已经提供的 messages。因为通用 ROS 包使用这些 msg，一般来说需要的功能已经被实现而不用自己手打。如果需要传递图片，sensor_msgs 提供了 Image 消息类型，同时有 image_pipeline 可以对 Raw 数据展开简单处理。但 OpenCV 如此流行，很多框架都准备了自带类型与 cv::Mat 相互转换的接口，ROS 也不例外。这篇文章主要探索在 ROS 中使用 OpenCV 处理图片的方法。 在 ROS 环境中使用 OpenCV catkin 只是一个基于 cmake，添加了有关 ROS 的宏的编译系统，因此要在 ROS 环境中单纯地使用 OpenCV 与常规 cmake 设置相同。 CMakeLists.txt 在包级别的 CMakeLists.txt 中加入 OpenCV 库 1234567891011...## System dependencies are found with CMake's conventionsfind_package(OpenCV REQUIRED)...## Specify additional locations of header files## Your package locations should be listed before other locationsinclude_directories(include ${catkin_INCLUDE_DIRS} ${OpenCV_INCLUDE_DIRS})...add_executable(nodeName src/source.cpp ...)## Specify libraries to link a library or executable target againsttarget_link_libraries(nodeName ${catkin_LIBRARIES} ${OpenCV_LIBS}) 源文件 加入 OpenCV 头文件即可，例如 123#include &quot;opencv2/imgproc.hpp&quot;#include &quot;opencv2/imgcodecs.hpp&quot;#include &quot;opencv2/highgui.hpp&quot; AUR 中提供的 ros-melodic-desktop 依赖 opencv3-opt，版本目前为 3.4.6，与 ROS Melodic 一道安装在 /opt，与官方仓库中的 opencv 独立，不过 Ubuntu 上的情况我不太清楚。在 CMakeLists.txt 中链接 OpenCV 库之后 catkin 应该就可以编译带有 OpenCV 的程序了。 sensor_msgs/Image sensors_msgs/Image 是 ROS 中的无损图片类型，其 msg 定义如下： 1234567Header header # 图片信息，包括 timestamp, frame_id 和 originuint32 height # 图片行像素数uint32 width # 图片列像素数string encoding # 指定编码格式，参考 include/sensor_msgs/image_encodings.huint8 is_bigendian # 指定字节顺序uint32 step # 完整一行的长度，单位为字节uint8[] data # 实际图片内容矩阵，大小为 step * rows gencpp 据此生成了三个类型： 1234typedef ::sensor_msgs::Image_&lt;std::allocator&lt;void&gt; &gt; Image;typedef boost::shared_ptr&lt; ::sensor_msgs::Image &gt; ImagePtr;typedef boost::shared_ptr&lt; ::sensor_msgs::Image const&gt; ImageConstPtr; 包括类 Image，以及指向它的两个智能指针。他们分别对应 cv_bridge 处理图片的两种方式，详情见下文。 cv_bridge cv_bridge 包用于实现 sensor_msgs/Image 与 cv::Mat 的互转。 其简化结构如下： 123456789101112131415namespace cv_bridge { typedef boost::shared_ptr&lt;CvImage&gt; CvImagePtr; typedef boost::shared_ptr&lt;CvImage const&gt; CvImageConstPtr; class CvImage { public: CvImage(...); // +1 overloads std_msgs::Header header; std::string encoding; cv::Mat image; sensor_msgs::ImagePtr toImageMsg() const; }; CvImagePtr toCvCopy(...); // 4 overloads CvImageConstPtr toCvShare(...); // 2 overloads} 可以看到，cv_bridge 提供 CvImage 类，在里面直接封装了 cv::Mat，其数据成员基本上与 sensors_msgs/Image 一一对应。 image_transport ROS 推荐使用 image_transport 发布和订阅图片，理由是它有多种传输策略来实现压缩传输和视频流编解码，但是 image_transport 本身只提供 raw 传输，其余方式由插件提供，image_transport_plugins 带有 &quot;compressed&quot; 和 &quot;theora&quot;，分别用于压缩图片和视频。 通用 ROS 安装中的三个图传包为 image_transport - 通过 sensors_msgs/Image 传输原始图片 compressed_image_transport - 使用 JPEG 或 PNG 压缩 theora_image_transport - 应用 Theora 编解码器传输视频 使用配置 要使用上述工具，需修改包级别的 package.xml 和 CMakeLists.txt 以添加依赖并告诉 catkin 导入库并生成相关文件。 package.xml 123456789101112131415...&lt;build_depend&gt;roscpp&lt;/build_depend&gt;&lt;build_depend&gt;std_msgs&lt;/build_depend&gt;&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;build_depend&gt;image_transport&lt;/build_depend&gt;&lt;build_depend&gt;cv_bridge&lt;/build_depend&gt;&lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;&lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;&lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;&lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;&lt;exec_depend&gt;sensor_msgs&lt;/exec_depend&gt;&lt;exec_depend&gt;image_transport&lt;/exec_depend&gt;&lt;exec_depend&gt;cv_bridge&lt;/exec_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 在 package.xml 中添加有关依赖，roscpp 用于生成 C++ 代码，std_msgs 是基本消息类型，在构建时需要 message_generation，而运行时只需要 message_runtime。 CMakeLists.txt 1234567891011121314151617181920212223242526272829...## Find catkin macros and librariesfind_package(catkin REQUIRED COMPONENTS roscpp std_msgs sensor_msgs message_generation image_transport cv_bridge)...## Generate added messages and services with any dependencies listed heregenerate_messages( DEPENDENCIES std_msgs sensor_msgs)...## CATKIN_DEPENDS: catkin_packages dependent projects also needcatkin_package( ... CATKIN_DEPENDS sensor_msgs image_transport cv_bridge ...)...add_executable(nodeName src/source.cpp ...)target_link_libraries(nodeName ${catkin_LIBRARIES} ${OpenCV_LIBS})## Add cmake target dependencies of the libraryadd_dependencies(nodeName ${PROJECT_NAME}_gencpp)... 源文件 在源文件中引用相关头文件。 123#include &quot;ros/ros.h&quot;#include &quot;image_transport/image_transport.h&quot;#include &quot;cv_bridge/cv_bridge.h&quot; 其中 cv_bridge.h 已经包含了 sensor_msgs 的头文件： 123#include &lt;sensor_msgs/Image.h&gt;#include &lt;sensor_msgs/CompressedImage.h&gt;#include &lt;sensor_msgs/image_encodings.h&gt;","link":"/2019/tutorial/%E4%BA%86%E8%A7%A3-ROS-image_transport-%E5%92%8C-cv_bridge/"},{"title":"如何使用 Hexo 博客","text":"这篇文章的目的是为本博客的博文作者提供指导，介绍需要准备的工具、写作流程和发布方法。 Hexo 文档 安装 生产环境 Hexo 是静态博客框架，请访问 nodejs.org 或使用包管理器获取 Node.js 8.3 以上版本，同时附带包管理器 npm。 123456# Debian or Ubuntuapt install nodejs# Archpacman -S nodejs npm# Windowswinget install nodejs 之后即可使用 npm 安装 Hexo，建议设置为全局安装： 1npm install -g hexo-cli 请不时更新以获得 bug 修补和新功能。 为方便部署，我们使用 Git 管理版本，访问 git-scm 或使用包管理器安装它。 clone 仓库后首先获取主题： 1$ git submodule update --init --recursive 然后安装依赖： 1$ npm install Hexo 使用 Markdown 创作博文，因此建议使用带有 Markdown 预览的编辑器。准备工作结束之后，就能开始愉快地写作了。 生产环境设置 修改 Icarus 主题 更换 hexo-renderer-markdown-it 服务器 Serverless (GitHub) GitHub Pages 设置 参考 .github/workflow/build_deploy.yml。 每次推送提交到 GitHub 时将自动构建一次以检查错误，推送标注日期的标签同时会触发同步至 Github Pages 和 WaferLab。 WaferLab 服务器 GitLab 设置 流程 1. 新建页面 1$ hexo new [layout] [option] &lt;title&gt; 在制定布局的基础上新建文章，可用选项有 Option Description -p, --path 自定义文章路径 -r, --replace 覆盖指定博文 -s, --slug 自定义文章URL 要新建草稿，使用： 1$ hexo new draft &lt;title&gt; 草稿将不会被渲染，亦不会被展示。草稿完成后可用 publish 发布： 1$ hexo publish [layout] &lt;title&gt; 2. 写博文 使用 Markdown 撰写文章，同时可以使用 HTML 元素实现更灵活的布局和其他功能，Hexo 插件提供了例如资源文件夹管理等实用工具。 使用折叠： 123456&lt;details&gt;&lt;summary&gt;Summary&lt;/summary&gt;Details here.{% codeblock lang:md %}Even code blocks are supported.{% endcodeblock %}&lt;/details&gt; Summary Details here. 1Even code blocks are supported. 高级功能 数学公式支持 使用 \\\\(Tex\\\\)、插入行内公式， $$Tex$$、\\\\[Tex\\\\] 插入行间公式。 公式渲染使用 \\(\\KaTeX\\)。 插入目录 在 Front-matter 中指定 1toc: true Hexo 将在预设位置渲染页面目录，方便长文章的浏览。 标签助手 标签插件的概念来源于 Octopress，可以通过简单的 ejs 标签方便地在文章中插入想要的内容，详情参考文档。 Justified Gallery 展示画廊，将多个图片包裹在 &lt;div class=&quot;justified-gallery&quot;&gt; 与 &lt;/div&gt; 的 HTML 标签对中，如果使用 Markdown 语法来引用图片的话，请在 HTML 标签和 Markdown 之间添加空行。例如： 12345678910&lt;div class=&quot;justified-gallery&quot;&gt;![Elephant](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/elephant.jpeg)![Dog](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/dog.jpeg)![Birds](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/birds.jpeg)![Fox](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/fox.jpeg)![Horse](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/horse.jpeg)![Leopard](https://ppoffice.github.io/hexo-theme-icarus/gallery/animals/leopard.jpeg)&lt;/div&gt; 炫酷的页面元素或样式 这些东西都是 Bulma 框架提供的，请查阅其文档使用各种元素。 3. 发布 写作完成后让 Hexo 渲染更改过的页面： 1hexo g -b: 抛出错误 -w: 跟踪文件更改 source 文件夹中的源文件将被转换为网页，保存在 publish 文件夹中。 在本地预览更改的效果，在发布前及时修改错误： 1hexo s -o: 使用浏览器打开链接 使用 Hexo 的部署功能将网页推送到服务器： 123hexo d# 或者连续完成渲染和部署hexo g -d Hexo 部署使用 git 将网页文件推送至远程的 publish 分支。在服务器上，git hooks 会在接收推送后自动将网站复制到 nginx 的根目录，可以立即在公网上查看更改。 注意直接部署并不会推送博客配置文件以及文章源文件，要备份整个工作区，保存最近对主题或配置的更改，请手动推送 master 分支到服务器，这个过程与部署相独立。 Work in Progress","link":"/2019/tutorial/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Hexo-%E5%8D%9A%E5%AE%A2/"},{"title":"脉搏信号传感器","text":"完成跨阻放大器设计之后，下一步的要求是使用光电传感器检测脉搏信号。本文将介绍关于脉搏信号传感器的知识并展示若干设计方案。 脉搏信号传感器的原理 脉搏信号传感器，或称心率检测器 (HRM)，是用于记录实时心跳信息的装置。 记录心率的意义想必无须赘述。HRM 检测与脉搏有关的特征，分析记录即可得到心率。依不同检测技术而定，HRM 除推断心率以外还能获取更多有关心脏健康情况的信息。 WIP","link":"/2019/tutorial/%E8%84%89%E6%90%8F%E4%BF%A1%E5%8F%B7%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"跨阻放大器 (Transimpedance Amplifier) 简介","text":"模拟电路中的放大模块一般都围绕着运算放大器设计，而运算放大器是直流耦合、差模输入的高增益电压放大器 1。虽然运放本身只能放大差分电压，但通过引入著名的反馈，可以改变增益的物理意义，实现各种形式的转换。 本学期本科生们都会选择加入学院的实验室做实践学习，我翻遍学院教师目录，决定争取跟谢教授研究生物电子方向。与两位小伙伴讨论之后，我花了一下午雕琢出一篇英文咨询邮件表明我们加入的意向，然而我收到的回复竟是 写邮件还不如加微信群，时代变了。 实验室老师和研究生们为有意加入的所有同学开了一场理论讲座，要求是完成按阶段布置的任务，按报告质量排名选择最优秀的同学。Fine，我最不怕的挑战就是这类了，只有付出努力坚持到底的人才得能到最终的胜利。 然而实际的任务要求远没有这么令人热血沸腾，第一个实践是所谓电子信息方向理论实践，在两个月内完成，其要求是 实现 $0\\sim100\\mu A$ 直流电流放大至 $0\\sim3.3V$。 Pretty simple right? 一个有基本电学常识的人能很快地由欧姆定律得到 $100\\mu A$ 的电流乘 $33k$ 的电阻等于 $3.3V$ 电压的等式，那么直接让输入电流通过一个 $33k$ 的电阻流向参考地，那么电阻电流流入一端就是所需的电压输出点了。 这个事实显得此题的问法非常弱智，然而确实应该这样解决吗？答案是 是 亦不是。 跨阻放大器的概念及原理 说使用欧姆定律从电流得到电压的思路正确，是因为这确实是一个理论上可行且简单的方案。在早期的集成电路或是现在我们这些 awful circuit designer 的设计中，可以见到使用大阻值电阻串联从电源轨道上分得参考电压的场景，这种做法可以理解为流过分压电阻的小电流在其两端产生对应压降。值得注意的是，利用分压电阻所得到的电压只作为参考电压，并非为驱动负载而设计。一旦从参考点接入低阻抗的负载，或是受到较强噪声的影响，参考电压将变得不再准确。 解决方案是使用运算放大器，其高输入电阻、低输出电阻的特点帮助正确放大输入信号。 WIP","link":"/2019/tutorial/%E8%B7%A8%E9%98%BB%E6%94%BE%E5%A4%A7%E5%99%A8-Transimpedance-Amplifier-%E7%AE%80%E4%BB%8B/"},{"title":"转录组学分析","text":"这是一篇关于使用 Trinity 进行无参转录组分析的文章，首先会简单介绍转录组学，接着会介绍 Trinity 软件的使用，最后会记录相关的下游分析。 一、转录组学 概述： 转录组广义上指在某一生理条件下，细胞内所有转录组产物的集合，包括：mRNA、ncRNA、rRNA 等；狭义上指所有 mRNA 的集合。 转录组测序的研究对象为特定细胞在某一功能状态下所能转录出来的所有 RNA 的总和，主要包括 mRNA 和 ncRNA。 转录组具有时间特异性、组织特异性、空间特异性等特点。 类型 特点 分析策略 有参转录组 需要所研究的物种有组装注释质量较好基因组序列，一般来说比对效率达到 70% 以上才能满足后续分析。 比对—定量—差异分析—功能富集分析（下游分析） 无参转录组 缺乏相应的质量较高的基因信息，需要从零开始组装分析 组装—定量—差异分析—功能富集分析（下游分析） 下游分析包括：GO 基因功能注释、KEGG 通路分析、mRNA 表达量计算、差异基因筛选、功能和通路富集分析、时间序列分析、共表达网络分析等。 二、Trinity 介绍与使用 基本介绍 Trinity 是由 Broad Institute 开发的转录组 de novo 组装软件，由三个独立的软件模块组成：Inchworm （虫）（C++） 、Chrysalis （蛹）（C++）、Butterfly （蝶）（Java）。三个软件依次来处理大规模的 RNA-seq 的 reads 数据。 组成部分 作用 工作过程 Inchworm （虫）（C++） 序列延伸 a. 将 reads 切为 k-mers (k bp 长度的短片段)b. 利用 Overlap 关系对k-mers 进行延伸 (贪婪算法)c. 输出所有的序列 (“contigs”) Chrysalis （蛹）（C++） 构建 de Brujin graph a. 聚类所有相似区域大于 k-1bp 的 contigsb. 构图 (区分不同的 “components”)c. 将 reads 比对回 components，进行验证 Butterfly （蝶）（Java） 解图，列举转录本 a. 拆分 graph 为线性序列b. 使用 reads 以及 pairs 关系消除错误序列 Trinity使用 1. 下载与安装 trinity 最新版本是 v2.4.0，下载。 123$ nohup wget -c https://github.com/trinityrnaseq/trinityrnaseq/archive/Trinity-v2.4.0.tar.gz 1&gt;trinity.o 2&gt;trinity.e &amp; # 下载$ tar -zxvf Trinity-v2.4.0.tar.gz # 解压$ make # 编译 2. 使用 命令： Trinity --seqType fq --left reads_1.fq --right reads_2.fq --CPU 6 --max_memory 20G 几个重要参数介绍： --seqType 支持输入数据格式为 fq 或者 fa 双端测序：--left 为read1，--right 为 read2，多个样品的 reads 由逗号隔开，不允许出现空格（依版本而定） 单端测序：--single 加上文件 多个样品的 reads 由逗号隔开，不允许出现空格（依版本而定） --CPU 软件所用 CPU 数量 --max_memory 内存控制（组装过程中，jellyfish 这一步是最耗费资源的一步 所以这个内存主要由 jellyfish 控制） --SS_lib_type RF 链特异性文库需要加上这个参数，其中 RF 表示文库的构建方法，点这了解，最好看看 --no_run_butterfly 不进行 butterfly 步骤，在 Chrysalis 这一步完成后中断 --no_run_quantifygraph 不进行 quantifygraph 这一步 --output trinity 的输出文件夹，默认在trinity_out_dir/Trinity.fasta --no_version_check 不汇报版本信息 结果 最终会得到一个 Trinity.fasta 的文件，在同文件夹下还会有其他的中间过程产生的文件，其中这个文件最为重要，是最终的组装结果。 三、下游分析（有待完善） 1. GO功能注释 2. KEGG通路分析 3. 差异基因分析与筛选 4. 功能和通路富集分析 5. 结果可视化（火山图、箱线图、MAplot、pheatmap等） 参考资料 官方文档 介绍博客 无参转录组分析 转录组学知识点 可视化分析（重点火山图） 介绍博客（Trinity参数）","link":"/2019/tutorial/%E8%BD%AC%E5%BD%95%E7%BB%84%E5%AD%A6%E5%88%86%E6%9E%90/"},{"title":"选择合适的测距传感器","text":"常用测距传感器比较表 内容摘录自北醒论坛🙃。 传感器 应用 优势 劣势 超声波传感器 工业质量监控、直径和尺寸检测液位检测机器人避障汽车避障智能家居 无任何机械传动部件，不怕电磁干扰，不怕酸碱等强腐蚀性液体，稳定性较强。 频率高、波长短、绕射现象小，特别是方向性好，能够成为射线而定向传播。 对液体、固体的穿透本领很大，尤其在阳光下不透明的固体。 抗干扰能力弱，任何声学噪声都可能干扰传感器的正常输出，两个相同频率的超声波传感器放在一起，会产生声学串扰。同时会受到烟雾、灰尘、雨滴的干扰。 报错率较高，发射角度较大，针对障碍物较多时，反射回来的声波较多，干扰较多。 测量范围有限，测量范围通常在百米以内，不适合超远距离探测。 测量精度低，超声波测距传感器的测量精度通常是厘米级的。 只能检测平面介质，例如声波被58度斜面接收到声音之后，声波无法正常传回接收器。 不利于测量高速移动的物体，由于超声波利用声音速度传播，相较于利用光学传感器测量，响应时间比较长。 毫米波传感器 汽车辅助驾驶智能交通工业安防无人机定高智能家居 探测距离远，通常都可以在百米外探测。 抗干扰能力强，全天候工作，穿透雾、烟、灰尘的能力强。 针对多目标探测有优势。 探测精度低，好的线性调频不易获得，影响距离分辨率。 易受电磁干扰，产生误报。 针对细小或者微小的物体测距识别较差。 在防空环境中，不可避免的会出现距离模糊和速度模糊。 激光雷达 物位计 (物料、液体)智能交通汽车辅助驾驶工业安防无人机定高、仿地飞行智能家居 精度高，在测距、识别障碍物方面最为准确，黑夜中也可工作。 内部无任何机械传动部件，寿命较旋转激光雷达高，稳定性较强。 探测距离适中。 测量方式多样，包括单点测量及面阵测量。 安装便捷，具有体积小、质量轻，功耗小，价格优势非常明显。 在雨雪雾霾天，沙尘暴等恶劣天气中开启会影响测距量程。 量程有限，针对200米以内的目标探测精准。 针对黑色高亮物体识别量程有衰减。","link":"/2019/tutorial/%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%B5%8B%E8%B7%9D%E4%BC%A0%E6%84%9F%E5%99%A8/"},{"title":"对外开放","text":"摘录自《广东改革开放 40 年研究丛书 - 广东对外开放 40 年》 研究广东改革开放，要系统总结广东改革开放 40 年的伟大成就，增强改革不停顿、开放不止步的信心和决心。 广东是中国改革开放的排头兵、先行地、试验区，在改革开放和现代化建设中始终走在全国前列，取得了举世瞩目的辉煌成就，展现了改革开放的磅礴伟力。 广东实现了从一个经济比较落后的农业省份向全国第一经济大省的历史性跨越。1978 - 2017 年，广东 GDP 从 185.85 亿元增加到 89 879.23 亿元，增长约 482.6 倍， 占全国的 10.9%。1989 年以来，广东 GDP 总量连续 29 年稳居全国首位，成为中国第一经济大省。经济总量先后超越新加披、中国香港和台湾地区，2017 年超过全球第 13 大经济体澳大利亚，进一步逼近“亚洲四小龙”中经济总量最大的韩国，处于世界中上等收入国家水平。 广东实现了从计划经济体制向社会主义市场经济体制的历史性变革。 广东实现了从封闭半封闭到全方位开放的历史性转折。 广东实现了由要素驱动向创新驱动的历史性变化。 广东实现了从温饱到全面小康迈进的历史性飞跃。 广东实现了生态环境由问题不少向逐步改善的历史性转变。 历史回顾 第一章 先行先试：广东对外开放拉开大帷幕 改革开放伊始：开启序幕 对外开放的探索：经济特区 对外开放的探索：外贸体制改革 第二章 扩大开放：广东对外开放迈向新台阶 邓小平南方谈话指明前进航向 大力引进和优化外资 出口导向战略引领对外贸易发展 深化粤港澳经济合作 广东成为中国改革开放“试验田”和示范区 第三章 国际接轨：广东对外开放争当排头兵 中国加入 WTO 与广东对外开放 粤港澳合作 “三来一补”与“香港因素” 第四章 转危为机：广东对外开放勇闯深水区 化挑战为机遇，积极应对金融危机 科学规划，推动形成高水平开放新格局 习近平总书记重要讲话精神和指示批示精神引领方向 第五章 全面引领：广东对外开放构建新格局 实施创新驱动发展战略 建设广东自由贸易试验区 打造“一带一路”核心枢纽 共建“粤港澳大湾区”新增长极","link":"/2021/history/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E5%AF%B9%E5%A4%96%E5%BC%80%E6%94%BE/"},{"title":"中国共产党的使命","text":"新民主主义革命时期 新中国成立至改革开放时期 新中国成立后，党的使命是全面恢复经济，建立社会主义制度。 1950 中国土地改革法 社会主义改造总路线：一化三改 制度保障：社会主义制度的建立 根本政治制度 改革开放时期 1978 - 2012 1978 - 1984 农村改革：家庭联产承包责任制 1984 - 1992 十二届三中全会至十四大 城市经济体制改革 1992 - 2003 十四大：建立社会主义市场经济体制 2003 - 2012 十六届三中全会至十八大 新时代党的使命 2012 至今 问题 需要更多理论上的论证 数据要注明出处 各个方面的做法 为实现中华民族伟大复兴的具体步骤 四个伟大，五位一体总体布局，四个全面战略布局 第二小组：党的领导 问题：为什么要坚持中国共产党的领导，为什么无产阶级需要共产党的领导 问题：有人认为西方政党大多轮流执政，中国共产党是一党专政， 除了历史实践和人民的选择之外，从无产阶级专政的理论来看，为什么需要坚持中国共产党的领导 需要领导核心，代表无产阶级利益 阶级斗争已经不是中国社会的主要矛盾，不需要多个政党代表各个阶级。 新时代中国特色社会主义中的政治建设与党的政治建设有什么区别 政治信仰：共产主义信仰 党的政治建设是什么 政治建设与思想建设的区别 党的政治建设指政治建设指政治信仰、政治立场、政治原则等 思想建设与政治建设中的政治信仰部分有重叠 什么是党的政治属性 意识形态是什么意思 思想观念、思想文化、思想价值 虚假观念 意识形态一词带有价值立场和阶级立场 深化供给侧结构性改革 为什么要进行供给侧结构性改革 新发展阶段、新发展格局、新发展理念 新发展阶段指的是从现在到未来的什么时间段 预计到建国一百年（建成社会主义现代化强国） 对外开放 改革和开放的关系 人民当家作主的制度体系 社会保障 资本主义与社会主义的社会保障区别 从功能，目的上答，社会性质 社会保障与经济发展的关联 社会公平正义 如何理解公平正义是历史的，具体的，相对的 如何理解社会公平观核心是生产正义 社会治理 马克思主义的群众观点 社会治理主题多元化有没有主次之分，为什么 国体对社会治理的影响 共同富裕 怎么理解共同富裕是一个过程 缩小收入分配差距和共同富裕有什么区别 传统文化观 什么是意识形态，文化对意识形态的影响，文化安全 生态文明建设 国际环境会议，其他国家指责我国碳排放量位居首位，我国的减排是否是为了应对国际压力？ 改革开放以来就开始重视，为了称为负责任的大国承担保护环境的责任 来自我们自己对人类社会发展的认识，意识到人和自然的统一和环境保护的重要性 从唯物辩证法解读生态文明？ 世界的物质统一性原理揭示了生态文明建设的重要性和紧迫性？ 物质统一性原理：世界的本原是物质、意识也统一与物质 生态环境的破坏，改变以往征服自然的思维方式，要顺应自然发展方式 环境破坏的根本原因是？ 人的不适当的实践活动造成生态破环环境污染： 为什么人有不适当的实践活动，包括社会制度： 例如资本主义制度 争地严重，城市与农田规划具体内容？ 底线思维：生态保护红线划定 永久基本农田划定：保证农民权益 城市开发边界划定 共同但有区别的责任原则 各个国家应对生态威胁的区别在哪？ 从历史上看每个国家工业发展的历史节点不一样，发达国家对环境的污染占主要责任，发达国家将造成污染的产业转移到发展中国家，因此不能将环境治理责任以排放量为依据 资本主义生产环境下，生态问题无法避免；改变生产关系才是解决生态问题的解决方案 为什么社会主义下还会出现生态问题 社会主义初级阶段，很多政策制度不健全 国家安全 通过怎样的机制达到文化渗透的目的 通过电影等文化产品进行输出，在通常价值观中夹杂私货。 国防与军队现代化 敌对势力实施的“政治转基因工程”、“军队国家化” 目的是使我军脱离党的领导 “军队与政治无关”的说法站不站得住脚：军队是政治上层建筑的一部分，无法与政治脱钩。西方政治势力之间的斗争是资产阶级各派之间的斗争，非资产阶级与无产阶级的矛盾。 “军队国家化”刻意隐瞒国家的政治性。西方国家政治制度保证了军队的领导权在资产阶级手中，无论政党如何轮替。党对军队的绝对领导代表了无产阶级专政国家。 资本主义输血式扶贫 比较资本主义制度发钱扶贫和社会主义共同富裕 维持社会运转的工具，暂时保持社会稳定的手段 为什么提出倡导人类命运共同体 人类命运共同体是多方面的 基于的原因和现状：全球化深入发展，各国利益紧紧联系在一起，存在共同的利益和责任；经济政治文化中的差距和不平等","link":"/2021/history/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/%E8%AF%BE%E7%A8%8B%E5%B1%95%E7%A4%BA%E6%B1%87%E6%80%BB/"},{"title":"不定式","text":"在寻找涉及单一独立变量的函数的极限时，如果可以把它表示为多个函数通过基本初等函数运算的组合，通常可以代入每个函数的极限求得结果。如果在代入每个函数的极限后仍无法确定极限的值，则待求极限的函数被称为不定式 (Indeterminate form)[1][2]。 为什么代入各极限后仍无法确定极限呢，只可能因为出现了未定义的运算。这些表达式通常涉及 \\(0\\), \\(1\\), \\(\\infty\\)，常见的不定式类型如下： \\[\\frac{0}{0},\\ \\frac{\\infty}{\\infty},\\ 0\\times\\infty,\\ \\infty-\\infty,\\ 0^0,\\ \\infty^0\\text{ and }1^\\infty\\] Quotient Indeterminate Forms 除式是最常见的不定式形式，即在计算两个函数的比值 \\(\\frac{f(x)}{g(x)}\\) 的极限时出现 \\(\\frac{0}{0}\\) 或 \\(\\frac{\\infty}{\\infty}\\)。这一类型最经典的例子是微分，考虑如下极限： \\[ \\lim\\limits_{\\Delta\\to0}\\frac{f(x+\\Delta)-f(x)}{\\Delta} \\] 这种定义下的微分计算是 \\(\\frac{0}{0}\\) 型的不定式。 若分子和分母都可微，分母导数不为零，即可使用洛必达法则计算不定式极限。但在使用洛必达法则前，也可以考虑如下解决方法。 0/0 型不定式 尝试因式分解，约去使分母变成零的因子。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to1}\\frac{x^2+x-2}{x^2-1}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to1}\\frac{x^2+x-2}{x^2-1}&amp;= \\lim\\limits_{x\\to1}\\frac{(x-1)(x+2)}{(x-1)(x+1)} \\\\ &amp;=\\lim\\limits_{x\\to1}\\frac{x+2}{x+1} \\\\ &amp;= \\frac{3}{2} \\end{aligned} \\] 这里只能约去分子分母上相同的因式，而且因式的极限存在。在使用上述微分定义推导导数时，目标是去掉分母上的无穷小后再求极限，但到底能不能直接约去无穷小是个值得思考的问题。在牛顿和莱布尼茨的时代，对无穷小的处理存在前后矛盾，令人难以理解微积分的逻辑，直到十九世纪柯西和魏尔施特拉斯的工作建立了严格的极限和实数理论，才解决了微积分的严密性问题，把微积分的无矛盾性问题归结为实数系统的无矛盾问题。所以说，微积分得以严密化的基础是：实数域的完备性（或连续性）。 ∞/∞ 型不定式 分子分母同时除以自变量的最高次幂。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\frac{4x^4+2x^2-1}{3x^4-5x^3}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to\\infty}\\frac{4x^4+2x^2-1}{3x^4-5x^3}&amp;= \\lim\\limits_{x\\to\\infty} \\cfrac{4+\\cfrac{2}{x^2}-\\cfrac{1}{x^4}} {3-\\cfrac{5}{x}} \\\\ &amp;= \\frac{4}{3} \\end{aligned} \\] 显然，对趋于无穷的极限而言，当分母幂次高于分子，极限为零；分子幂次高于分母，极限为无穷；只有分子分母幂次相等，极限才是最高次幂系数的商。 当然使用洛必达法则能更快解决问题。 Other Indeterminate Forms 其他形式的不定式可以通过恒等变形转换为除式形式，再使用以上方法计算极限。 0 × ∞ 型不定式 \\(0\\times\\infty=\\cfrac{0}{\\frac{1}{\\infty}}=\\cfrac{\\infty}{\\frac{1}{0}}\\) 例：求 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x\\cdot\\ln(x)\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to0^+}x\\cdot\\ln(x)&amp;= \\lim\\limits_{x\\to0^+}\\cfrac{\\ln(x)}{\\cfrac{1}{x}} \\quad\\left(\\frac{\\infty}{\\infty}\\right) \\\\ &amp;= \\lim\\limits_{x\\to0^+}\\cfrac{\\cfrac{1}{x}}{-\\cfrac{1}{x^2}} \\quad\\text{(L’Hopital)} \\\\ &amp;= \\lim\\limits_{x\\to0^+}\\cfrac{1}{-\\cfrac{1}{x}} \\\\ &amp;= 0 \\end{aligned} \\] ∞ - ∞ 型不定式 通分或进行分子有理化。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to1}\\left(\\frac{x}{x-1}-\\frac{2}{x^2-1}\\right)\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to1}\\left(\\frac{x}{x-1}-\\frac{2}{x^2-1}\\right)&amp;= \\lim\\limits_{x\\to1}\\frac{x(x+1)-2}{(x-1)(x+1)} \\quad\\left(\\frac{0}{0}\\right) \\\\ &amp;= \\lim\\limits_{x\\to1}\\frac{(x-1)(x+2)}{(x-1)(x+1)} \\\\ &amp;= \\frac{3}{2} \\end{aligned} \\] 例：求 \\(\\displaystyle\\lim\\limits_{x\\to+\\infty}\\sqrt{x+1}-\\sqrt{x}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to+\\infty}\\sqrt{x+1}-\\sqrt{x}&amp;= \\lim\\limits_{x\\to+\\infty}\\cfrac{x+1-x}{\\sqrt{x+1}+\\sqrt{x}} \\\\ &amp;= 0 \\end{aligned} \\] 指数型不定式 剩下三种不定式类型 \\(0^0\\)、\\(\\infty^0\\)、\\(1^\\infty\\)。注意不要靠直觉判断其极限，可以使用对数函数的性质将其转换为容易处理的形式。 \\[ \\begin{aligned} y(x) &amp;= e^{\\ln{y(x)}} \\\\ \\lim\\limits_{x\\to c}f(x)^{g(x)}&amp;= \\lim\\limits_{x\\to c}\\exp\\left(g(x)\\cdot\\ln{f(x)}\\right) \\end{aligned} \\] 如果转换为乘法后仍不足以解决问题，可以再变形为除式。因此处理这类问题的方法是令待求极限的函数为 \\(y(x)\\)，然后试求 \\(\\ln{y(x)}\\) 的极限，最后求指数函数。 例：求 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\left(1+\\frac{5}{x}\\right)^x\\) 令 \\(y = \\left(1+\\frac{5}{x}\\right)^x\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to\\infty}\\ln{y}&amp;= \\lim\\limits_{x\\to\\infty}x\\cdot\\ln\\left(1+\\frac{5}{x}\\right) \\quad(\\infty\\times0) \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{\\ln\\left(1+\\frac{5}{x}\\right)}{\\frac{1}{x}} \\quad(\\frac{0}{0}) \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{\\frac{1}{1+\\frac{5}{x}}\\left(-\\frac{5}{x^2}\\right)} {-\\frac{1}{x^2}}\\quad\\text{(L’Hopital)} \\\\ &amp;= \\lim\\limits_{x\\to\\infty} \\frac{5}{1+\\frac{5}{x}} \\\\ &amp;= 5 \\end{aligned} \\] 则 \\(\\displaystyle\\lim\\limits_{x\\to\\infty}\\left(1+\\frac{5}{x}\\right)^x=e^5\\) 例：求 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x^{\\frac{1}{\\ln{x}}}\\) 令 \\(y = x^{\\frac{1}{\\ln{x}}}\\) \\[ \\begin{aligned} \\lim\\limits_{x\\to0^+}\\ln{y}&amp;= \\lim\\limits_{x\\to0^+}\\frac{1}{\\ln{x}}\\cdot\\ln{x} \\\\ &amp;= 1 \\end{aligned} \\] 则 \\(\\displaystyle\\lim\\limits_{x\\to0^+}x^{\\frac{1}{\\ln{x}}}=e\\) 如果不属于以上所述的七种类型，其他形似不定式的形式都是可以直接判断结果的，它们并不是不定式，例如： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\infty\\times\\infty=\\infty \\\\ 0^{\\infty}=0 \\\\ 0^{-\\infty}=\\infty \\\\ \\infty^{\\infty}=\\infty \\\\ \\infty^{-\\infty}=0 \\\\ \\end{array} \\] 所有指数函数的例子中要求底数非负，否则指数函数未定义。 Wikipedia ↩︎ Brilliant ↩︎","link":"/2020/note/Advanced-Mathematics/%E4%B8%8D%E5%AE%9A%E5%BC%8F/"},{"title":"数列和函数的极限","text":"数列 Wikipedia 数列指的是一列数。“一列”指出其至少具有一维，即有序性。我们用正整数为每一项编号，\\(a_1,a_2,\\dotsc,a_n,\\dotsc\\) 表示无穷数列，简称数列，记作 \\({a_n}\\)。 如果有通项 \\(a_n\\) 的解析式，那么数列可以看成定义在正整数集上的函数 \\(f:\\Z^+\\to y\\)：\\[f(n)=a_n,\\ n=1,2, \\dotsc\\] 数列的极限 Wikipedia \\(\\epsilon-N\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{n\\to\\infty}a_n=l \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist N&gt;0,\\ \\forall n&gt;N\\implies |a_n-l|&lt;\\epsilon \\end{array} \\] 若极限 \\(l\\) 存在，则称数列收敛 (convergent)，否则发散 (divergent)。 数列极限的性质 夹逼定理 (squeeze theorem) \\[ \\def\\arraystretch{1.5} \\begin{array}{l} \\exist N_0\\in\\Z^+,\\text{ if } a_n\\leqslant b_n\\leqslant c_n,\\forall n&gt;N_0,\\\\ \\text{ and}\\lim\\limits_{n\\to\\infty} a_n=\\lim\\limits_{n\\to\\infty}b_n=l,\\\\ \\text{ then}\\lim\\limits_{n\\to\\infty}c_n=l \\end{array} \\] 不等式：极限 \\(\\implies\\) 数列 2 的推论：由极限判断数列符号 不等式：数列 \\(\\implies\\) 极限 四则运算 注意四则运算的前提是两个数列都收敛。 四则运算可以推广到有限个数列的四则运算，但对无限次运算不一定成立。 数列收敛的充要条件是所有子数列都收敛，所有极限与原数列极限相同。 证明数列发散的方法 利用 6，由子数列发散或收敛与不同值证明原数列发散。 证明数列收敛的方法 利用定义。\\(N\\) 的取值决定于 \\(\\epsilon\\)，不需要求得最小的 \\(N\\)。 利用实数域的完备性：单调有界数列必有极限，但没有给出求极限的方法。 夹逼定理。 通过四则运算得到重要极限的组合。 重要极限 例：证明 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n\\) 存在。 证明： 证明 \\(a_n=\\left(1+\\frac{1}{n}\\right)^n\\) 递增，即 \\[ \\begin{aligned} \\left(1+\\frac{1}{n}\\right)^n&amp;&lt;\\left(1+\\frac{1}{n+1}\\right)^{n+1}\\\\ \\implies\\sqrt[n+1]{\\left(1+\\frac{1}{n}\\right)^n}&amp;&lt;\\frac{n+2}{n+1} \\end{aligned} \\] 在不等关系中遇到 \\(\\sqrt[n]{x^n}\\)，即几何平均值，可以考虑使用均值不等式： \\[ \\sqrt[n+1]{\\left(1+\\frac{1}{n}\\right)^n} &lt;\\frac{n\\left(1+\\frac{1}{n}\\right)+1}{n+1} =\\frac{n+2}{n+1} \\] which is amazing, 为什么不等式在这里恰好合适呢，我暂时没有头绪。 根据实数域的完备性，还需要给出数列有界的条件，试证明 \\(a_n&lt;4\\)： \\[ 1+\\frac{1}{n}&lt;\\sqrt[n]{4} \\] 在这里直接使用均值不等式方向不对，所以需要交换一下位置。 \\[ \\begin{gathered} \\frac{1}{4}&lt;\\left(\\frac{n}{n+1}\\right)^n\\\\ \\implies\\sqrt[n]{\\frac{1}{4}}= \\sqrt[n]{\\frac{1}{2}\\sdot\\frac{1}{2}\\cdot 1\\dotsm 1} &lt;\\frac{\\frac{1}{2}+\\frac{1}{2}+n-2}{n} =\\frac{n-1}{n}\\\\ =1-\\frac{1}{n}&lt;1-\\frac{1}{n+1}=\\frac{n}{n+1} \\end{gathered} \\] 这里需要拼一下根号下的乘积，应该只有这种组合可以简单地得到结论，属于技巧性操作。 由例题我们得知 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n\\) 存在，这个极限值记为 \\(e\\)： \\[\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n=e\\] 也就是著名的自然对数的底数，这一极限是 \\(e\\) 的定义式。 \\(e\\approx2.718281828\\)，小数点后九位非常有规律所以其近似值并不难记。相信大家看过一些关于 \\(e\\) 意义的精彩解读，它无疑是数学中最重要的常数之一，尤其对理工科而言，它是联系不同域的桥梁。 例：求 \\(\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n\\) 解：观察通项形式，思路应该是通过四则运算将其分解为重要极限。 \\[ \\begin{aligned} \\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n &amp;=\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{\\frac{n+1}{2}}\\right) ^{\\frac{n+1}{2}\\cdot 2-1}\\\\ &amp;=\\lim\\limits_{n\\to\\infty}\\left[\\left(1+\\frac{1}{\\frac{n+1}{2}}\\right) ^\\frac{n+1}{2}\\right]^2\\left(1+\\frac{2}{n+1}\\right)^{-1} \\end{aligned} \\] 注意每一项的极限都存在，因此 \\[ \\lim\\limits_{n\\to\\infty}\\left(1+\\frac{2}{n+1}\\right)^n=e^2 \\] 函数的极限 趋于无穷：\\(\\epsilon-X\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to+\\infty}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist X&gt;0,\\ \\forall x&gt;X\\implies |f(x)-A|&lt;\\epsilon \\end{array} \\] \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to-\\infty}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist X&gt;0,\\ \\forall x&lt;-X\\implies |f(x)-A|&lt;\\epsilon \\end{array} \\] 趋于有限值：\\(\\epsilon-\\delta\\) 定义 \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } 0&lt;|x-x_0|&lt;\\delta \\end{array} \\] 注意：函数极限存在与否与函数在 \\(x_0\\) 点是否有定义没有关系，\\(x\\) 落在 \\(x_0\\) 的去心邻域中。 单侧极限： 左极限： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0^-}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } x_0-\\delta&lt;x&lt;x_0 \\end{array} \\] 右极限： \\[ \\def\\arraystretch{1.5} \\begin{array}{c} \\lim\\limits_{x\\to x_0^+}f(x)=A \\iff \\\\ \\forall\\epsilon&gt;0,\\ \\exist \\delta&gt;0, \\ |f(x)-A|&lt;\\epsilon\\text{ if } x_0&lt;x&lt;x_0+\\delta \\end{array} \\] 函数极限的性质 极限存在定理 \\[ \\def\\arraystretch{1.5} \\begin{array}{l} \\lim\\limits_{x\\to x_0}f(x)=A \\iff\\\\ \\lim\\limits_{x\\to x_0^-}f(x) =\\lim\\limits_{x\\to x_0^+}f(x) =A \\end{array} \\] 左右极限存在且相等 \\(\\iff\\) 函数极限存在 四则运算 有关不定式的情况请参考Post not found: Note/Advanced-Mathematics/不定式 这里。","link":"/2020/note/Advanced-Mathematics/%E6%95%B0%E5%88%97%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E9%99%90/"},{"title":"高等数学目录","text":"简介 第一章：初等函数 1.3,4：Post not found: Note/Advanced-Mathematics/数列和函数的极限 WIP","link":"/2020/note/Advanced-Mathematics/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E7%9B%AE%E5%BD%95/"},{"title":"A bite of AiP &amp; MLAO","text":"Antenna-in-Package (AiP) Overview reference: Zhang, Y. and J. Mao (2019). \"An Overview of the Development of Antenna-in-Package Technology for Highly Integrated Wireless Devices.\" Proceedings of the IEEE 107(11): 2265-2280. Motivations Next generations of wireless communications: mmWave frequencies and multiple antennas for beamforming and tracking; Automotive radar: mmWave with a wide bandwidth allows for high spatial resolution for collision avoidance and vision enhancement in self-driving[1]. Development of Integrated Antennas Prerequisite: Single-die wireless transceiver DSP and CMOS technologies enabled the full integration of an entire wireless transceiver into a single die. Chip antenna technology was developed to provide a compatible antenna solution, while the interconnections between the transceiver and the chip antenna introduce a transmission loss, causing serious problems for higher frequencies. Integration solutions: AoC vs AiP Integrated antennas were attempted. Antenna-on-Chip (AoC) realizes an antenna or antennas with the transceiver in a die on the same wafer, suitable for terahertz applications. Antenna-in-Package (Aip) implements an antenna or antennas with the transceiver die into a standard SMT package. AiP Design Considerations Fundamental antenna characteristics as well as package-specific characteristics: Wavelength, bandwidth &amp; dimension considerations; Basic antenna types: dipole, loop, slot, etc; AiP arrangement: Patch, Yagi-Uda, Grid array, etc; Custom solution specially for developed for AiP: horn antenna by Tajima et al. The basic antennas were used for the proof of the concept, the unusual antennas for specific designs, and the popular antennas for general radios and radars[1:1]. Parasitic effects: leaded and leadless; Package types: BGA, QFN, etc; Interconnection pad configurations: ground-signal-ground (GSG) and GSG-signal-ground (GSGSG); Trace: coplanar waveguide (CPW), strip, and microstrip lines; Fabrication technologies: low temperature co-fired ceramic (LTCC), high density interconnection (HDI), fan-out wafer level packaging (FOWLP), etc. Machine Learning Assisted Optimization (MLAO) Overview reference: Wuf, Q., et al. (2020). \"Machine-learning-assisted optimization and its application to antenna designs: Opportunities and challenges.\" China Communications 17(4): 152-164. Motivation Full-wave electromagnetic simulation provides great accuracy while being resource demanding and time consuming; Modern wireless communication systems gave higher antenna performance requirements; MLAO has been introduced to accelerate the design process of antennas and arrays[2]. In modern wireless communication systems, the antenna is designed and considered not as a separate component but as a system-level task that must integrate with other components, structures, or even appearance designs for commercial devices[2:1]. Available methods Irregular geometries leads to analytically incalculable solutions. Numerical methods were introduced to analyze complex configurations: Integral equation solvers: discrete dipole approximation, method of moments element method, fast multipole method, plane wave time-domain, partial element equivalent circuit method, etc; Differential equation solvers: finite-difference time-domain method, discontinuous time-domain method, multiresolution time-domain method, finite element method, finite integration technique, etc; Other methods: eigenmode expansion, physical optics, uniform theory of diffraction. Machine learning approaches: Artificial neural networks, support vector machine, gaussian process regression, etc. Optimization considerations Multi-objective, variable-fidelity, parallel computing and sensitivity analysis. Opportunities Hybrid surrogate models: data-driven and physical-driven methods. Work in Progress Zhang, Y. and J. Mao (2019). &quot;An Overview of the Development of Antenna-in-Package Technology for Highly Integrated Wireless Devices.&quot; Proceedings of the IEEE 107(11): 2265-2280. ↩︎ ↩︎ Wu, Q., et al. (2020). &quot;Machine-learning-assisted optimization and its application to antenna designs: Opportunities and challenges.&quot; China Communications 17(4): 152-164. ↩︎ ↩︎","link":"/2021/note/Antenna/A-bite-of-AiP-MLAO/"},{"title":"An Efficient Surrogate Assisted Particle Swarm Optimization for Antenna Synthesis","text":"The content was summarized from K. Fu, X. Cai, B. Yuan, Y. Yang, and X. Yao, &quot;An Efficient Surrogate Assisted Particle Swarm Optimization for Antenna Synthesis,&quot; IEEE Antennas and Propagation Magazine, 2021. Motivation[1] Problem Formulation of Antenna Optimization The common EM optimization for the microwave component design is geometry optimization, adjusting the geometric parameters of a given topological antenna structure inside the range of desired operating frequencies to achieve optimal performance: To minimize \\(f(\\bm{x})\\), given that \\(g_i(\\bm{x})\\leqslant0,i=1,2,\\ldots,k,\\bm{x}\\in[\\bm{lb}, \\bm{ub}]^D\\) where \\(\\bm{x}=[x_1, x_2, \\ldots, x_D]\\) represents the geometrical variables of a fixed antenna structure, \\(D\\) is the problem dimension, \\(k\\) is the number od constrains. \\(\\bm{lb}\\) and \\(\\bm{ub}\\) are the lower and upper bounds of the design space. \\(f(\\bm{x})\\) and \\(g_i(\\bm{x})\\) represent the major performance metric and subordinate performance metrics respectively. In EM geometry optimization, the geometrical change of the EM structure is defined completely by the changes in the values of a given set of geometrical parameters. The second type of EM optimization is EM shape optimization, where the EM structure is optimized by modifying the geometrical boundary of objects in the design space. EM shape optimization allows optimal EM structures with unrestricted shapes in the design space. In EM shape optimization, the topology of the EM structure, e.g., the number of holes in the design space, is fixed in the optimization process. The third type of EM optimization is EM topology optimization. It is a numerical optimization method to find the optimal shape and topology of the EM structure by repetitively adding or eliminating geometrical/material elements within the design space. EM topology optimization can search for the optimal EM structure without constraints of shape and topology in the design space[2]. Requirements Optimization: to find to optimum design parameters; Sensitivity Analysis: to explore the design performance when parameters are varying. Solution Evolutionary Algorithm (EA) Evolutionary algorithm is a generic population-based metaheuristic optimization algorithm, ideally making no assumption about the underlying fitness landscape. This is a heuristic solution because we can never prove the real global optimal solution can be found and it is usually not. However, we often find that the solution found by PSO is quite close to the global optimal. Steps: Randomly generate the initial population of individuals; Repeat until termination: Evaluate the fitness of each individual in the population; Select parents: the fittest individuals; Breed new individuals with crossover and mutation; Replace the least-fit individuals of the population with new individuals. Types: Genetic algorithm (GA): One seeks the solution of a problem in the form of strings of numbers, by applying operators such as recombination and mutation; Differential evolution (DE): Based on vector differences and is therefore primarily suited for numerical optimization problems. Particle swarm optimization (PSO): Only the objective function is needed and it is not dependent on the gradient or any differential form of the objective. Limitations The computational budget of EA-based antenna synthesis is usually high because of various exact function evaluations are required at each iteration and hundreds of iterations are needed for a global optimal solution. Surrogate Assisted Evolutionary Algorithms (SAEAs) Surrogate Modeling Accurately approximate the simulation output by constructing statistical model (or surrogate model). Characteristics Surrogate modeling is a special case of supervised machine learning applied in the field of engineering design. Its training data is obtained via probing the simulation outputs at several intelligently selected locations in the design parameter space. At each of these locations, a full simulation is conducted to calculate the corresponding simulation output.[3] Steps[4] Sampling: generating initial training data by selecting samples of the design parameters from their parameter space, preferably to have samples that are spread evenly across the parameter space. Output evaluations: run the simulations for each sample, resulting the initial training dataset; Construct the surrogate model: usually by utilizing established machine learning algorithms; Active learning: enrich the training dataset as the training progresses by crafting learning functions to allocate samples to regions where the model is thought to be inaccurate or uncertain, or to regions of interests. Enrich training dataset: Perform new simulations runs to retrain the model. Models Online, data-driven mode 👆. Radial basis function (RBF) network: RBF networks are selected as the principal surrogate models for accurately predicting the responses of untried antenna structures, because RBF has been proved to be remarkable accuracy for high-dimensional problems. The metamodels are initially trained based on a dataset consisting of \\(n\\) distinct vectors, \\(\\bm{x}_1\\), \\(\\bm{x}_2\\), \\(\\ldots\\), \\(\\bm{x}_n\\in\\Reals^D\\), and each vector \\(\\bm{x}_i\\) represents a solution of the geometrical parameters for the given antenna structure, \\(f(\\bm{x}_i)\\in\\Reals\\) is the corresponding performance metric, which is computed by exact EM simulations. The predicted performance metric of an undetermined vector \\(\\bm{x}_{n+1}\\) can be approximated by \\[ \\hat{f}(\\bm{x}_ {n+1})=\\sum^n_{i=1}\\lambda_i\\Phi_i\\left(||\\bm{x} _{n+1}-\\bm{x} _i||\\right)+p(\\bm{x} _{n+1}) \\tag{1} \\] where \\(\\Phi_i\\) is \\(i\\)th basis function, and \\(||\\cdot||\\) indicates the Euclidean distance, and \\(p(\\bm{x})=\\bm{b}^T\\bm{x}+a\\) is a linear polynomial function. Simplified Kriging model Particle Swarm Optimization (PSO) Particle Swarm Optimization was proposed by Kennedy and Eberhart in 1995[5]. As mentioned in the original paper, sociobiologists believe a school of fish or a flock of birds that moves in a group &quot;can profit from the experience of all other members&quot;. While we can simulate the movement of a flock of birds, we can also imagine each bird is to help us find the optimal solution in a high-dimensional solution space and the best solution found by the flock is the best solution in the space[6]. Assume we have \\(P\\) particles and the position of particle \\(i\\) at iteration \\(t\\) is \\(X^i(t)\\). Besides the position, we have the a velocity for each particle \\(V^i(t)\\). At the next iteration, the position of each particle would be updated as \\[X^i(t+1)=X^i(t)+V^i(t+1)\\tag{2}\\] and the velocities are updated by the rule \\[V^i(t+1)=wV^i(t)+c_1r_1(p^i(t)-X^i(t))+c_2r_2(p^g(t)-X^i(t))\\tag{3}\\] where \\(c_1\\) and \\(c_2\\) are acceleration coefficients, \\(r_1\\) and \\(r_2\\) are random values in the range of \\([0,1]\\), \\(p^g(t)\\) represents the global best position of the swarm and \\(p^i(t)\\) represents the historical best position of particle \\(i\\) found until iteration \\(t\\). The iteration terminates if the maximum number of iterations is reached, \\(p^g(t)\\) and \\(p^i(t)\\) are updated according the exact function evaluations for all the particles. The result is the global best position \\(p^g\\), revealing the optimal parameters of the given antenna structure. Implementation Details An introduction to Surrogate modeling. ↩︎ J. Jin, F. Feng, J. Zhang, J. Ma, and Q.-J. Zhang, &quot;Efficient EM Topology Optimization Incorporating Advanced Matrix Padé Via Lanczos and Genetic Algorithm for Microwave Design,&quot; IEEE Transactions on Microwave Theory and Techniques, vol. 69, no. 8, pp. 3645-3666, 2021-08-01 2021, doi: 10.1109/tmtt.2021.3088870. ↩︎ Interpretable Machine Learning: A Guide for Making Black Box Models Explainable. ↩︎ Alexander I. J. Forrester, András Sóbester, Andy J. Keane, Engineering Design via Surrogate Modelling: A Practical Guide, 2008. ↩︎ J. Kennedy and R. Eberhart, &quot;Particle swarm optimization,&quot; Proceedings of ICNN'95 - International Conference on Neural Networks, 1995, pp. 1942-1948 vol.4, doi: 10.1109/ICNN.1995.488968. ↩︎ A Gentle Introduction to Particle Swarm Optimization ↩︎","link":"/2021/note/Antenna/An-Efficient-Surrogate-Assisted-Particle-Swarm-Optimization-for-Antenna-Synthesis/"},{"title":"Designing Filtering DRA","text":"Reference: X. Liu, K. W. Leung, and N. Yang, &quot;Frequency Reconfigurable Filtering Dielectric Resonator Antenna With Harmonics Suppression,&quot; IEEE Transactions on Antennas and Propagation, vol. 69, no. 6, pp. 3224-3233, 2021-06-01 2021, doi: 10.1109/tap.2020.3044387. Filtering Antenna Types Cascading a filtering circuit Mode-cancelling method Leveraging the advantages of DRA High efficiency Low cost High degree of design flexibility Basic Filtering DRA Design Slots: can be used to tune the passband and radiation nulls of the filtering antenna SLot I can improve passband matching and stopband supression Slot II resonates in its higher order mode Slot III excites the fundamental \\(\\rm{TE}^y_{1\\delta 1}\\) DRA mode Feedline: divided into three parts for matching the antenna","link":"/2022/note/Antenna/Designing-Filtering-DRA/"},{"title":"Dielectric Resonator Antenna","text":"Wikipedia: Dielectric Resonator Antenna David R. Jackson and Stuart A. Long History of Microscript and Dielectric Resonator Antennas 2020 14th European Conference on Antennas and Propagation (EuCAP) Dielectric resonator antenna is based on a resonator, which intentionally &quot;leaks&quot; or radiates power to act as an antenna. Kwok Wa Leung, Eng Hock Lim, and Xiao Sheng Fang Dielectric Resonator Antennas: From the Basic to the Aesthetic Proceedings of the IEEE, 2012","link":"/2022/note/Antenna/Dielectric-Resonator-Antenna/"},{"title":"ESPSO with HFSS","text":"Procedure Initialization: Model parameters: DR width, length, height, permittivity; slot width, length; feed line length, width Build database: Evaluate data","link":"/2021/note/Antenna/ESPSO-with-HFSS/"},{"title":"Space Mapping","text":"Space mapping (SM) is a recognized method for speeding up electromagnetic (EM) optimization. This paper[1] proposes a nre coarse- and fine-mesh SM technique for EM optimization incorporating mesh deformation. By incorporating mesh deformation into coarse-mesh EM optimization, the coarse-mesh EM responses change continuously as the values of the geometrical design variables change. Intro The circuit-theoretic models are simple and efficient, but lack the necessary accuracy or have limited validity range. The field-theoretic models are more complex and CPU intensive but can be significantly more accurate. The field-theoretic models are applicable to general geometries. Space mapping explores a mathematical link between the discrete coarse and the discrete fine EM field models. The coarse model allows us to explore different optimization starting points, solution robustness, local minima, parameter sensitivities and statistics, and other design characteristics within a practical time frame[2]. Theory Consider an optimization problem for a given set of design specifications. The behavior of the system may be described by two distinct models, namely, a coarse model and a fine model. Let us define an \\(l\\)-dimensional vector of fine model parameters as \\[ \\phi_f=[\\phi_{f1}\\phi_{f2}\\ldots\\phi_{fl}]^T \\tag{1} \\] and \\(k\\)-dimensional vector of coarse model parameters as \\[ \\phi_c=[\\phi_{c1}\\phi_{c2}\\ldots\\phi_{ck}]^T \\text{.} \\tag{2} \\] Also, let \\(R_f(\\phi_f)\\) and \\(R_c(\\phi_c)\\) denote the fine and coarse model responses at \\(\\phi_f\\) and \\(\\phi_c\\) respectively. The key idea behind the SM optimization technique is the generation of an appropriate transformation \\[ \\phi_c=\\operatorname{P}(\\phi_f) \\tag{3} \\] mapping the fine model parameter space to the coarse model parameter space such that \\[ ||\\operatorname{R}_f(\\phi_f)-\\operatorname{R}_c(\\phi_c)|| \\leqslant \\epsilon \\tag{4} \\] within some local modeling region around the optimal coarse model solution \\(\\phi_c^*\\), where \\(||\\cdot||\\) indicates a suitable norm and \\(\\epsilon\\) is the error. It's desirable that \\(\\operatorname{P}\\) is invertible, the inverses transformation \\[ \\overline{\\phi_f}=\\operatorname{P}^{-1}(\\phi_c^*) \\tag{5} \\] is used to find the fine model solution \\(\\overline{\\phi_f}\\) which is the image of \\(\\phi^*_c\\) subject to \\((4)\\). Process[2:1] Finding \\(\\operatorname{P}\\) is a iterative process. Begin with a set of fine model base points \\(\\mathbf{B}_f={\\phi_f^1,\\phi_f^2,\\ldots,\\phi_f^m}\\). The initial \\(m\\) base points are selected in the vicinity of a reasonable candidate for the fine model solution. Define each of the transformation \\(\\operatorname{P}_j\\) as a linear combination fo some predefined and fixed fundamental functions \\[ \\phi_{c} = \\sum^n_{s=1}a_sf_s{\\phi_f}=\\operatorname{P}j(\\phi_f)=\\mathbf{A}{j}f(\\phi_f) \\tag{6} \\] or for all points, in matrix form \\[ \\mathbf{WDA}^T_j=\\mathbf{WC} \\tag{7} \\] where \\[ \\mathbf{C} = [\\phi_c^1\\phi_c^2\\ldots\\phi_c^{m_j}]^T \\tag{8} \\] \\[ \\mathbf{D} = [f(\\phi_f^1)f(\\phi_f^2)\\ldots f(\\phi_f^{m_j})]^T \\tag{9} \\] and a weighting factor diagonal matrix \\(\\mathbf{W}\\). The least-square solution to this system is \\[ \\mathbf{A}^T_j=(\\mathbf{D}^T\\mathbf{W}^T\\mathbf{WD})^{-1}\\mathbf{D}^T\\mathbf{W}^T\\mathbf{WC} \\text{.} \\tag{10} \\] Coarse- and Fine-Mesh SM Optimization Incorporating Mesh Deformation Let \\(\\bm{d}^j_i\\) represent the 3-D coordinates of the \\(i\\)-th mesh node after mesh deformation in the \\(j\\)-th SM iteration. The 3-D coordinates \\(\\bm{d}^j_i\\) as functions of coarse-model geometrical variable \\(\\phi_c\\) using a triharmonic RBF method are formulated as \\[ \\bm{d}^j_i(\\phi_c)= \\sum^{n_b}_ {k=1}\\bm{p}^j_k(\\phi_c)\\sigma_k(\\overline{\\bm{d}^j_i}) +\\sum^4_ {l=1}\\bm{q}^j_l(\\phi_c)\\pi_l(\\overline{\\bm{d}^j_i}) \\tag{11} \\] Let \\(\\bm{K}\\) represents the system matrix for solving the coarse-mesh EM response using FEM, \\(R^j_c\\) represent the coarse-mesh EM response incorporating the mesh deformation corresponding to \\(\\phi_c\\) in the \\(j\\)-th Sm iteration, formulated as \\[ R^j_c(\\phi_c)=\\bm{c}^T[\\bm{K}(\\bm{D^j(\\phi_c)})]^{-1}\\bm{b} \\tag{12} \\] Define a surrogate model that combines the coarse model with the mapping function, formulated as \\[ R^j_s(\\phi,w)=\\bm{c}^T[\\bm{K}(\\bm{D^j(f(\\phi,w))})]^{-1}\\bm{b} \\tag{13} \\] F. Feng, J. Zhang, W. Zhang, Z. Zhao, J. Jin, and Q.-J. Zhang, &quot;Coarse- and Fine-Mesh Space Mapping for EM Optimization Incorporating Mesh Deformation,&quot; IEEE Microwave and Wireless Components Letters, vol. 29, no. 8, pp. 510-512, 2019-08-01 2019, doi: 10.1109/lmwc.2019.2927113. ↩︎ J. W. Bandler, R. M. Biernacki, Shao Hua Chen, P. A. Grobelny and R. H. Hemmers, &quot;Space mapping technique for electromagnetic optimization,&quot; in IEEE Transactions on Microwave Theory and Techniques, vol. 42, no. 12, pp. 2536-2544, Dec. 1994, doi: 10.1109/22.339794. ↩︎ ↩︎","link":"/2021/note/Antenna/Space-Mapping/"},{"title":"Towards Physics-Based Model for Antenna Synthesis","text":"Discuss around feeding more information about the antenna structure to our learning model. Motivation Modifying the radiation structure to achieve the radiation null both at the upper and lower band edges Although the fusion method can give a good filtering response, the overall design more relies on the designers’ experiences, and thus a trial-and-error process becomes inevitable. [1] The limitations of some optimization methods The antenna shape is continuously adjusted to meet the optimization goal The objective functions are expressed in terms of the antenna parameters However, little physical understanding for the antenna design is gained according to the quantitative observations about the antenna parameter based objective functions. What could characteristic mode theory (CMT) do The CMT based analysis can provide insight to the underlying physics of the radiation and scattering problems Independent of the feeding structures, the CMT can present the inherent properties of the object by solving the generalized eigenvalue problem including characteristic values, characteristic currents and characteristic fields, etc. The shape optimization methods based on CMT have been explored for various antenna designs Work done by the paper: A CMT based topology optimization method for filtering antenna design. Characteristic Mode Analysis Developed by Garbacz[2][3], generalized by Harrington and Mautz[4], as well as a more viable computational approach[5]. Characteristic Current Consider one or more conducting bodies defined by the surface \\(S\\). The scattering of an electromagnetic wave on them is represented via a boundary condition: \\[ \\begin{equation} \\hat{\\bm{n}}\\times(\\bm{E}^s+\\bm{E}^i)=0 \\end{equation} \\] where \\(\\hat{\\bm{n}}\\) is the unitary normal to \\(S\\), \\(\\bm{E}^i\\) represents the incident electric field intensity, and \\(\\bm{E}^s\\) is the scattered electric field intensity. The scattered electric field is defined as \\[ \\begin{equation} \\bm{E}^s=-j\\omega\\bm{A}-\\nabla\\varphi \\end{equation} \\] where \\(\\bm{A}\\) is the vector potential \\[ \\begin{equation} \\bm{A}(\\bm{r})=\\mu_0\\underset{S}{\\oiint}\\bm{J} (\\bm{r'}) G(\\bm{r},\\bm{r'}) \\operatorname{d}s' \\end{equation} \\] \\(\\varphi\\) is the scalar potential \\[ \\begin{equation} \\varphi(\\bm{r})=\\frac{1}{j\\omega\\epsilon_0}\\underset{S}{\\oiint}\\nabla\\cdot\\bm{J}(\\bm{r'})G(\\bm{r},\\bm{r'})\\operatorname{d}s' \\end{equation} \\] \\(G(\\bm{r},\\bm{r'})\\) is the scala Green's function \\[ \\begin{equation} G(\\bm{r},\\bm{r'})=\\frac{e^{-jk|\\bm{r}-\\bm{r'}|}}{4\\pi|\\bm{r}-\\bm{r'}|} \\end{equation} \\] \\(\\bm{r}\\) denotes a field point, \\(\\bm{r'}\\) denotes a source point, and \\(\\mu_0\\), \\(\\epsilon_0\\), and \\(k\\) is the permeability, permittivity, and wavenumber of free space respectively. Define the symmetric product of two vector functions \\(\\bm{B}\\) and \\(\\bm{C}\\) on \\(S\\) as \\[ \\begin{equation} \\lang B,C\\rang=\\underset{S}{\\oiint}\\bm{B}\\cdot\\bm{C}\\operatorname{d}s \\end{equation} \\] The product \\(\\lang B^*,C\\rang\\), where the asterisk denotes complex conjugate, defines an inner product for the complex Hilbert space of all square-integrable vector functions on \\(S\\). Rewrite \\((2)\\) as an operator \\[ \\begin{equation} \\bm{E} = \\operatorname{L}(\\bm{J}) = j\\omega\\bm{A}(\\bm{J}) + \\nabla\\varphi(\\bm{J}) \\end{equation} \\] The operator \\(\\operatorname{L}\\) has the dimensions of impedance, we introduce the notation: \\[ \\begin{equation} Z(J) = \\hat{\\bm{n}} \\times \\operatorname{L}(\\bm{J}) \\end{equation} \\] \\(Z\\) is a symmetric operator, i.e., \\(\\lang B,ZC\\rang=\\lang ZB,C\\rang\\), but not a Hermitian operator, i.e., \\(\\lang B^* ,ZC\\rang\\ne\\lang Z^* B^*,C\\rang\\). The impedance operator \\(Z\\) can be written as \\[ \\begin{equation} Z = R + jX \\end{equation} \\] where \\(R\\) and \\(X\\) are real symmetric operators since \\(Z\\) is symmetric: \\[ \\begin{equation} R = \\frac{1}{2}(Z+Z^* ) \\end{equation} \\] \\[ \\begin{equation} X = \\frac{1}{2j}(Z-Z^* ) \\end{equation} \\] Furthermore, \\(R\\) is positive semidefinite since the power radiated by a current \\(\\bm{J}\\) on \\(S\\) is \\(\\lang \\bm{J}^*,R\\bm{J}\\rang\\geqslant 0\\). If no resonator fields exist internal to \\(S\\), then \\(R\\) is positive definite. Next, consider the eigenvalue equation: \\[ \\begin{equation} Z(\\bm{J}_n) = \\nu_nM(\\bm{J}_n) \\end{equation} \\] where \\(\\nu_n\\) are eigenvalues, \\(\\bm{J}_n\\) are eigenfunctions, and \\(M\\) is a weight operator to be chosen. The eigenfunctions for any choice of symmetric \\(M\\) will diagonalize \\(Z\\), but only the choice \\(M=R\\) also gives orthogonality of the radiation patterns. Hence \\[ \\begin{equation} Z(\\bm{J}_n) = (R+jX)(\\bm{J}_n) = \\nu_nR(\\bm{J}_n) \\end{equation} \\] Let \\[ \\begin{equation} \\nu_n = 1 + j\\lambda_n \\end{equation} \\] and substitute \\(\\nu_n\\) in \\((13)\\), obtaining \\[ \\begin{equation} X(\\bm{J}_n) = \\lambda_nR(\\bm{J}_n) \\end{equation} \\] Both \\(R\\) and \\(X\\) are symmetric operators, all eigenvalues \\(\\lambda_n\\) and eigenfunctions \\(\\bm{J}_n\\) must be real. \\(\\bm{J}_n\\) and their inner products also satisfy the orthogonality relationships. The choice of \\({\\bm{J}_n}\\) as basis functions therefore simultaneously leads to diagonal matrix representations of \\(R\\), \\(X\\), and \\(Z\\). These \\(\\bm{J}_n\\) are called characteristic currents or eigencurrents of the conducting body defined by \\(S\\). Filtering Response Mechanism Filtering Properties The gain of a conventional microstrip antenna \\(G\\) depends on the matching characteristic (the reflection coefficient \\(|\\rm{S}_{11}|\\)) the radiation performance (the maximum directivity \\(D\\) and the radiation efficiency \\(\\eta_{radiation}\\)) To generate radiation nulls: Reducing out-of-band reflection efficiency (\\(\\eta_{match}=1-|\\rm{S}_{11}|^2\\)) Reducing out-of-band radiation performance (\\(D\\) or \\(\\eta _{radiation}\\)) Refer to \\((15)\\), using the orthogonal property of \\(\\bm{J}_ n\\) to expand the equivalent surface current of the antenna \\(\\bm{J}\\): \\[ \\begin{equation} \\bm{J}=\\sum_ {n}\\alpha_ n\\bm{J}_ n=\\sum_ {n}\\frac{\\left\\lang\\bm{E^i_ {\\rm{tan}}},\\bm{J}_ n\\right\\rang}{1+j\\lambda_ n}\\bm{J}_ n \\end{equation} \\] where \\(\\alpha_ n\\) is mode weighting coefficient (MWC) and \\(\\bm{E}^i_ {\\rm{tan}}\\) is excitation of the antenna. The denominator of the MWC is related to the modal significance (MS): \\[ \\begin{equation} \\text{MS}=\\frac{1}{|1+j\\lambda_ n|} \\end{equation} \\] The mode \\(n\\) resonates when its MS equals 1. The radiation field \\(\\bm{E}\\) can be expanded in terms of the characteristic field \\(\\bm{E}_ n\\) radiated by the \\(\\bm{J}_ n\\): \\[ \\begin{equation} \\bm{E}=\\sum_ {n}\\alpha_ n\\bm{E}_ n=\\sum_ {n}\\frac{\\left\\lang\\bm{E^i_ {\\rm{tan}}},\\bm{J}_ n\\right\\rang}{1+j\\lambda_ n}\\bm{E}_ n \\end{equation} \\] in which the term \\(\\left\\lang\\bm{E^i_ {\\rm{tan}}},\\bm{J}_ n\\right\\rang\\) depends on the excitation is related to the \\(\\eta_ {match}\\), and the term \\(\\bm{E}_ n\\) is related to the \\(D\\). Two methods of generating the radiation null: \\(\\bm{E}_ n=\\bm{0}\\) \\(\\left\\lang\\bm{E^i_ {\\rm{tan}}},\\bm{J}_ n\\right\\rang=0\\) Optimization Schemes Multi-objective optimization \\[ \\begin{equation} \\begin{array}{l} \\text{minimize/maximize}\\quad f_j(x),\\ j=1,2,\\ldots,J \\\\ \\text{subject to}\\quad g_k(x)\\geqslant0,\\ k=1,2,\\ldots,K \\\\ \\text{and}\\quad h_l(x)=0,\\ l=1,2,\\ldots,L \\\\ \\mathbf{x}=(x_1,x_2,\\ldots,x_n)^T,\\ \\mathbf{x}\\in\\mathbf{\\Omega} \\end{array} \\end{equation} \\] NSGA-II Domination A solution \\(\\mathbf{x}^{(1)}\\) is said to dominate the other solution \\(\\mathbf{x}^{(2)}\\) if both condition 1 and 2 below are true: \\(\\mathbf{x}^{(1)}\\) is no worse than \\(\\mathbf{x}^{(2)}\\) for all objectives \\(\\mathbf{x}^{(1)}\\) is strictly better than \\(\\mathbf{x}^{(2)}\\) in at least one objective The notation for \\(\\mathbf{x}^{(1)}\\) dominates \\(\\mathbf{x}^{(2)}\\) is: \\[ \\mathbf{x}^{(1)}\\preceq\\mathbf{x}^{(2)} \\] L. Ke and S. Yan, “Filtering Antenna Synthesis Based on Characteristic Mode Theory [Unpublished manuscript],” IEEE Trans. Antennas Propag., Sept. 2021. ↩︎ R. J. Garbacz, &quot;Modal expansions for resonance scattering phenomena,&quot; Proceedings of the IEEE, vol. 53, no. 8, pp. 856-864, 1965. ↩︎ R. Garbacz and R. Turpin, &quot;A generalized expansion for radiated and scattered fields,&quot; IEEE Trans. Antennas Propag., vol. 19, no. 3, pp. 348-358, 1971. ↩︎ R. Harrington and J. Mautz, &quot;Theory of characteristic modes for conducting bodies,&quot; IEEE Trans. Antennas Propag., vol. 19, no. 5, pp. 622-628, 1971. ↩︎ R. Harrington and J. Mautz, &quot;Computation of characteristic modes for conducting bodies,&quot; IEEE Trans. Antennas Propag., vol. 19, no. 5, pp. 629-639, 1971. ↩︎","link":"/2021/note/Antenna/Towards-Physics-Based-Model-for-Antenna-Synthesis/"},{"title":"C# Cheat Sheet","text":"C# (pronounced &quot;see sharp&quot;) is a modern, object-oriented, and type-safe programming language. C# features: Object-oriented Garbage collection: Automatically reclaims memory occupied by unreachable unused objects. Nullable types: guard against variables that don't refer to allocated objects. Exception handling: provides a structural and extensible approach to error detection and recovery. Lambda expressions: support functional programming techniques. Language integrated query (LINQ): a syntax that creates a common pattern for working with data from any sources. Asynchronous operations: provides syntax for building distributed systems. Unified type system: all types including primitive types inherit from a single root object type. Dynamic allocation of objects In-line storage of lightweight structure Generic methods and types Iterators C# programs run on .NET, a virtual execution system that called the common language runtime (CLR) and a set of class libraries. The CLR is the implementation by Microsoft of the common language infrastructure (CLI), an international standard. The CLI is the basis for creating execution and development environments in which languages and libraries work together seamlessly. Source code written in C# is compiled into an intermediate language (IL) that conforms to the CLI specification. The IL code and resource are stored in an assembly, typically with an extension of .dll. An assembly contains a manifest that provides information about the assembly's types, version and cultures. When the C# program is executed, the assembly is loaded into the CLR. The CLR performs Just-In-Time (JIT) compilation to convert the IL code to native machine instructions. Code that's executed by the CLR is sometimes referred to as &quot;managed code&quot;. &quot;Unmanaged code&quot; is compiled into native machine language that targets a specific platform. C# Hello World 1234567using System;class Hello { static void Main() { Console.WriteLine(&quot;Hello, World!&quot;); }} Types and Variables Value types Simple types Signed integral: sbyte, short, int, long Unsigned integral: byte, short, int, ulong Unicode characters: char, which represents a UTF-16 code unit IEEE binary floating-point: float, double High-precision decimal floating-point: decimal Boolean: bool, which represents Boolean values - values that are either true or false Enum types: User defined types of the form enum E {...}. An enum type is a distinct type with named constants. Every enum type has an underlying type, which must be one of the eight integral types. Struct types: User defined types of the form struct S {...} Nullable value types Extensions of all other types with a null value Tuple value types User-defined types of the form (T1, T2, ...) Reference types class types Ultimate base class of all other types: object Unicode strings: string, which represents a sequence of UTF-16 code units User-defined types of the form class C {...} Interface types User-defined types of the form interface I {...} Array types Single-dimensional, multi-dimensional, and jagged. For example: int[], int[,], and int[][] Delegate types User defined types of the form delegate int D {...} C# keyword int is an alias of the .NET Class Library type System.Int32. decimal has more precision than float and double while consuming more memory. m or M : literal suffix. String Formatting String concatenation 1string str = &quot;There are &quot; + 12 + &quot; apples.&quot;; // There are 12 apples. String interpolation 123string name = &quot;Speed&quot;;string value = &quot;120&quot;;string message = $&quot;{name}: {value}&quot;; // Speed: 120 String interpolation can be combined with verbatim literal. String interpolation symbol $ should be placed before verbatim literal prefix symbol @. 12string projectName = &quot;C#-Cheat-Sheet&quot;;string path = $@&quot;C:\\Output\\{projectName}\\Data&quot;; // C:\\Output\\C#-Cheat-Sheet\\Data Mathematical Operation Basic operation Decimal type 1decimal quotient = 7.0m / 3; // 2.3333333333333333333333333333 Calling Methods From the .NET Class Library Creating an instance of a class 1Random dice = new Random(); Stateless method (static method) 1Console.Write(&quot;abc&quot;); Stateful method (instance method) 1dice.Next(); // Depends on system time. Execution Flow if-else statement 1234567if (condition1) { // Do sth.} else if (condition2) { // Do others.} else { // What to do.} foreach statement 1234string[] names = {&quot;Alex&quot;, &quot;Bill&quot;, &quot;Charlie&quot;};foreach (var name in names) { // Alex Console.WriteLine(name); // Bill} // Charlie Conditional operator (ternary conditional operator) 12int saleAmount = 100;int discount = saleAmount &gt; 50 ? 20 : 10; switch-case statement 1234567891011121314int dataCategory = 1;switch (dataCategory) { case 1: case 2: // Do sth. break; case 3: // Do others. break; default: // Default action. break;} for statement 123456for (int i = 0; i &lt; 10; i++) { Console.WriteLine(i); if (i == 5) { break; }} do-while statement 1234567Random random = new Random();int current = 0;do { current = random.Next(1, 11); Console.WriteLine(current);} while (current != 5); while statement 123456789101112Random random = new Random();int current = random.Next(1, 11);while (current != 5) { if (current &gt; 6) { continue; } Console.WriteLine(current); current = random.Next(1, 11);}Console.WriteLine($&quot;Last number: {current}&quot;); Data Structure Array 12string[] slogans = new string[3];string[] studentIDs = { &quot;A123&quot;, &quot;B234&quot;, &quot;C345&quot; }; Properties Length 1int len = studentIDs.Length; Scope and Namespace 123456789using System;namespace MyNewApp { class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); } }} Child-namespace 123namespace MyNewApp.Data { // Classes} Calling a method in the same class 1234567891011121314151617using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Calling a method from a different class 12345678910111213141516171819using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Utility.Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } } class Utility { public static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Referencing a class in a different namespace 123456789101112131415161718192021using System;namespace MyNewApp { class Program { static void Main(string[] args) { string value = &quot;Microsoft Learn&quot;; string reversedValue = Utilities.Utility.Reverse(value); Console.WriteLine($&quot;Secret message: {reversedValue}&quot;); } }}namespace MyNewApp.Utilities { class Utility { public static string Reverse(string message) { char[] letters = message.ToCharArray(); Array.Reverse(letters); return new string(letters); } }} Work in Progress","link":"/2021/note/C-Sharp/C-Sharp-Cheat-Sheet/"},{"title":"Basic MOS Device Physics","text":"MOS I/V Characteristics Derive the current through MOSFETs as a function of the terminal voltages. Threshold Voltage A channel of charge carriers is formed under the gate oxide between source and drain when the gate voltage \\(V_G\\) reaches a sufficiently positive value, the threshold voltage \\(V_{TH}\\). The transistor is said to be &quot;turn on&quot; and the interface is &quot;inverted&quot;. If \\(V_G\\) continues to rise, the charge in the depletion region remains relatively constant while the channel charge density increases, meaning lower resistance between source and drain. In reality, the &quot;turn-on&quot; behavior is a continuous function of the gate voltage, leaving no unambiguous \\(V_{TH}\\) out there. For practice, it can be proved that \\[ V_{TH}=\\Phi_{MS}+2\\Phi_F+\\frac{Q_{dep}}{C_{ox}} \\tag{2.1} \\] where \\(\\Phi_{MS}\\) is the difference between the work function of the polysilicon gate and the silicon substrate, \\(\\Phi_F=(kT/q)\\ln(N_{sub}/n_i)\\), \\(k\\) is Boltzmann's constant, \\(q\\) is the electron charge, \\(N_{sub}\\) is the doping density of the substrate, \\(n_i\\) is the density of electrons in undoped silicon, \\(Q_{dep}\\) is the charge in the depletion region, and \\(C_{ox}\\) is the gate-oxide capacitance per unit area. Derivation of I/V Characteristics For NMOS: Linear Region \\(V_{DS}&lt;V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=\\mu_nC_{ox}\\frac{W}{L} \\left[(V_{GS}-V_{TH})V_{DS} -\\frac{1}{2}V_{DS}^2\\right] \\tag{2.8}\\] Saturation Region \\(V_{DS}\\geqslant V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=\\frac{1}{2}\\mu_nC_{ox}\\frac{W}{L} (V_{GS}-V_{TH})^2\\tag{2.13}\\] For PMOS: Linear Region \\(V_{DS}&lt;V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=-\\mu_pC_{ox}\\frac{W}{L} \\left[(V_{GS}-V_{TH})V_{DS} -\\frac{1}{2}V_{DS}^2\\right] \\tag{2.15}\\] Saturation Region \\(V_{DS}\\geqslant V_{GS}-V_{TH},\\ V_{GS}&gt;V_{TH}\\) \\[I_{DS}=-\\frac{1}{2}\\mu_pC_{ox}\\frac{W}{L} (V_{GS}-V_{TH})^2\\tag{2.16}\\] MOS Transconductance In saturation region: \\[ \\begin{aligned} g_m&=\\left.\\frac{\\partial I_{DS}} {\\partial V_{GS}}\\right|_{\\text{VDS const.}} \\\\ &=\\mu_nC_{ox}\\frac{W}{L}(V_{GS}-V_{TH}) \\end{aligned} \\tag{2.18} \\] or: \\[ \\begin{aligned} g_m&amp;=\\sqrt{2\\mu_nC_{ox}\\frac{W}{L}I_D} \\\\ &amp;=\\frac{2I_D}{V_{GS}-V_{TH}} \\end{aligned} \\tag{2.20} \\] Second-Order Effects Body Effect When the bulk voltage of an NFET drops below the source voltage, wider depletion region is formed. As \\(V_B\\) drops and \\(Q_d\\) increases, \\(V_{TH}\\) also increases. This phenomenon is called the body effect or the back-gate effect. It can be proved that with body effect, \\[ V_{TH}=V_{TH0}+\\gamma\\left(\\sqrt{2\\Phi_F+V_{SB}}-\\sqrt{|2\\Phi_F|}\\right) \\tag{2.23} \\] where \\(V_{TH0}\\) is given by \\((2.1)\\), \\(\\gamma=\\sqrt{2q\\epsilon_{si}N_{sub}}/C_{ox}\\) denotes the body effect coefficient, and \\(V_{SB}\\) is the source-bulk voltage difference. Channel-Length Modulation The actual length of the channel gradually decreases as the potential difference between the gate and the drain decreases. In \\((2.13)\\), \\(L\\) is in fact a function of \\(V_{DS}\\). This effect is called channel-length modulation. We have, in saturation, \\[ I_{DS}\\approx\\frac{1}{2}\\mu_nC_{ox}\\frac{W}{L}(V_{GS}-V_{TH})^2 (1+\\lambda V_{DS})\\tag{2.27} \\] where \\(\\lambda\\) is the &quot;channel-length modulation coefficient&quot;. Notice that with channel-length modulation, some of the expressions derived for \\(g_m\\) must be modified. Subthreshold Conduction In reality, for \\(V_{GS}\\approx V_{TH}\\), a &quot;weak&quot; inversion layer still exists and some current flows from drain to source. Even for \\(V_{GS}&lt;V_{TH}\\), \\(I_{DS}\\) is present but it exhibits an exponential dependence on \\(V_{GS}\\). Voltage Limitations A high gate-source voltage can breaks down the gate oxide irreversibly. In short-channel devices, an excessively large drain-source voltage widens the depletion region around the drain so much that it touches that around the source, creating a very large drain current. MOS Device Models WIP","link":"/2020/note/Design-of-Analog-Integrated-Circuit/Basic-MOS-Device-Physics/"},{"title":"Homework1","text":"某公司设计的某款芯片面积为 1mm\\(\\times\\)1mm，于某 12 寸晶圆厂流片生产， 忽略划片槽占用面积，每片晶圆大概能产出多少颗芯片裸片？ 如果划片槽宽度为 100μm，每片晶圆大概能产出多少颗芯片？ 如果划片槽宽度减少为 50μm，每片晶圆大概能产出多少颗芯片？ 如果通过优化电路设计，芯片面积可以缩减至 0.8mm\\(\\times\\)0.8mm，在划片槽宽度分别为 100μm 和 50μm 时，每片晶圆大概能产出多少颗芯片？ 针对以上问题，做出相应图表并进行相关分析和论述。 关键点 12 寸晶圆的直径实际上是 300mm，从中心开始向边缘刻画芯片。因为芯片通常是矩形，并不能完全覆盖晶圆，因此需要考虑多种因素减少浪费的晶圆面积。 芯片面积 芯片面积是影响晶圆生产芯片数量的最主要因素。实现相同功能的前提下，更先进的制造技术和电路设计可以缩小芯片的面积。 20mm Die 10mm Die 145 624 观察在晶圆上分别制造边长为 20mm 和 10mm 的方形芯片的排列效果。在芯片紧密排列时，单块芯片更小的面积可以增加晶圆利用率。这可以近似为割圆为方，De Vries 博士在他的论文 Investigation of gross die per wafer formulas 中给出的近似公式之一是 \\[ DPW=\\frac{\\pi d^2}{4S}-\\frac{\\pi d}{\\sqrt{2S}} \\] 其中 \\(d\\) 指晶圆直径，\\(S\\) 指方形芯片面积。 划片槽宽度 当然芯片间需要留出划片槽 (scribe-line) 方便切割芯片，显然划片槽越宽，可用的晶圆面积越少。下面是边长 10mm 的方形芯片间分别留出 1mm 和 500μm 划片槽的效果。 1mm Scribe-line 500μm Scribe-line 537 593 考虑划片槽的存在，把芯片右侧和下侧的划片槽面积并入芯片面积计算，仍然可以使用相同的近似公式。 对齐方式 划分芯片网格的时候，中心对齐方式对排列芯片的结果有一点影响，主要有 Die Centering 和 Wafer Centering 两种方式，前者使晶圆中点对齐纵横划片槽的交点，后者使晶圆中点对齐最中心芯片的中心点。对边长 25mm、划片槽宽 1mm 的方形芯片，两种对齐方式的效果如下。 Die Centering Wafer Centering 80 89 不过芯片面积越小，对齐方式对芯片总数的影响越小，近似计算时可以忽略。 结论 现在使用近似公式估计芯片数量，为衡量估计的准确度可以写一个程序计算接近乎精确的结果，我修改了一个 Javascript 计算器让其能够给出题目条件下的芯片数量，同时还可以生成图形以直观地观察芯片的排列，本文中所有的图片都是该程序生成的。 近似计算 近似公式中 \\(d\\) = 300mm，设芯片边长为 \\(a\\)，则 \\(S_0=a^2\\)。设划片槽宽度为 \\(t\\)，可考虑 \\(S_1=(a+t)^2\\)。将题目中的各种情况带入近似公式得到结果如下： 1mm Die 0.8mm Die 100μm Scribe-line 57812 86525 50μm Scribe-line 63479 97051 No Scribe-line 70019 109614 精确计算 程序计算的结果如下，布局使用 Wafer Centering： 1mm Die 0.8mm Die 100μm Scribe-line 57928 86668 50μm Scribe-line 63561 97192 No Scribe-line 70089 109712 1mm\\(\\times\\)1mm 芯片、100μm 划片槽和 0.8mm\\(\\times\\)0.8mm 芯片、50μm 划片槽两种组合的布局示例如图。 似乎近似计算的结果总是略小于精确值，但相对误差不超过 2‰，这对估算而言已经足够好用。","link":"/2020/note/Design-of-Analog-Integrated-Circuit/Homework1/"},{"title":"模拟集成电路设计目录","text":"Introduction We are back to analog design again! It is said that we are living in a digital world. Most of the devices that we used everyday have a digital processor inside. So what's the point of learning analog design? Although from the perspective of quantum mechanics, the basic building elements of the world are discrete, from a macro perspective, human is analog, our perception and behaviors are continuous. The world around us is analog, things would not change instantly since it will require infinite energy. As long as the circuit is still interacting with the real world, an analog portion is necessary. This course focuses on modern analog design with CMOS technology. The reference books are: Razavi, B. (2017). Design of Analog CMOS Integrated Circuits (2nd ed.). New York: McGraw-Hill Education. Baker, R. J. (2010). CMOS Circuit Design, Layout, and Simulation (3rd ed.). Hoboken, NJ: IEEE Press. Chapter 1: Post not found: Note/Design-of-Analog-Integrated-Circuit/Basic-MOS-Device-Physics WIP","link":"/2020/note/Design-of-Analog-Integrated-Circuit/%E6%A8%A1%E6%8B%9F%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95/"},{"title":"VHDL 基本语法","text":"这里只列出可能要考的语句。 并行语句 并行信号赋值 (&lt;=) 使用运算符 &lt;= 为端口或信号赋值。 注意信号赋值语句在顺序语句中也存在，在进程中的信号赋值语句是顺序语句，在进程外的信号赋值语句是并行语句。 1Y &lt;= not (A and B); 条件赋值 (when...else) 优先顺序的条件判断。从第一条条件表达式开始顺序判断，直到最后一个 else。 例：实现三态门 1234architecture when_else of three_state isbegin Z &lt;= A when ENABLE = '1' else 'Z';end architecture when_else; 例：实现 2-4 译码器 1234567architecture when_else of decoder isbegin Z &lt;= &quot;0001&quot; when A = &quot;00&quot; else &quot;0010&quot; when A = &quot;01&quot; else &quot;0100&quot; when A = &quot;10&quot; else &quot;1000&quot;;end architecture when_else; 例：实现带使能的 2-4 译码器 12345678architecture when_else of decoder isbegin Z &lt;= &quot;0001&quot; when (A = &quot;00&quot; and EN = '1') else &quot;0010&quot; when (A = &quot;01&quot; and EN = '1') else &quot;0100&quot; when (A = &quot;10&quot; and EN = '1') else &quot;1000&quot; when (A = &quot;11&quot; and EN = '1') else &quot;0000&quot;;end architecture when_else; 选择赋值 (with...select) 同时进行条件判断。在结尾使用 when others 以包含全部情况。 例：实现七段显示译码器 12345678910111213141516architecture with_select of seven_seg isbegin with A select Z &lt;= &quot;1110111&quot; when &quot;0000&quot;, &quot;0010010&quot; when &quot;0001&quot;, &quot;1011101&quot; when &quot;0010&quot;, &quot;1011011&quot; when &quot;0011&quot;, &quot;0111010&quot; when &quot;0100&quot;, &quot;1101011&quot; when &quot;0101&quot;, &quot;1101111&quot; when &quot;0110&quot;, &quot;1010010&quot; when &quot;0111&quot;, &quot;1111111&quot; when &quot;1000&quot;, &quot;1111011&quot; when &quot;1001&quot;, &quot;1101101&quot; when &quot;1010&quot;|&quot;1011&quot;|&quot;1100&quot;|&quot;1101&quot;|&quot;1110&quot;|&quot;1111&quot;, &quot;0000000&quot; when others;end architecture with_select; 进程语句 (process) 进程语句本身是并行的，其内部的语句按顺序执行，因此可以按软件编程的思想实现算法。必须为进程提供完整的敏感信号表，在敏感信号表中出现的变量和信号发生变化时进程即被激活。 例：使用进程实现优先编码器 123456789101112131415161718architecture sequential of priority_encoder isbegin process (A) is begin if A(3) = '1' then Y &lt;= &quot;11&quot;; elsif A(2) = '1' then Y &lt;= &quot;10&quot;; elsif A(1) = '1' then Y &lt;= &quot;01&quot;; elsif A(0) = '1' then Y &lt;= &quot;00&quot;; else Y &lt;= &quot;00&quot;; end if; end process; VALID &lt;= '1' when A(0) = '1' or A(1) = '1' or A(2) = '1' or A(3) = '1' else '0';end architecture sequential; 元件例化语句 (component) 元件例化体现了 VHDL 模块化设计的思想，通过使用已经定义的元件的实例可以简化设计流程。 例：并联两个 8 bits 加法器实现 16 bits 加法器 12345678910111213141516171819202122232425library IEEE;use IEEE.std_logic_1164.all;use IEEE.numeric_std.all;entity BIT16ADDER is Port(CIN : in std_logic; A : in std_logic_vector(15 downto 0); B : in std_logic_vector(15 downto 0); SUM : out std_logic_vector(15 downto 0); COUT : out std_logic);end BIT16ADDER;architecture Behavioral of BIT16ADDER is component NBitAdder is generic (n : natural := 4); port(A, B : in std_logic_vector(n-1 downto 0); Cin : in std_logic; Sum : out std_logic_vector(n-1 downto 0); Cout : out std_logic); end component NBitAdder; signal CC : STD_LOGIC;begin U1: NBITADDER generic map(n =&gt; 8) port map(A(7 downto 0), B(7 downto 0), CIN, SUM(7 downto 0), CC); U2: NBITADDER generic map(n =&gt; 8) port map(A(15 downto 8), B(15 downto 8), CC, SUM(15 downto 8), COUT);end Behavioral; 顺序语句 顺序语句必须放在进程或子程序中，定义进程和子程序的算法，即并行语句包含顺序语句。 顺序赋值语句 (&lt;= 和 :=) 使用运算符 &lt;= 为端口或信号赋值，使用 := 为变量赋值。 变量的声明的赋值只能在顺序语句中进行，例如进程、函数和过程。 1variable var : std_logic := '0'; if-else 语句 if-else 是最常用的顺序语句，用于流程控制。 123456789if condition1 then block1elsif condition2 then block2elsif condition3 then block3else block4end if; case-when 语句 case-when 语句也是顺序语句，只能在进程中使用，用来选择有明确描述的信号。 例：使用 case-when 实现多路复用器。 12345678910111213architecture case_statement of mux isbeginprocess(A, B, C, D, S) begin case S is when &quot;00&quot; =&gt; Y &lt;= A; when &quot;01&quot; =&gt; Y &lt;= B; when &quot;10&quot; =&gt; Y &lt;= C; when &quot;11&quot; =&gt; Y &lt;= D; when others =&gt; null; end case; end process;end architecture case_statement;","link":"/2019/note/Digital-Integrated-Circuit/VHDL-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"VHDL 简介","text":"背景 VHDL (VHSIC Hardware Description Language, VHSIC (Very High Speed Integrated Circuits)) 是一种硬件描述语言，它可以描述硬件电路的行为，并由综合工具生成相应的网表。主流的 EDA (Electronic Design Automation) 工具都支持 VHDL，其主要的竞争对象是 Verilog HDL，VHDL 可以用于所有数字硬件设计，包括系统级设计、板级设计、ASIC、CPLD 和 FPGA 设计。 VHDL 方法论 硬件描述语言为硬件设计提供了仿真功能，无需真实硬件电路即可观察逻辑行为，错误可以在流片之前修正；同时它也具有模块化设计，能构建可重用的代码。 与一般软件编程语言不同，VHDL 代码有顺序执行和并发执行两种行为。 顺序执行 语句一个接一个被执行，与软件编程语言相同 可以覆盖先前表达式的效果 并发执行 语句同时执行 表达式出现的顺序无关紧要 适合硬件的并发性的建模 VHDL 的方法论包括 抽象 描述系统的不同部分 在抽象层，只关注必要的信息，忽略其他不重要的内容。 模块化 拆分大的组件，使用模块构建每个部分。 层级结构 用子模块构建设计，每个层级可能包含来自不同抽象层的模块。 VHDL 组件 实体和结构 实体 (Entity) 和结构 (Architecture) 是 VHDL 不可或缺的两大组件。 实体 黑盒子 描述输入输出接口和它们的类型 结构 描述电路的功能和/或结构 一个实体可以用多个结构来实现 VHDL 保留字 参考 Xilinx 文档 VHDL 标识符、空格和注释 VHDL 对大小写不敏感。 语句用分号结束。 不要覆盖预定义标识符，例如 std_logic、TIME。 可以使用任意数量的空格、回车来分隔元素。当然建议使用统一的缩进排版增强可读性。 行注释以 -- 开头，正如其他编程语言，鼓励书写规范的注释。 VHDL 常量和开路接口 未使用的组件输入和输出应指定为 open 连接到电源或地：'1' 或 '0' 例 1U1: universal port map(X, Y, open, A, '1'); VHDL Testbench Testbench 用来验证设计的正确性，位于设计层级的最顶层。它有自己的 VHDL 风格，只可用于仿真而不能被综合。 VHDL 标准库 标准逻辑包 IEEE standard logic 1164 九值逻辑枚举类型 'U' - Uninitialized 'X' - Forcing unknown '0' - Forcing 0 '1' - Forcing 1 'Z' - High impedance 'W' - Weak unknown 'L' - Weak 0 'H' - Weak 1 '-' - Don't care 标准逻辑类型的定义为 12type std_ulogic is('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-'); IEEE 1164 标准类型 std_logic 是 std_ulogic 解析后的信号类型 1subtype std_logic is resolved std_ulogic; 这个包位于 IEEE 库内，与工作库相分隔 12library IEEE;use IEEE.std_logic_1164.all; 逻辑向量类型 1type std_logic_vector is array(natural range&lt;&gt;) of std_logic; natural: 预定义子类型，表示从 0 到最大的整数 range&lt;&gt;: 指未定义的范围 例 12std_logic_vector(3 downto 0);std_logic_vector(0 to 7); 数值计算 进行标准逻辑向量的运算 12use IEEE.std_logic_arith.all;use IEEE.std_logic_unsigned.all; VHDL 描述方式 数据流描述123456789101112library IEEE;use IEEE.std_logic_1164.all;entity comb_function is port (A, B, C : in std_logic; Z : out std_logic);end entity comb_function;architecture expression of comb_function isbegin Z &lt;= (not A and B) or (A and C);end architecture expression; 结构化描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172library IEEE;use IEEE.std_logic_1164.all;entity or2 is port (X, Y : in std_logic; Z : out std_logic);end entity or2;architecture ex1 of or2 isbegin Z &lt;= X or Y;end architecture ex1;library IEEE;use IEEE.std_logic_1164.all;entity not1 is port (X : in std_logic; Z : out std_logic);end not1;architecture ex1 of not1 isbegin Z &lt;= not X;end ex1;library IEEE;use IEEE.std_logic_1164.all;entity and2 is port (X, Y : in std_logic; Z : out std_logic);end entity and2;architecture ex1 of and2 isbegin Z &lt;= X and Y;end architecture ex1;library IEEE;use IEEE.std_logic_1164.all;Entity comb_function is port (A, B, C : in std_logic; Z : out std_logic);End entity comb_function;architecture netlist of comb_function is component and2 is port (X, Y : in std_logic; Z : out std_logic); end component and2; component or2 is port (X, Y : in std_logic; Z : out std_logic); end component or2; component not1 is port (X : in std_logic; Z : out std_logic); end component not1; signal P, Q, R : std_logic;begin G1: not1 port map (A, P); G2: and2 port map (P, B, Q); G3: and2 port map (A, C, R); G4: or2 port map (Q, R, Z);end architecture netlist;","link":"/2019/note/Digital-Integrated-Circuit/VHDL-%E7%AE%80%E4%BB%8B/"},{"title":"数字集成电路设计目录","text":"课程介绍 其实有关 FPGA 和 VHDL 的内容有很多，以后可能会更深入地研究下去，但现在只是记录一些应付考试的知识点。 Chapter 0: 可编程逻辑器件 可编程逻辑阵列 (Programmable Logic Array, PLA) 的实现原理是任何组合逻辑函数都可以由积之和 (Sum of Products, SoP) 表示，通过建造大型与或门阵列和可编程内部连结，即可实现可编程组合逻辑。 常见的可编程器件主要有 可编程只读存储器 (Programmable Read Only Memory, PROM) 可编程阵列逻辑 (Programmable Array Logic, PAL) 通用阵列逻辑 (Generic Array Logic, GAL) 复杂可编程逻辑器件 (Complex Programmable Logic Device, CPLD) 现场可编程门阵列 (Field Programmable Gate Array, FPGA) FPGA / CPLD 设计流程 Chapter 1: Post not found: Note/Digital-Integrated-Circuit/组合逻辑与时序逻辑 Chapter 2: Post not found: Note/Digital-Integrated-Circuit/VHDL-简介 Chapter 3: Post not found: Note/Digital-Integrated-Circuit/VHDL-基本语法 Chapter 4: Post not found: Note/Digital-Integrated-Circuit/组合逻辑模块的-VHDL-实现","link":"/2019/note/Digital-Integrated-Circuit/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95/"},{"title":"组合逻辑与时序逻辑","text":"布尔代数基础 逻辑信号只有两个值：0 和 1 正值逻辑：0 表示低电压，1 表示高电压 基本的逻辑门：与、或、非、异或 AND: C = AB OR: C = A + B NOT: C = A' EXCLUSIVE OR: C = A ⊕ B = A'B + AB' 逻辑电路的两种表示方法：真值表和逻辑表达式 具体内容大家应该都知道这里不说了。 逻辑表达式的两种简化方法：布尔代数和卡诺图 单变量定理 X + 0 = X X * 1 = X X + 1 = 1 X * 0 = 0 X + X = X X * X = X (X')' = X X + X' = 1 X * X' = 0 二、三变量定理 X + Y = Y + X X * Y = Y * X (X + Y) + Z = X + (Y + Z) (X * Y) * Z = X * (Y * Z) X * Y+ X * Z = X * (Y + Z) (X + Y) * (X + Z) = X + Y * Z X + X * Y = X X * (X + Y) = X X * Y + X * Y' = X (X + Y) * (X + Y') = X X * Y + X' * Z + Y * Z= X * Y + X' * Z (X + Y) * (X' + Z) * (Y + Z) = (X + Y) * (X' + Z) X + X' * Y = X + Y 多变量定理 德摩根定律 卡诺图大家也懂，按真值表画，暂不提 现代硬件实现：NAND 和 NOR 根据目前的工艺，NAND 门和 NOR 门比 AND 门和 OR 门更容易制造，速度也更快。 AND-OR 逻辑可以转换为 NAND-NAND 逻辑 C = (AB)' = A' + B' OR-AND 逻辑可以转换为 NOR-NOR 逻辑 C = (A + B)' = A'B' 竞争与冒险 组合逻辑与时序逻辑的区别 组合逻辑 时序逻辑 没有存储器件，输出只由当前输入决定。 有记忆功能，输出取决于当前输入和过去的状态。 时序逻辑的两种实现 同步时序 异步时序 所有寄存器都连接至同一个时钟源，所有触发器的状态都在相同时钟沿发生变化。 触发器的时钟来源不全相同，状态变化发生在不同时钟沿。 基本组合逻辑模块 译码器 Decoder 将二进制码翻译成特定对象 编码器 Encoder 与译码器相反，将输入转换为二进制码 优先编码器 Priority encoder 多个输入有效时根据优先级编码 多路复用器 Multiplexer 单向电子开关，从多个输入中选择一个输出 比较器 Comparator 正如其名 加法器 Adder 半加器 将两个二进制比特相加，提供和及进位输出 S = X ⊕ Y Co = X * Y 全加器 将两个二进制比特和进位输入相加，产生和及进位输出 S = X ⊕ Y ⊕ Ci Co = X * Y + X * Ci + Y * Ci 波纹进位加法器 Ripple adder 级联 n 个 1 比特全加器，最坏延迟可从 LSB 直到 MSB 超前进位加法器 Carry-lookahead adder 无需等待低位的运算结果 时序逻辑 触发器和锁存器 触发器 Flip-flop 锁存器 Latch 边缘触发 电平触发 SR 锁存器 S-R latch 锁存器中最简单的一种，也是其他触发器的基本组成部分 带使能端的 SR 锁存器 S-R latch with enable D 锁存器 D latch 使能有效时，输出随输入变化 触发器 Flip-flop D 触发器 D flip-flop 只在边缘触发 下降沿触发 D 触发器 D flip-flop with negative-edge trigger 异步预置重置 D 触发器 D flip-flops with asynchronous preset and clear 同步预置重置 D 触发器 D flip-flops with synchronous preset and clear T 触发器 Trigger flip-flop 仅时钟输入，在每个上升沿变换状态 JK 触发器 JK flip-flop Q = K'Q + JQ' 三态门 Tri-state logic 输出有三种状态：0、1、高阻态 Z 基本时序逻辑模块 计数器 Counter 波纹进位计数器 Ripple counter 同步串行计数器 Synchronous serial counter 同步并行计数器 Synchronous parallel counter 移位寄存器 Shift-register","link":"/2019/note/Digital-Integrated-Circuit/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E4%B8%8E%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91/"},{"title":"组合逻辑模块的 VHDL 实现","text":"多路复用器 (Multiplexer) 下面的例子尝试构建 4 to 1 Mux。 使用 with...select 语句 12345678architecture with_select of mux isbegin with S select Y &lt;= A when &quot;00&quot;, B when &quot;01&quot;, C when &quot;10&quot;, D when others;end architecture with_select; 使用 when...else 语句 1234567architecture when_else of mux isbegin Y &lt;= A when S = &quot;00&quot; else B when S = &quot;01&quot; else C when S = &quot;10&quot; else D;end architecture when_else; 使用三态门实现 1234567architecture tri_state of mux isbegin Y &lt;= A when S = &quot;00&quot; else 'Z'; Y &lt;= B when S = &quot;01&quot; else 'Z'; Y &lt;= C when S = &quot;10&quot; else 'Z'; Y &lt;= D when S = &quot;11&quot; else 'Z';end architecture tri_state; 使用 case...when 语句 12345678910111213architecture case_when of mux isbegin process(A, B, C, D, S) is begin case S is when &quot;00&quot; =&gt; Y &lt;= A; when &quot;01&quot; =&gt; Y &lt;= B; when &quot;10&quot; =&gt; Y &lt;= C; when &quot;11&quot; =&gt; Y &lt;= D; when others =&gt; null; end case; end process;end architecture case_when; 编码器 (Encoder) 下面的例子尝试实现 4 to 2 Encoder 使用 with...select 语句 123456789architecture with_select of encoder isbegin with S select Y &lt;= &quot;00&quot; when &quot;0001&quot;, &quot;01&quot; when &quot;0010&quot;, &quot;10&quot; when &quot;0100&quot;, &quot;11&quot; when &quot;1000&quot;, &quot;00&quot; when others;end architecture with_select; 使用 when...else 语句 12345678architecture when_else of encoder isbegin Y &lt;= &quot;00&quot; when S = &quot;0001&quot; else &quot;01&quot; when S = &quot;0010&quot; else &quot;10&quot; when S = &quot;0100&quot; else &quot;11&quot; when S = &quot;1000&quot; else &quot;00&quot;;end architecture when_else; 优先编码器 (Priority encoder) 利用 when...else 语句顺序判断的特性。 123456789architecture when_else of priority_encoder isbegin Y &lt;= &quot;11&quot; when A(3) = '1' else &quot;10&quot; when A(2) = '1' else &quot;01&quot; when A(1) = '1' else &quot;00&quot; when A(0) = '1' else &quot;00&quot;; VALID &lt;= '1' when A(0) = '1' or A(1) = '1' or A(2) = '1' or A(3) = '1' else '0';end architecture when_else; 加法器 (Adder) 使用库提供的 + 运算符。 12345678910111213141516171819202122library IEEE;use IEEE.std_logic_1164.all;use IEEE.std_logic_arith.all;use IEEE.std_logic_unsigned.all;entity NBitAdder is generic (n: natural := 4); port(A, B: in std_logic_vector(n-1 downto 0); Cin : in std_logic; Sum : out std_logic_vector(n-1 downto 0); Cout : out std_logic);end entity NBitAdder;architecture behavioral of NBitAdder is signal result : std_logic_vector(n downto 0); signal carry : std_logic_vector(n downto 0);begin carry &lt;= (0 =&gt; Cin, others =&gt; '0'); result &lt;= ('0' &amp; A) + ('0' &amp; B) + carry; Sum &lt;= result(n-1 downto 0); Cout &lt;= result(n);end architecture behavioral; generic: 声明参数并指定默认值，表明其在例化中可能被赋予其他值。 &amp;: 双目运算符，级联两侧的 bits。 +: 库中对标准逻辑向量重载的加法，得到相同位数的结果，不生成进位。 乘法器 (Multiplier) 使用库提供的 * 运算符。 123456789101112131415library IEEE;use IEEE.std_logic_1164.all;use IEEE.std_logic_ARITH.all;use IEEE.std_logic_UNSIGNED.all;entity unsgnmul4 is Port (A : in std_logic_vector(3 downto 0); B : in std_logic_vector(3 downto 0); PAB : out std_logic_vector(7 downto 0));end unsgnmul4;architecture Behavioral of unsgnmul4 isbegin PAB &lt;= A * B;end Behavioral;","link":"/2019/note/Digital-Integrated-Circuit/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9D%97%E7%9A%84-VHDL-%E5%AE%9E%E7%8E%B0/"},{"title":"Digital Image Fundamentals","text":"Image Sampling and Quantization Representing Digital Image The continuous image is represented by function \\(f(s, t)\\) with two continuous variables, \\(s\\) and \\(t\\). The continuous image can be converted into a digital image, \\(f(x, y)\\), containing \\(M\\) rows and \\(N\\) columns, by sampling and quantization, where \\((x, y)\\) are discrete coordinates. The section of the real plane spanned by the coordinates of an image is called spatial domain, with \\(x\\) and \\(y\\) being referred to as spatial variables or spatial coordinates. In computer processing, the representation of a digital image is an numerical array or matrix: \\[ f(x,y)= \\begin{bmatrix} f(0, 0) &amp; f(0, 1) &amp; \\cdots &amp; f(0, N-1) \\cr f(1, 0) &amp; f(1, 1) &amp; \\cdots &amp; f(1, N-1) \\cr \\vdots &amp; \\vdots &amp; &amp; \\vdots \\cr f(M-1, 0) &amp; f(M-1, 1) &amp; \\cdots &amp; f(M-1, N-1) \\cr \\end{bmatrix} \\tag{2-9} \\] \\[ \\mathbf{A}= \\begin{bmatrix} \\mathnormal{a} _ {0, 0} &amp; \\mathnormal{a} _ {0, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {0, N-1} \\cr \\mathnormal{a} _ {1, 0} &amp; \\mathnormal{a} _ {1, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {1, N-1} \\cr \\vdots &amp; \\vdots &amp; &amp; \\vdots \\cr \\mathnormal{a} _ {M-1, 0} &amp; \\mathnormal{a} _ {M-1, 1} &amp; \\cdots &amp; \\mathnormal{a} _ {M-1, N-1} \\cr \\end{bmatrix} \\tag{2-10} \\] Each element of the matrix is called an image element, picture element, pixel, or pel. We use the terms image and pixel to denote a digital image and its elements. We define the origin of an image at the top left corner. This is a convention based on the fact that many image displays sweep an image starting at the top left and moving to the right, one row at a time. And the first element of a matrix is by convention at the top left of the array. The positive \\(x\\)-axis extends downward and the positive \\(y\\)-axis extends to the right, which is precisely the right-handed Cartesian coordinate system rotated by 90° clockwise. The center of an \\(M \\times N\\) image with origin at \\((0, 0)\\) is obtained by dividing \\(M\\) and \\(N\\) by 2 and rounding down to the nearest integer. Some programing languages (e.g., MATLAB) start indexing at 1 instead of 0. The center in that case is \\((x_c, y_c)=(\\operatorname{floor}(M/2)+1, \\operatorname{floor}(N/2)+1)\\). Obviously, the number of discrete intensity levels, \\(L\\), is usually an integer power of 2. The range of values spanned by the grey scale is referred to as the dynamic range. In digital image processing, we define the dynamic range of an image to be the ratio of the maximum measurable intensity to the minimum measurable intensity level in the system. Another concept is image contrast, which we define as the difference in intensity between the highest and lowest intensity levels in an image. The contrast ratio is the ratio of these two quantities. Linear vs. Coordinate Indexing The convention we mentioned before that uses a 2D coordinate to give a location of a pixel is referred to as coordinate indexing, or subscript indexing. Another type of indexing used intensively in programming image processing algorithm is linear indexing, which consists of a 1-D array based on computing offsets from coordinates \\((0, 0)\\). The matrix used to store a pixel could be row-major or column-major order. And there are two principal types of linear indexing correspondingly. Here is an illustration of column scanning for generating linear indices. Some Basic Relationships Between Pixels Neighbors of a pixel A pixel \\(p\\) at coordinates \\((x, y)\\) has two horizontal and two vertical neighbors with coordinates \\[(x+1, y), (x-1, y), (x, y+1), (x, y-1)\\] This set of pixels, called 4-neighbors of \\(p\\), is denoted \\(N_4(p)\\). The four diagonal neighbors of \\(p\\) have coordinates \\[(x+1, y+1), (x+1, y-1), (x-1, y+1), (x-1, y-1)\\] and are denoted \\(N_D(p)\\). These neighbors, 8 in total, are called the 8-neighbors of \\(p\\), denoted by \\(N_8(p)\\). The set of image locations of neighbors of a point \\(p\\) is called the neighborhood of \\(p\\). The neighborhood is said to be closed if it contains \\(p\\). Otherwise, the neighborhood is said to be open. Adjacency Let \\(V\\) be the set of intensity levels used to define adjacency. If we are dealing with the adjacency of pixels whose values are ranged from \\(0\\) to \\(n-1\\), set \\(V\\) can contain any subset of these \\(n\\) values. We consider three types of adjacency: 4-adjacency: Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are 4-adjacent if \\(q\\) is in the set \\(N_4( p)\\). 8-adjacency: Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are 8-adjacent if \\(q\\) is in the set \\(N_8( p)\\). m-adjacency (aka mixed adjacency): Two pixels \\(p\\) and \\(q\\) with values from \\(V\\) are m-adjacent if \\(q\\) is in \\(N_4( p)\\), or \\(q\\) is in \\(N_D( p)\\) and the set \\(N_4( p) \\cap N_4( q)\\) has no pixels whose values are from \\(V\\). Mixed adjacency is a modification of 8-adjacency, and is introduced to eliminate the ambiguities that may result from using 8-adjacency. Connectivity, Regions and Boundaries A digital path (or curve) from pixel \\(p\\) with coordinate \\((x_0, y_0)\\) to pixel \\(q\\) with coordinate \\((x_n, y_n)\\) is a sequence of distinct pixels with coordinates \\[(x_0, y_0), (x_1, y_1),\\dotsc,(x_n, y_n)\\] where points \\((x_i, y_i)\\) and \\((x_{i-1}, y_{i-1})\\) are adjacent for \\(1 \\leqslant i \\leqslant n\\). In this case, \\(n\\) is the length of the path. Notice that there are actually \\(n+1\\) pixels along the path. If \\((x_0, y_0)=(x_n, y_n)\\) the path is a closed path. 4-, 8-, and m-paths are defined depending on the type of adjacency specified. Let \\(S\\) represent a subset of pixels in an image. Two pixels \\(p\\) and \\(q\\) are said to be connected in \\(S\\) if there exists a path between them consisting entirely of pixels in \\(S\\). For any pixel \\(p\\) in \\(S\\), the set of pixels that are connected to \\(p\\) in \\(S\\) is called a connected component of \\(S\\). If it only has one component, and that component is connected, then \\(S\\) is called a connected set. Notice that the number of components is the number of sets, not pixel count. Let \\(R\\) represent a subset of pixels in an image. We call \\(R\\) a region of the image if \\(R\\) is a connected set. Two regions, \\(R_i\\) and \\(R_j\\) are said to be adjacent if their union forms a connected set. Regions that are not adjacent are said to be disjoint. We consider 4- and 8-adjacency when referring to regions. Suppose an image contains \\(K\\) disjoint regions, \\(R_k\\), \\(k=1,\\dotsc,K\\), none of which touches the image border. Let \\(R_u\\) denote the union of all the \\(K\\) regions, and let \\((R_u)^c\\) denote its complement. We call all the points in \\(R_u\\) the foreground, and all the points in \\((R_u)^c\\) the background of the image. The boundary (aka border or contour) of a region \\(R\\) is the set of pixels in \\(R\\) that are adjacent to pixels in the complement of \\(R\\). Stated another way, the border of a region is the set of pixels in the region that have at least one background neighbor. As a rule, adjacency between points in a region and its background is defined using 8-adjacency. The preceding definition sometimes is referred to as the inner border of the region to distinguish it from its outer border, which is the corresponding border in the background. If \\(R\\) happens to be an entire image, then its boundary (or border) is defined as the set of pixels in the first and last rows and columns of the image. Distance Measure For pixels \\(p\\), \\(q\\), and \\(s\\), with coordinates \\((x, y)\\), \\(u, v\\), and \\(w, z\\), respectively, \\(D\\) is a distance function or metric if \\(D(p, q)\\geq 0 \\quad \\)(\\(D(p, q)=0\\) iff \\(p=q\\)), \\(D(p, q)=D(q, p)\\), and \\(D(p, s)\\leq D(p, q) + D(q, s)\\). The Euclidean distance between \\(p\\) and \\(q\\) is defined as \\[ D_e(p,q)=\\left[(x-u)^2+(y-v)^2\\right]^{\\frac{1}{2}} \\tag{2-19} \\] Image Interpolation Interpolation is the process of using known data to estimate values at unknown locations, which is basically image resampling methods for image resizing. Work in Progress","link":"/2020/note/Image-Processing/Digital-Image-Fundamentals/"},{"title":"Image Processing Syllabus","text":"Textbook Digital Image Processing, Fourth Edition, ISBN 978-0-13-335672-4, by Rafael C. Gonzalez and Richard E. Woods, published by Pearson Education © 2018. Content Chapter 1: Digital Image Introduction Chapter 2: Digital Image Fundamentals Chapter 3: Post not found: note/Image-Processing/Intensity Transformation and Spatial Filtering Work in Progress","link":"/2020/note/Image-Processing/Image-Processing-Syllabus/"},{"title":"Intensity Transformations and Spatial Filtering","text":"Background The Basic of Intensity Transformations and Spatial Filtering \\[ g(x, y)=T[f(x, y)] \\tag{3-1} \\] \\[ s=T(r) \\tag{3-2} \\] For simplicity in notation, we use \\(s\\) and \\(r\\) to denote, respectively, the intensity of \\(g\\) and \\(f\\) at any point \\((x, y)\\). Some Basic Intensity Transformation Functions Image Negatives \\[ s=L-1-r \\tag{3-3} \\] Log Transformations \\[ s=c\\log(1+r) \\tag{3-4} \\] Power-law (Gamma) Transformations \\[ s=cr^{\\gamma} \\tag{3-5} \\] By convention, the exponent in a power-law equation is referred to as gamma [hence the use of this symbol in Eq.\\((3-5)\\)]. The process used to correct these power-law response phenomena is called gamma correction or gamma encoding. Piecewise Linear Transformation Functions Contrast Stretching Intensity-Level Slicing Bit-Plane Slicing Histogram processing Let \\(r_k\\), for \\(k=0,1,2,\\dotsc,L-1\\), denotes the intensities of an \\(L\\)-level digital image, \\(f(x,y)\\). The unnormalized histogram of \\(f\\) is defined as \\[ h(r_k)=n_k\\quad \\text{for }k=0, 1, 2,\\dotsc,L-1 \\tag{3-6} \\] where \\(n_k\\) is the number of pixels in \\(f\\) with intensity \\(r_k\\), and the subdivisions of the intensity scale are called histogram bins. Similarly, the normailzed histogram of \\(f\\) is defined as \\[ p(r_k)=\\frac{h(r_k)}{MN}=\\frac{n_k}{MN} \\tag{3-7} \\] where, as usual, \\(M\\) and \\(N\\) denote the number of image rows and columns, respectively. Mostly, we work with normalized histograms, which we refer to simply as histograms or image histograms. The components of \\(p_k\\) are estimates of the probabilities of intensity levels occurring in an image. The sum of \\(p_k\\) for all values of \\(k\\) is always 1. Histogram shape is related to image appearance. Histogram Equalization Assuming initially continuous intensity values, let the variable \\(r\\) denote the intensities of an image to be processed. As usual, we assume that \\(r\\) is in range \\([0, L-1]\\), with \\(r=0\\) representing black and \\(r=L-1\\) representing white. For \\(r\\) satisfying the conditions, we focus attention on transformations (intensity mapping) of the form \\[ s=T(r)\\quad 0\\leq r\\leq L-1 \\tag{3-8} \\] The intensity of an image can be viewed as a random variable in the interval \\([0, L-1]\\). Let \\(p_r(r)\\) and \\(p_s(s)\\) denote the PDFs of intensity values \\(r\\) and \\(s\\) in two different images. A fundamental result from probability theory is that if \\(p_r(r)\\) and \\(T(r)\\) are known, and \\(T(r)\\) is continuous and differentiable over the range of interest, then the PDF of the transformed (mapped) variable \\(s\\) can be obtained as \\[ p_s(s)=p_r(r)\\left|\\frac{dr}{ds}\\right| \\tag{3-10} \\] A transformation function of particular importance in image processing is \\[ s=T(r)=(L-1)\\int_0^rp_r(w)dw \\tag{3-11} \\] where \\(w\\) is a dummy variable of integration. The integral on the right side is the cumulative distribution function (CDF) of random variable \\(r\\). \\[ \\begin{aligned} \\frac{ds}{dr}&amp;=\\frac{T(r)}{dr}\\cr &amp;=(L-1)\\frac{dr}{r}\\left[\\int_0^rp_r(w)dw\\right]\\cr &amp;=(L-1)p_r(r) \\tag{3-12} \\end{aligned} \\] \\[ \\begin{aligned} p_s(s)&amp;=p_r(r)\\left|\\frac{dr}{ds}\\right|\\cr &amp;=p_r(r)\\left|\\frac{1}{(L-1)p_r(r)}\\right|\\cr &amp;=\\frac{1}{L-1}\\quad 0\\leq s \\leq L-1 \\tag{3-13} \\end{aligned} \\] We recognize the form of \\(p_s(s)\\) in the last line of the equation as a uniform probability density function. Thus, performing the intensity transformation in Eq.\\((3-11)\\) yields a random variable, \\(s\\), characterized by a uniform PDF. What is important is that \\(p_s(s)\\) in Eq.\\((3-13)\\) will always be uniform, independently of the form of \\(p_r(r)\\). Histogram Matching (Specification) Local Histogram Processing Fundamentals of Spatial Filtering Spatial filtering modifies an image by replacing the values of each pixel by a function od values of the pixel and its neighbors. If the operation performed on the image pixels is linear, then the filter is called linear spatial filter. Otherwise, the filter is a nonlinear spatial filter. The Mechanics of Linear Spatial Filtering A linear spatial filter performs a sum-of-product operations between a image \\(f\\) and a filter kernel, \\(w\\). The kernel is an array whose size defines the neighborhood of operation, and whose coefficients determine the nature of the filter. Other terms used to refer to a spatial filer kernel are mask, template, and window. Our focus is on kernels of odd size in both directions. In general, linear spatial filtering of an image of size \\(M \\times N\\) with a kernel of size \\(m \\times n\\) is given by the expression \\[ g(x, y)=\\sum_{s=-a}^{a}\\sum_{t=-b}^{b}w(s, t)f(x+s, y+t) \\tag{3-31} \\] where \\(x\\) and \\(y\\) are varied so the center (origin) of the kernel visits every pixel in \\(f\\) once. Spatial Correlation and Convolution Work in Progress","link":"/2020/note/Image-Processing/Intensity-Transformations-and-Spatial-Filtering/"},{"title":"Digital Image Introduction","text":"What is Digital Image Processing? Well, I think we all know what digital image processing is to some extent. So without further ado, let's jump right into it. Form Image Processing to Computer Vision A useful paradigm that considers three types of computerized processes in the continuum from image processing at one end to computer vision at the other: Low-level processes: both its inputs and outputs are images, such as image preprocessing to reduce noise, contrast enhancement, and image sharpening. Mid-level processes: the inputs generally are images, but its outputs are attributes extracted from those images, such as segmentation and classification fo individual objects. High-level processes: &quot;making sense&quot; of an ensemble of recognized objects. Fundamental Steps in Digital Image Processing Components of an Image Processing System","link":"/2020/note/Image-Processing/Introduction/"},{"title":"集成电路设计方法学总结","text":"概念 集成电路的分类 规模、集成度和工艺线宽 规模 SSI MSI LSI VLSI ULSI 集成度 几十~数百 成千~上万 几十万 几百~上千万 几千万 工艺线宽（μm） 5~10 (10) 1~5 (2) 0.5~1 (0.8) 0.1~0.5 (0.25) &lt; 0.1 (0.09) 设计方法论 手工设计（20 世纪 50~60 年代） SSI：直接手工制版图 计算机辅助设计 CAD（20 世纪 70~80 年代） MSI 和 LSI：电路图到版图设计 电子设计自动化 EDA（20 世纪 90 年代至今） LSI 和 VLSI：行为描述语言 HDL 到版图设计 面向 VDSM + SoC 的新一代 CAD 系统 VLSI、ULSI 和 SoC：软硬协同设计 IC 分类 标准 IC（通用 IC） 半定制 IC 专用 IC 摩尔定律：由 Intel 公司创始人之一的 Gordon Moore 于 1960 年提出，1965 年发表，并于 1971 年得到第一次公开验证的一条关于集成电路制造的预言，其具体表述为：集成电路的功能随着时间呈指数增长，即每过 18 个月，微处理器处理能力增加一倍而价格不变（即集成度按 18 个月翻番）。 导通集合 CON：使某位输出为 1 的输入序列的集合为该输出位的导通集合 断开集合 COFF：使某位输出为 0 的输入序列的集合为该输出位的断开集合 无关集合 CDC：是某位输出为 X 的输入序列的集合为该输出位的无关集合 Work in Progress","link":"/2021/note/Methodology-of-Integrated-Circuit-Design/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E6%80%BB%E7%BB%93/"},{"title":"VapourSynth Usage","text":"好活：https://guide.encode.moe/ 输入输出 读取视频（YUV420P8）： 12a = r&quot;D:\\video.mp4&quot;src8 = core.lsmas.LWLibavSource(a) 据说 VSEditor 像素值精度不佳，在脚本里转 RGB（RGB24）： 1res = mvf.ToRGB(src8) 截图（RGB24）： 1res = mvf.ToRGB(src8, depth=8) 预览 RGB24： 12res = mvf.Preview(src8)res.set_output() 字幕： VSFilter 1res = core.vsf.TextSub(src16, file=&quot;subtitle.ass&quot;) or VSFilterMod if subber requires it: 1res = core.vsfm.TextSubMod(src8, file=&quot;subtitle.ass&quot;) 压制流程： 1vspipe --y4m &quot;script.vpy&quot; - | x265 -D 10 --output &quot;output.hevc&quot; - 参考 比较： 12res = core.std.Interleave([src16, rip16])res = mvf.Preview(res) 查看帧信息： 1res = core.text.ClipInfo(src8) Tips： 观察 UV，需要找画面极红、极蓝的地方 Work in Progress","link":"/2021/note/Video-Scripting/VapourSynth-Usage/"},{"title":"Video Scripting Tools","text":"Python Environment Anaconda: https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ Use Python 3.9. VapourSynth Official site: http://www.vapoursynth.com/ Documentation (API4): http://www.vapoursynth.com/doc/ Documentation (API3): https://amusementclub.github.io/doc3/ Repository: https://github.com/vapoursynth/vapoursynth Use R55-API3 for backward compatibility, decompress the portable archive into the Python environment directory and overwrite all existing files. Verification 12from vapoursynth import coreprint(core.version()) or vspipe --version Plugins VCB-S archive Move python scripts to &lt;env_dir&gt;\\lib\\site-packages, Move filters to &lt;env_dir&gt;\\vapoursynth64\\plugins VSRepo: Repository: https://github.com/vapoursynth/vsrepo Database: https://vsdb.top/ Use -p for a portable VapourSynth install Plugin list: muvsfunc: Muonium's VapourSynth functions. Documentation: https://github.com/WolframRhodium/muvsfunc/wiki/muvs-tutorial mvsfunc: mawen1250's VapourSynth functions havsfunc: Holy's ported AviSynth functions for VapourSynth LSMASHSource: A general source plugin based on FFmpeg. Can open MP4, MOV, ISO base media without having to create an index file. Documentation: https://github.com/AkarinVS/L-SMASH-Works/blob/master/VapourSynth/README VapourSynth Editor Official repository: https://bitbucket.org/mystery_keeper/vapoursynth-editor YomikoR's mod: https://github.com/YomikoR/VapourSynth-Editor AkarinVS's single executable: https://github.com/AmusementClub/VapourSynth-Editor VapourSynth Preview Original: https://github.com/Endilll/vapoursynth-preview AkarinVS's mod: https://github.com/AkarinVS/vapoursynth-preview Download the repo and copy both stubs and vspreview folders to &lt;env_dir&gt;\\lib\\site-packages. 1python -m vspreview script.vpy or hit F5 in VSCode: x264 https://github.com/jpsdr/x264 x265 http://www.msystem.waw.pl/x265/ OKEGui Official repository: https://github.com/vcb-s/OKEGui Miscellaneous Tools MediaInfo MediaInfo GUI: https://mediaarea.net/en/MediaInfo/Download/Windows MediaInfo Project NG: https://github.com/vcb-s/MediainfoProjectNg VCB-S Tutorial &amp; Specification https://vcb-s.nmm-hd.org/ https://github.com/vcb-s/VCB-S_Collation Resources Doom9 is a forum featuring information on digital video and audio manipulation (mostly video). Aegisub Official repository: https://github.com/Aegisub/Aegisub wangqr's build: https://github.com/wangqr/Aegisub Daydream Cafe Edition: https://github.com/Ristellise/AegisubDC","link":"/2021/note/Video-Scripting/Video-Scripting-Tools/"},{"title":"x264 命令行选项","text":"x264 是 VideoLAN 等开发的自由开源软件库和命令行工具，用于将视频流转换为 H.264/MPEG-4 AVC 编码格式。 作为命令行工具，前端应用如 MeGUI 和 OKEGui 调用 x264.exe 来压缩视频；作为库，HandBrake 和 FFmpeg 等工具将 x264 集成其中。x264 代码仓库在 https://code.videolan.org/videolan/x264 x264 似乎没有官方在线文档，除了查看 --help，可参考 http://www.chaneru.com/Roku/HLS/X264_Settings.htm https://avidemux.org/admWiki/doku.php?id=tutorial:h.264 https://www.digital-digest.com/articles/x264_options_page1.html https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-x264.html#menc-feat-x264-encoding-options Advanced Video Coding Advanced Video Coding (AVC)，又称 H.264 或 MPEG-4 Part 10, AVC，是目前最流行的视频格式，最早于 2003 年标准化。AVC 的优势在于最广泛的支持，使用 AVC 编码的视频几乎可以在任何设备上播放。但随着技术进步，AVC 已不适合编码 4K 及以上分辨率或具备 HDR 的视频。 功能 帧类型 视频压缩技术可利用其他帧的信息来压缩某一帧。被其他帧用作参考的帧称为参考帧（reference frame）。用于根据帧在视频中的位置，压缩算法将为每帧分配一个帧类型（picture/frame types），主要分为 I、P 和 B 帧： I 帧（intra-coded picture）是一张完整的图片，压缩率最低，但不需要参考其他任何帧来解码，在播放跳转时速度最快 P 帧（predicted picture）参考出现在其之前的帧，仅保存该帧与参考帧之间的不同之处 B 帧（bidirectional predicted picture）同时参考在其之前和之后的帧 GOP IPB 帧按顺序的组合称作图像组（group of picture, GOP）。一个 GOP 以 I 帧开始，其中分布 P 和 B 帧。一个 GOP 应为可播放的单元，一个视频由各 GOP 顺序连接而成。GOP 结构可由 N 和 M 两个参数描述，GOP 大小 N 表示 GOP 开始 I 帧与下一个 GOP 开始的 I 帧之间的距离，M 表示相邻两个锚点帧（可以是 I 或 P 帧）之间的距离，或者表示为两个锚点帧之间 B 帧的最大数量。 GOP 分为 open GOP 和 closed GOP，参考这里。open GOP 允许 GOP 内的帧参考该 GOP 外的帧；closed GOP 中，帧不会参考其他 GOP 的帧。两个相邻的 IDR 帧将定义一个 closed GOP，这也就意味着，如果所有 I 帧都是 IDR 帧，则所有 GOP 都是 closed GOP；反之如果所有 I 帧都不是 IDR 帧，则有些 GOP 可能为 open GOP。 open GOP 理论上编码效率更高，x264 默认使用 closed GOP，x265 默认使用 open GOP。由于 I 帧一般都出现在场景转换处，因此 open GOP 实际上带来的提升很小。 宏块 帧通常被分割为若干宏块（macroblock），每个宏块对应一种预测类型，即节点宏块（intra macroblock）、预测宏块（predicted macroblock）和前后预测宏块（bi-predicted macroblock）。 I 帧仅包含节点宏块 P 帧可包含节点宏块和预测宏块 B 帧可包含节点宏块、预测宏块和前后预测宏块 宏块是视频编码的单元，对应一次线性块变换，在 AVC 中为离散余弦变换（discrete cosine transform, DCT），在 HEVC 中该概念发展为编码树单元（coding tree unit, CTU）。一个宏块被分为变换块作为 DCT 的输入，例如，在第一个使用宏块的编码 H.261 中，DCT 变换块大小为 8×8，对 YCbCr 4:2:0 进行编码，一个宏块大小为 16×16，包含 16×16 亮度平面采样点和 8×8 色度平面采样点，则该宏块被分为 4 个 Y 块，1 个 Cb 块和 1 个 Cr 块。 视频压缩的粒度由分块（slice）决定，一个分块是在空间上与帧内其他分块独立的区域，在编码时分块间独立。 IDR 帧 又称关键帧（keyframe），Instantaneous decoding refresh (IDR) 帧的所有分块都是 I 分块或 SI 分块，也就是说 IDR 帧是一种特殊的 I 帧。当解码进行到 IDR 帧时，所有参考帧都被忽略，即 IDR 帧解码后，后续帧的解码不再依靠 IDR 帧之前的帧。一个 GOP 的第一帧是 IDR 帧。 IDR 帧可以立即刷新参考帧缓冲，能让视频跳转更丝滑。 根据定义，I 帧不一定都是 IDR 帧，但在压缩视频时，每个 I 帧都应称为 IDR 帧，即不允许 non-IDR 帧。 帧和场 单词 frame 和 picture 一般意义相同，但 picture 是更广泛的概念。一个 picture 可指一个帧（frame）或一个场（field）： 帧（frame）指一张完整的图片 场（field）是完整画面一半的扫描线（scan line）的组合 使用模拟信号的视频可使用市电做时钟同步，但早期的视频播放媒介 CRT 显示器受频宽限制，无法按 60 Hz 或 50 Hz 的市电频率刷新完整的图像；若按半频即 30 Hz 或 25 Hz 播放，帧刷新又太慢，使得电子束扫描到图像下方时上方的像素已经变暗，导致观众观感画面闪烁。隔行扫描（interlaced scan）技术被用于解决这类问题。 隔行扫描 隔行扫描技术仅用于扫描式显示设备例如 CRT 电视。阴极射线从上到下一行一行扫描激发荧光来显示图像，一行像素即一条扫描线。逐行扫描即依次显示所有扫描线，而隔行扫描每次只传输并显示一半的扫描线，即场。一个场包含第 1、3、5... 行，即所有奇数行的扫描线，称为奇数场或前场；另一个场包含第 2、4、6... 行，即所有偶数行的扫描线，称为偶数场或后场。 隔行扫描增加了观感帧率，减少视觉闪烁。例如使用 PAL 制式，市电频率为 50 Hz 的电视，可以在有限的频宽内显示每秒 50 个场。NTSC 和 PAL 制式均先显示奇数场，再显示偶数场。 值得注意的是，隔行扫描并非是逐行扫描画面的扫描线按奇偶分为两份。前场和后场在画面空间上互补组成一幅完整的图像，即 PAL 制式下每 1/25 秒电子束点亮显示器所有的像素各一次，但时间上两者对应的内容相差 1/50 秒。隔行扫描技术需要应用在录制、传输和显示等环节，在摄像机录制视频时已经在使用隔行的方式保存视频，因此前后场的组合并非是时间上相同的图像，画面中移动的部分会产生横向的锯齿状线条；如果两场刚好是场景交换之处，则会组成两个场景同时出现的鬼影画面。 帧间预测 帧间预测（inter-picture prediction）可参考复数个帧： 允许 P 和 B 帧拥有更多参考帧，显著降低快速重复闪光、反复剪切或遮挡场景的码率 运动补偿算法可使用可变块大小，一个块最大为 16×16，最小为 4×4，亮度平面预测快大小可以是 16×16、16×8、8×16、8×8、8×4、4×8、4×4，色度平面预测块根据色度抽样设置减小大小。一个宏块内，可以有不同大小的预测快组合 可为每个宏块分配复数个运动矢量 B 帧内可使用任意宏块类型，例如节点宏块 使用六阶数字滤波器推测亮度平面半像素采样点以得到更锐利的亚像素运动补偿效果，1/4 像素的运动由半像素的线性插值得到。运动补偿可精确到 1/4 像素，对 4:2:0 采样的色度平面，这意味着运动补偿可达到 1/8 测度采样点尺寸 加权运动预测使编码器能为运动补偿加权或做偏移，对淡入、淡出和淡入淡出转换等场景提供性能提升 帧内编码 帧内编码可使用相邻块边缘做空间预测，亮度平面预测块大小可为 16×16、8×8 或者 4×4，每个宏块内只能使用其中一种。 引入整数离散余弦变换（integer discrete cosine transform, integer DCT），一种 DCT 的整数近似。 允许无损宏块编码。 灵活的隔行扫描视频编码。隔行扫描图像可有三种编码方式：将两个场合并为一个帧进行编码、两个场分别编码、将两个场合并为一个帧，但在宏块级别将一个帧宏块分为两个场宏块进行编码。前两种方式被称为图像自适应帧-场编码（picture-adaptive frame-field coding, PAFF or PicAFF），第三种方法被称为宏块自适应帧-场编码（macroblock-adaptive frame-field coding,MBAFF）： PAFF：对运动图像，将两个场分别编码更好，对非运动图像，将两场合并编码效果更好，PAFF 会根据整个图像的特点选择帧编码或是场编码 MBAFF：当图像同时存在运动区域和非运动区域时，MBAFF 合并两个场为一帧进行编码，对一个帧宏块（16×16），选择帧编码或者将其分为两个场宏块（8×16）进行场编码中更好的一个 Profiles AVC 档次（profiles）定义了编码器使用的算法和约束的组合，对应解码器需要具备的能力和额外的视频功能，如场编码、10 bits 像素等。档次越高，编码器使用的技术越复杂，对解码器的要求越高，可能带来更高的压缩率。 参考 Wikipedia Levels AVC 级别（levels）在档次的基础上增加额外的限制，标志着解码器在某一档次下应具有的解码性能。某一档次下的某一级别说明了其最高分辨率、帧率和码率。 参考 Wikipedia，例如，级别 4.2 下，视频不能超过 2048×1080@60，50000 kbits/s。 x264 命令行参数 为方便这里贴出 --fullhelp `x264.exe --fullhelp` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617x264 core:142 r2431+42 c69a006 tMod [10-bit@all X86_64]Syntax: x264 [options] -o outfile infileInfile can be raw (in which case resolution is required), or YUV4MPEG (*.y4m), or Avisynth if compiled with support (yes). or libav* formats if compiled with lavf support (yes) or ffms support (yes).Outfile type is selected by filename: .264 -&gt; Raw bytestream .mkv -&gt; Matroska .flv -&gt; Flash Video .mp4 -&gt; MP4 if compiled with GPAC or L-SMASH support (lsmash) .3gp -&gt; MP4 (branded '3gp6') .3g2 -&gt; MP4 (branded '3gp6' and '3g2a') .mov or .qt -&gt; QuickTime File Format .avi -&gt; AVI if compiled with support (yes)Output bit depth: 10 (configured at compile time)Options: -h, --help List basic options --longhelp List more options --fullhelp List all optionsExample usage: Constant quality mode: x264 --crf 24 -o &lt;output&gt; &lt;input&gt; Two-pass with a bitrate of 1000kbps: x264 --pass 1 --bitrate 1000 -o &lt;output&gt; &lt;input&gt; x264 --pass 2 --bitrate 1000 -o &lt;output&gt; &lt;input&gt; Lossless: x264 --qp 0 -o &lt;output&gt; &lt;input&gt; Maximum PSNR at the cost of speed and visual quality: x264 --preset placebo --tune psnr -o &lt;output&gt; &lt;input&gt; Constant bitrate at 1000kbps with a 2 second-buffer: x264 --vbv-bufsize 2000 --bitrate 1000 -o &lt;output&gt; &lt;input&gt;Presets: --device &lt;string&gt; Force the limits of a device(with latest driver/firmware) Overrides all settings over the limits. Multiple devices are separated by commas. Auto resize not implemented. --profile &lt;string&gt; Force the limits of an H.264 profile Overrides all settings. - high10: No lossless. Support for bit depth 8-10. - high422: No lossless. Support for bit depth 8-10. Support for 4:2:0/4:2:2 chroma subsampling. - high444: Support for bit depth 8-10. Support for 4:2:0/4:2:2/4:4:4 chroma subsampling. --profile-force Do not automatically decrease profile settings --preset &lt;string&gt; Use a preset to select encoding settings [medium] Overridden by user settings. - ultrafast: --no-8x8dct --aq-mode 0 --b-adapt 0 --bframes 0 --no-cabac --no-deblock --no-mbtree --me dia --no-mixed-refs --partitions none --rc-lookahead 0 --ref 1 --scenecut 0 --subme 0 --trellis 0 --no-weightb --weightp 0 - superfast: --no-mbtree --me dia --no-mixed-refs --partitions i8x8,i4x4 --rc-lookahead 0 --ref 1 --subme 1 --trellis 0 --weightp 1 - veryfast: --no-mixed-refs --rc-lookahead 10 --ref 1 --subme 2 --trellis 0 --weightp 1 - faster: --no-mixed-refs --rc-lookahead 20 --ref 2 --subme 4 --weightp 1 - fast: --rc-lookahead 30 --ref 2 --subme 6 --weightp 1 - medium: Default settings apply. - slow: --b-adapt 2 --direct auto --me umh --rc-lookahead 50 --ref 5 --subme 8 - slower: --b-adapt 2 --direct auto --me umh --partitions all --rc-lookahead 60 --ref 8 --subme 9 --trellis 2 - veryslow: --b-adapt 2 --bframes 8 --direct auto --me umh --merange 24 --partitions all --ref 16 --subme 10 --trellis 2 --rc-lookahead 60 - placebo: --bframes 16 --b-adapt 2 --direct auto --slow-firstpass --no-fast-pskip --me tesa --merange 24 --partitions all --rc-lookahead 60 --ref 16 --subme 11 --trellis 2 --tune &lt;string&gt; Tune the settings for a particular type of source or situation Overridden by user settings. Multiple tunings are separated by commas. Only one psy tuning can be used at a time. - film (psy tuning): --deblock -1:-1 --psy-rd &lt;unset&gt;:0.15 - animation (psy tuning): --bframes {+2} --deblock 1:1 --psy-rd 0.4:&lt;unset&gt; --aq-strength 0.6 --ref {Double if &gt;1 else 1} - touhou (psy tuning): --aq-strength 1.3 --deblock -1:-1 --partitions {p4x4 if p8x8 set} --psy-rd &lt;unset&gt;:0.2 --ref {Double if &gt;1 else 1} - grain (psy tuning): --aq-strength 0.5 --no-dct-decimate --deadzone-inter 6 --deadzone-intra 6 --deblock -2:-2 --ipratio 1.1 --pbratio 1.1 --psy-rd &lt;unset&gt;:0.25 --qcomp 0.8 - stillimage (psy tuning): --aq-strength 1.2 --deblock -3:-3 --psy-rd 2.0:0.7 - psnr (psy tuning): --aq-mode 0 --no-psy - ssim (psy tuning): --aq-mode 2 --no-psy - fastdecode: --no-cabac --no-deblock --no-weightb --weightp 0 - zerolatency: --bframes 0 --force-cfr --no-mbtree --sync-lookahead 0 --sliced-threads --rc-lookahead 0 --slow-firstpass Don't force these faster settings with --pass 1: --no-8x8dct --me dia --partitions none --ref 1 --subme {2 if &gt;2 else unchanged} --trellis 0 --fast-pskipFrame-type options: -I, --keyint &lt;integer or &quot;infinite&quot;&gt; Maximum GOP size [250] -i, --min-keyint &lt;integer&gt; Minimum GOP size [auto] --no-scenecut Disable adaptive I-frame decision --scenecut &lt;integer&gt; How aggressively to insert extra I-frames [40] --intra-refresh Use Periodic Intra Refresh instead of IDR frames -b, --bframes &lt;integer&gt; Number of B-frames between I and P [3] --b-adapt &lt;integer&gt; Adaptive B-frame decision method [1] Higher values may lower threading efficiency. - 0: Disabled - 1: Fast - 2: Optimal (slow with high --bframes) --b-bias &lt;integer&gt; Influences how often B-frames are used [0] --b-pyramid &lt;string&gt; Keep some B-frames as references [normal] - none: Disabled - strict: Strictly hierarchical pyramid - normal: Non-strict (not Blu-ray compatible) --open-gop Use recovery points to close GOPs Only available with b-frames --no-cabac Disable CABAC -r, --ref &lt;integer&gt; Number of reference frames [3] --no-deblock Disable loop filter -f, --deblock &lt;alpha:beta&gt; Loop filter parameters [0:0] --slices &lt;integer&gt; Number of slices per frame; forces rectangular slices and is overridden by other slicing options --slices-max &lt;integer&gt; Absolute maximum slices per frame; overrides slice-max-size/slice-max-mbs when necessary --slice-max-size &lt;integer&gt; Limit the size of each slice in bytes --slice-max-mbs &lt;integer&gt; Limit the size of each slice in macroblocks (max) --slice-min-mbs &lt;integer&gt; Limit the size of each slice in macroblocks (min) --tff Enable interlaced mode (top field first) --bff Enable interlaced mode (bottom field first) --constrained-intra Enable constrained intra prediction. --pulldown &lt;string&gt; Use soft pulldown to change frame rate - none, 22, 32, 64, double, triple, euro (requires cfr input) --fake-interlaced Flag stream as interlaced but encode progressive. Makes it possible to encode 25p and 30p Blu-Ray streams. Ignored in interlaced mode. --frame-packing &lt;integer&gt; For stereoscopic videos define frame arrangement - 0: checkerboard - pixels are alternatively from L and R - 1: column alternation - L and R are interlaced by column - 2: row alternation - L and R are interlaced by row - 3: side by side - L is on the left, R on the right - 4: top bottom - L is on top, R on bottom - 5: frame alternation - one view per frameRatecontrol: -q, --qp &lt;integer&gt; Force constant QP (0-81, 0=lossless) -B, --bitrate &lt;integer&gt; Set bitrate (kbit/s) --crf &lt;float&gt; Quality-based VBR (-12-51) [23.0] --rc-lookahead &lt;integer&gt; Number of frames for frametype lookahead [40] --vbv-maxrate &lt;string&gt; or &lt;integer&gt; Max local bitrate (kbit/s) [0] - auto_high444: Set the VBV maxrate to fit in the target level of High 4:4:4 Predictive Profile - auto_high422: Set the VBV maxrate to fit in the target level of High 4:2:2 Profile - auto_high10: Set the VBV maxrate to fit in the target level of High 10 Profile - auto_high: Set the VBV maxrate to fit in the target level of High Profile - auto_main: Set the VBV maxrate to fit in the target level of Main and Baseline Profile --vbv-bufsize &lt;string&gt; or &lt;integer&gt; Set size of the VBV buffer (kbit) [0] - auto_high444: Set the VBV bufsize to fit in the target level of High 4:4:4 Predictive Profile - auto_high422: Set the VBV bufsize to fit in the target level of High 4:2:2 Profile - auto_high10: Set the VBV bufsize to fit in the target level of High 10 Profile - auto_high: Set the VBV bufsize to fit in the target level of High Profile - auto_main: Set the VBV bufsize to fit in the target level of Main and Baseline Profile --vbv-init &lt;float&gt; Initial VBV buffer occupancy [0.9] --crf-max &lt;float&gt; With CRF+VBV, limit RF to this value May cause VBV underflows! --qpmin &lt;integer&gt;[:&lt;integer&gt;:&lt;integer&gt;] Set min QP of I:P:B frames [0:0:0] --qpmax &lt;integer&gt;[:&lt;integer&gt;:&lt;integer&gt;] Set max QP of I:P:B frames [81:81:81] --qpstep &lt;integer&gt; Set max QP step [4] --ratetol &lt;float&gt; Tolerance of ABR ratecontrol and VBV [1.0] --ipratio &lt;float&gt; QP factor between I and P [1.40] --pbratio &lt;float&gt; QP factor between P and B [1.30] --chroma-qp-offset &lt;integer&gt; QP difference between chroma and luma [0] --aq-mode &lt;integer&gt; AQ method [1] - 0: Disabled - 1: Variance AQ (complexity mask) - 2: Auto-variance AQ (experimental) - 3: Auto-variance AQ mod1 - 4: Auto-variance AQ mod2 --aq-strength &lt;float&gt; Reduces blocking and blurring in flat and textured areas. [1.0] --aq-sensitivity &lt;float&gt; &quot;Center&quot; of AQ curve. [10.0] - 5: most QPs are raised - 10: good general-use sensitivity - 15: most QPs are lowered --aq-ifactor &lt;float&gt; AQ strength factor of I-frames [1.00] --aq-pfactor &lt;float&gt; AQ strength factor of P-frames [1.00] --aq-bfactor &lt;float&gt; AQ strength factor of B-frames [1.00] --aq2-strength &lt;float&gt; Use 2nd AQ (Haali's AQ) algorithm for support. [0.0] 0.0: no 2nd AQ 1.1: strong 2nd AQ --aq2-sensitivity &lt;float&gt; &quot;Flatness&quot; threshold to trigger 2nd AQ [15.0] 5: applies to almost all blocks 22: only flat blocks --aq2-ifactor &lt;float&gt; 2nd AQ strength factor of I-frames [1.00] --aq2-pfactor &lt;float&gt; 2nd AQ strength factor of P-frames [1.00] --aq2-bfactor &lt;float&gt; 2nd AQ strength factor of B-frames [1.00] --aq3-mode &lt;integer&gt; 3rd AQ (OreAQ) method [0] - 0: Disabled - 1: OreAQ - 2: MixOre (experimental) --aq3-strength &lt;float&gt; Reduces blocking and blurring in bump and clear-cut areas. [0.5] &lt;Up:Down&gt; or &lt;Up1:Down1:Up2:Down2:Up3:Down3:Up4:OtherStuff&gt; Set QP up/down strength. --aq3-sensitivity &lt;float&gt; &quot;Center&quot; of 3rd AQ curve. [10.0] - 5: most QPs are raised - 10: good general-use sensitivity - 15: most QPs are lowered --aq3-ifactor &lt;Up:Down&gt; 3rd AQ strength factor of I-frames [1.0:1.0] --aq3-pfactor &lt;Up:Down&gt; 3rd AQ strength factor of P-frames [1.0:1.0] --aq3-bfactor &lt;Up:Down&gt; 3rd AQ strength factor of B-frames [1.0:1.0] --aq3-boundary &lt;int:int:int&gt; OreAQ boundary. fullrange=off: [768:256:96] fullrange=on : [820:224:36] #1: Bright-Middle #2: Middle-Dark #3: Dark-M.Dark --fade-compensate &lt;float&gt; Allocate more bits to fades [0.0] Approximate sane range: 0.0 - 1.0 (requires mb-tree) -p, --pass &lt;integer&gt; Enable multipass ratecontrol - 1: First pass, creates stats file - 2: Last pass, does not overwrite stats file - 3: Nth pass, overwrites stats file --stats &lt;string&gt; Filename for 2 pass stats [&quot;x264_2pass.log&quot;] --no-mbtree Disable mb-tree ratecontrol. --qcomp &lt;float&gt; QP curve compression [0.60] --cplxblur &lt;float&gt; Reduce fluctuations in QP (before curve compression) [20.0] --qblur &lt;float&gt; Reduce fluctuations in QP (after curve compression) [0.5] --zones &lt;zone0&gt;/&lt;zone1&gt;/... Tweak the options of regions of the video Each zone is of the form &lt;start frame&gt;,&lt;end frame&gt;,&lt;options&gt; where &lt;options&gt; is a comma separated list either q=&lt;integer&gt; (force QP) or b=&lt;float&gt; (bitrate multiplier) can only be used as the first option Other available options for use in zones are: (no-)chroma-me (no-)dct-decimate deblock=&lt;integer&gt;:&lt;integer&gt; no-deblock b-bias=&lt;integer&gt; deadzone-intra=&lt;integer&gt; (no-)fast-pskip subme=&lt;integer&gt; deadzone-inter=&lt;integer&gt; ref=&lt;integer&gt; direct=&lt;string&gt; scenecut=&lt;integer&gt; nr=&lt;integer&gt; trellis=&lt;integer&gt; (no-)mixed-refs me=&lt;string&gt; merange=&lt;integer&gt; psy-rd=&lt;float&gt;:&lt;float&gt; no-8x8dct crf=&lt;float&gt; b-pyramid=&lt;string&gt; fgo=&lt;int&gt; Limitations: The number of reference frames for a zone can never exceed what was specified with --ref scenecut can not be turned on and off; only varied if originally active (&gt;0) merange can not exceed what was originally specified if --me esa/tesa subme can't be changed if the original commandline specified it as 0 me can't be set to esa or tesa if --me was originally specified as dia, hex, or umh --qpfile &lt;string&gt; Force frametypes and QPs for some or all frames Format of each line: framenumber frametype QP QP is optional (none lets x264 choose). Frametypes: I,i,K,P,B,b. K=&lt;I or i&gt; depending on open-gop setting QPs are restricted by qpmin/qpmax.Analysis: -A, --partitions &lt;string&gt; Partitions to consider [&quot;p8x8,b8x8,i8x8,i4x4&quot;] - p8x8, p4x4, b8x8, i8x8, i4x4 - none, all (p4x4 requires p8x8. i8x8 requires --8x8dct.) --direct &lt;string&gt; Direct MV prediction mode [&quot;spatial&quot;] - none, spatial, temporal, auto --no-weightb Disable weighted prediction for B-frames --weightp &lt;integer&gt; Weighted prediction for P-frames [2] - 0: Disabled - 1: Weighted refs - 2: Weighted refs + Duplicates --me &lt;string&gt; Integer pixel motion estimation method [&quot;hex&quot;] - dia: diamond search, radius 1 (fast) - hex: hexagonal search, radius 2 - umh: uneven multi-hexagon search - esa: exhaustive search - tesa: hadamard exhaustive search (slow) --merange &lt;integer&gt; Maximum motion vector search range [16] --mvrange &lt;integer&gt; Maximum motion vector length [-1 (auto)] --mvrange-thread &lt;int&gt; Minimum buffer between threads [-1 (auto)] -m, --subme &lt;integer&gt; Subpixel motion estimation and mode decision [7] - 0: fullpel only (not recommended) - 1: SAD mode decision, one qpel iteration - 2: SATD mode decision - 3-5: Progressively more qpel - 6: RD mode decision for I/P-frames - 7: RD mode decision for all frames - 8: RD refinement for I/P-frames - 9: RD refinement for all frames - 10: QP-RD - requires trellis=2, aq-mode&gt;0 - 11: Full RD: disable all early terminations --psy-rd &lt;float:float&gt; Strength of psychovisual optimization [&quot;1.0:0.0&quot;] #1: RD (requires subme&gt;=6) #2: Trellis (requires trellis, experimental) --no-psy Disable all visual optimizations that worsen both PSNR and SSIM. --fgo &lt;int&gt; Activates Film Grain Optimization. (requires subme&gt;=7) [0] - 5: weak FGO - 15: strong FGO --no-mixed-refs Don't decide references on a per partition basis --no-chroma-me Ignore chroma in motion estimation --no-8x8dct Disable adaptive spatial transform size -t, --trellis &lt;integer&gt; Trellis RD quantization. [1] - 0: disabled - 1: enabled only on the final encode of a MB - 2: enabled on all mode decisions --no-fast-pskip Disables early SKIP detection on P-frames --no-dct-decimate Disables coefficient thresholding on P-frames --nr &lt;integer&gt; Noise reduction [0] --deadzone-inter &lt;int&gt; Set the size of the inter luma quantization deadzone [21] --deadzone-intra &lt;int&gt; Set the size of the intra luma quantization deadzone [11] Deadzones should be in the range 0 - 32. --cqm &lt;string&gt; Preset quant matrices [&quot;flat&quot;] - jvt, flat --cqmfile &lt;string&gt; Read custom quant matrices from a JM-compatible file Overrides any other --cqm* options. --cqm4 &lt;list&gt; Set all 4x4 quant matrices Takes a comma-separated list of 16 integers. --cqm8 &lt;list&gt; Set all 8x8 quant matrices Takes a comma-separated list of 64 integers. --cqm4i, --cqm4p, --cqm8i, --cqm8p &lt;list&gt; Set both luma and chroma quant matrices --cqm4iy, --cqm4ic, --cqm4py, --cqm4pc &lt;list&gt; Set individual quant matricesVideo Usability Info (Annex E):The VUI settings are not used by the encoder but are merely suggestions tothe playback equipment. See doc/vui.txt for details. Use at your own risk. --overscan &lt;string&gt; Specify crop overscan setting [&quot;undef&quot;] - undef, show, crop --videoformat &lt;string&gt; Specify video format [&quot;undef&quot;] - component, pal, ntsc, secam, mac, undef --range &lt;string&gt; Specify color range [&quot;auto&quot;] - auto, tv, pc --colorprim &lt;string&gt; Specify color primaries [&quot;undef&quot;] - undef, bt709, bt470m, bt470bg, smpte170m, smpte240m, film, bt2020 --transfer &lt;string&gt; Specify transfer characteristics [&quot;undef&quot;] - undef, bt709, bt470m, bt470bg, smpte170m, smpte240m, linear, log100, log316, iec61966-2-4, bt1361e, iec61966-2-1, bt2020-10, bt2020-12 --colormatrix &lt;string&gt; Specify color matrix setting [&quot;???&quot;] - undef, bt709, fcc, bt470bg, smpte170m, smpte240m, GBR, YCgCo, bt2020nc, bt2020c --chromaloc &lt;integer&gt; Specify chroma sample location (0 to 5) [0] --nal-hrd &lt;string&gt; Signal HRD information (requires vbv-bufsize) - none, vbr, cbr (cbr not allowed in .mp4) --filler Force hard-CBR and generate filler (implied by --nal-hrd cbr) --pic-struct Force pic_struct in Picture Timing SEI --crop-rect &lt;string&gt; Add 'left,top,right,bottom' to the bitstream-level cropping rectangleAudio: Audio options may be used if audio support is compiled in. Audio is automatically opened from the input file if supported by the demuxer. --audiofile &lt;filename&gt; Uses audio from the specified file --ademuxer &lt;string&gt; Demux audio by the specified demuxer [auto] Supported and compiled in demuxers: - auto, lavf, avs, lsmash --atrack &lt;integer&gt; Audio track number [auto] --acodec &lt;string&gt; Audio codec [auto] Available settings: - auto (select muxer default codec and its default encoder) - copy (copy source audio without transcoding) - none (disable audio) Set audio format only and automatically choose encoder - raw, Force to use specified audio encoder 'ff' prefix indicate they are supported via libavcodec - raw, --abitrate &lt;float&gt; Enables bitrate mode and set bitrate (kbits/s) --aquality &lt;float&gt; Quality-based VBR [codec-dependent default] --asamplerate &lt;integer&gt; Audio samplerate (Hz) [keep source samplerate] --acodec-quality &lt;float&gt; Codec's internal compression quality [codec specific] --aextraopt &lt;string&gt; Pass extra option to codec [codec specific] Should be comma separated &quot;name=value&quot; style Encoder specific helps: * raw encoder help Directly pass the decoded PCM samples (in native endian) to muxer. All audio options except for --acodec and --audiofile are ignored.Input/Output: -o, --output &lt;string&gt; Specify output file --muxer &lt;string&gt; Specify output container format [&quot;auto&quot;] - auto, raw, mkv, flv, mp4, 3gp, 3g2, mov, qt, avi --demuxer &lt;string&gt; Specify input container format [&quot;auto&quot;] - auto, raw, y4m, avs, lavf, ffms --decoder &lt;string&gt; Specify decoder in lavf for input video --input-fmt &lt;string&gt; Specify input file format (requires lavf support) --input-csp &lt;string&gt; Specify input colorspace format for raw input - valid csps for `raw' demuxer: i420, yv12, nv12, i422, yv16, nv16, i444, yv24, bgr, bgra, rgb - valid csps for `lavf' demuxer: yuv420p, yuyv422, rgb24, bgr24, yuv422p, yuv444p, yuv410p, yuv411p, gray, monow, monob, pal8, yuvj420p, yuvj422p, yuvj444p, xvmcmc, xvmcidct, uyvy422, uyyvyy411, bgr8, bgr4, bgr4_byte, rgb8, rgb4, rgb4_byte, nv12, nv21, argb, rgba, abgr, bgra, gray16be, gray16le, yuv440p, yuvj440p, yuva420p, vdpau_h264, vdpau_mpeg1, vdpau_mpeg2, vdpau_wmv3, vdpau_vc1, rgb48be, rgb48le, rgb565be, rgb565le, rgb555be, rgb555le, bgr565be, bgr565le, bgr555be, bgr555le, vaapi_moco, vaapi_idct, vaapi_vld, yuv420p16le, yuv420p16be, yuv422p16le, yuv422p16be, yuv444p16le, yuv444p16be, vdpau_mpeg4, dxva2_vld, rgb444le, rgb444be, bgr444le, bgr444be, gray8a, bgr48be, bgr48le, yuv420p9be, yuv420p9le, yuv420p10be, yuv420p10le, yuv422p10be, yuv422p10le, yuv444p9be, yuv444p9le, yuv444p10be, yuv444p10le, yuv422p9be, yuv422p9le, vda_vld, gbrp, gbrp9be, gbrp9le, gbrp10be, gbrp10le, gbrp16be, gbrp16le, yuva420p9be, yuva420p9le, yuva422p9be, yuva422p9le, yuva444p9be, yuva444p9le, yuva420p10be, yuva420p10le, yuva422p10be, yuva422p10le, yuva444p10be, yuva444p10le, yuva420p16be, yuva420p16le, yuva422p16be, yuva422p16le, yuva444p16be, yuva444p16le, vdpau, xyz12le, xyz12be, nv16, nv20le, nv20be, rgba64be, rgba64le, bgra64be, bgra64le, 0rgb, rgb0, 0bgr, bgr0, yuva444p, yuva422p, yuv420p12be, yuv420p12le, yuv420p14be, yuv420p14le, yuv422p12be, yuv422p12le, yuv422p14be, yuv422p14le, yuv444p12be, yuv444p12le, yuv444p14be, yuv444p14le, gbrp12be, gbrp12le, gbrp14be, gbrp14le, gbrap, gbrap16be, gbrap16le, yuvj411p, bayer_bggr8, bayer_rggb8, bayer_gbrg8, bayer_grbg8, bayer_bggr16le, bayer_bggr16be, bayer_rggb16le, bayer_rggb16be, bayer_gbrg16le, bayer_gbrg16be, bayer_grbg16le, bayer_grbg16be --output-csp &lt;string&gt; Specify output colorspace [&quot;i420&quot;] - i420, i422, i444, rgb --input-depth &lt;integer&gt; Specify input bit depth for raw input --input-range &lt;string&gt; Specify input color range [&quot;auto&quot;] - auto, tv, pc --input-res &lt;intxint&gt; Specify input resolution (width x height) --index &lt;string&gt; Filename for input index file --sar width:height Specify Sample Aspect Ratio --fps &lt;float|rational&gt; Specify framerate --seek &lt;integer&gt; First frame to encode --frames &lt;integer&gt; Maximum number of frames to encode --level &lt;string&gt; Specify level (as defined by Annex A) --level-force Force params to specifyed level --bluray-compat Enable compatibility hacks for Blu-ray support --avcintra-class &lt;integer&gt; Use compatibility hacks for AVC-Intra class - 50, 100, 200 --stitchable Don't optimize headers based on video content Ensures ability to recombine a segmented encode -v, --verbose Print stats for each frame --no-progress Don't show the progress indicator while encoding --quiet Quiet Mode --log-level &lt;string&gt; Specify the maximum level of logging [&quot;info&quot;] - none, error, warning, info, debug --stylish r2204 style progress indicator --log-file &lt;string&gt; Save log to file --log-file-level &lt;int&gt; Log-file level information [&quot;info&quot;] - none, error, warning, info, debug --psnr Enable PSNR computation --ssim Enable SSIM computation --threads &lt;integer&gt; Force a specific number of threads --demuxer-threads &lt;integer&gt; Force a specific number of threads for demuxer (lavf, ffms) --lookahead-threads &lt;integer&gt; Force a specific number of lookahead threads --sliced-threads Low-latency but lower-efficiency threading --thread-input Run Avisynth in its own thread --sync-lookahead &lt;integer&gt; Number of buffer frames for threaded lookahead --non-deterministic Slightly improve quality of SMP, at the cost of repeatability --cpu-independent Ensure exact reproducibility across different cpus, as opposed to letting them select different algorithms --asm &lt;integer&gt; Override CPU detection --no-asm Disable all CPU optimizations --dump-yuv &lt;string&gt; Save reconstructed frames --sps-id &lt;integer&gt; Set SPS and PPS id numbers [0] --aud Use access unit delimiters --force-cfr Force constant framerate timestamp generation --no-fps-correction Disable automatic NTSC fps correction --tcfile-in &lt;string&gt; Force timestamp generation with timecode file --tcfile-out &lt;string&gt; Output timecode v2 file from input timestamps --timebase &lt;int/int&gt; Specify timebase numerator and denominator &lt;integer&gt; Specify timebase numerator for input timecode file or specify timebase denominator for other input --opts &lt;integer&gt; Set level of writing options in SEI [3] - 0: no information will be written in SEI - 1: write x264 information - 2: write x264 options - 3: write x264 information and optionsMuxer specific: [mp4/3gp/3g2/mov/flv] --dts-compress Eliminate initial delay with container DTS hack [mp4/3gp/3g2/mov] --chapter &lt;string&gt; Set the chapter list from chapter format file --chpl-with-bom Add UTF-8 BOM to the chapter strings in the chapter list. (experimental) --language &lt;string&gt; Set the language by ISO639-2/T language codes --no-container-sar Disable sample aspect ratio within the container --no-remux Inhibit auto-remuxing for progressive download --force-display-size Force display region size for video --fragments Enable movie fragments structure --priming &lt;integer&gt; Specify the number of priming samples for the copied audioFiltering: --vf, --video-filter &lt;filter0&gt;/&lt;filter1&gt;/... Apply video filtering to the input file Filter options may be specified in &lt;filter&gt;:&lt;option&gt;=&lt;value&gt; format. Available filters: hqdn3d:ls,cs,lt,ct Denoises the image using mplayer's hqdn3d filter The four arguments are floats and are optional If any options are omitted, they will assume a value based on previous options that you did specify - ls = luma spatial filter strength [4.0] - cs = chroma spatial filter strength [3.0] - lt = luma temporal filter strength [6.0] - ct = chroma temporal filter strength [4.5] crop:left,top,right,bottom removes pixels from the edges of the frame pad:[left][,top][,right][,bottom][,width][,height][,red][,green][,blue] adds pixels to the frame edge default values for red, green and blue are 0 resize:[width,height][,sar][,fittobox][,csp][,method] resizes frames based on the given criteria: - resolution only: resizes and adapts sar to avoid stretching - sar only: sets the sar and resizes to avoid stretching - resolution and sar: resizes to given resolution and sets the sar - fittobox: resizes the video based on the desired constraints - width, height, both - fittobox and sar: same as above except with specified sar - csp: convert to the given csp. syntax: [name][:depth] - valid csp names [keep current]: i420, yv12, nv12, i422, yv16, nv16, i444, yv24, bgr, bgra, rgb - depth: 8 or 16 bits per pixel [keep current] note: not all depths are supported by all csps. - method: use resizer method [&quot;bicubic&quot;] - fastbilinear, bilinear, bicubic, experimental, point, - area, bicublin, gauss, sinc, lanczos, spline select_every:step,offset1[,...] apply a selection pattern to input frames step: the number of frames in the pattern offsets: the offset into the step to select a frame see: http://avisynth.org/mediawiki/Select#SelectEvery vflip vertically flips the frame yadif:[mode][,order] Deinterlaces the picture using MPlayer's yadif mode: sets the deinterlacing mode 0 - single-rate deinterlacing (default) 1 - double-rate deinterlacing (bob) 2 - single-rate deinterlacing without spacial interlacing check 3 - double-rate deinterlacing without spacial interlacing check order: forces the field order tff - top-field first bff - bottom-field first subtitles: renders subtitles using VSFilter need VSFilter64.dll --sub &lt;string&gt; Load subtitles file (used with video filter &quot;subtitles&quot;) can be called more than once to load multiple subtitles 常言道： 码率高低调 crf 暗场烂掉调 aq 噪点消失加 psy 动态糊掉加 qcomp 预设 方便日常使用，真正压制时手动指定所有选项，不需要加上预设。 --profile 默认：Not Set 强制编码器使用某一档次的能力。该选项将覆盖所有其他选项。 不指定档次或级别时编码器会自动分配，但现在都 1202 年了，不太可能有不支持 AVC High Profile, Level 5.1 的播放器，因此无需指定此选项。值得注意的是，使用 --qp 0 或 --crf 0 制作无损视频时，色度采样无论是 4:2:0、4:2:2 还是 4:4:4，输出视频的档次都是 Hi444PP，并不代表原视频的采样是 4:4:4。 --preset 默认：medium 一组编码设置，让编码器在编码速度和压缩效率之间做权衡。--preset 加在所有选项之前，可被用户指定的选项覆盖。 包括 ultrafast、superfast、veryfast、faster、fast、medium、slow、slower、veryslow、placebo，同码率下开得越高画面越好，编码也越慢，选择能接受的最慢的选项。 --tune 默认：Not Set 根据输入视频的内容类型进一步做优化，该选项加在 --preset 之后，其他选项之前，可被用户指定的选项覆盖。 可选项包括 film、animation、grain、stillimage、psnr、ssim、fastcode、zerolatency，可同时指定多个，但前六个属于 psy tuning，只能选其中一个。 仅在输入视频内容符合以上选项时使用，否则应留空。这里面 animation 是给美式动画用的，对应大面积的单色块、少纹理和光影，不适合现代日式动画。 --slow-firstpass 使用 --pass 1 时会引入额外的选项加快 first pass，该选项将禁用这些做法。因为一般用 CRF，因此不用理会此选项。 帧类型 -I, --keyint 默认：250 指定相邻两个 IDR 帧之间的最大距离。可以是整数或者 infinite，后者意味着非场景转换处不会出现 IDR 帧。 IDR 帧的特性使其作为播放跳转的描点，即关键帧。减小 keyint 使得进度条拖动更顺滑。 -i, --min-keyint 默认：auto (MIN(--keyint/10,--fps)) IDR 帧之间的最小距离，该选项最大值为 --keyint/2+1。 如果 IDR 帧之间距离可选的范围太窄，可能导致 IDR 帧放置错误。一个 IDR 帧之后与它距离大于 min-keyint 的 I 帧一定是 IDR 帧。 建议默认，或是一倍帧率。设置 --min-keyint 1，则所有 I 帧都是 IDR 帧。 -b, --bframes 默认：3 连续出现的 B 帧的最大数量。 B 帧最能节省码率，对动画尤其有效，但连续出现 B 帧可能导致欠码。 该参数越高，编码越慢，对动画一般使用 8~10。 --b-adapt 默认：1 自适应 B 帧决策方法，指导 x264 决定插入 P 帧还是 B 帧。有以下 3 种方法： 0：关闭，总是选择插入 B 帧 1：快速 2：最佳 只使用 2。 -r, --ref 默认：3 参考帧的数量，即解码帧缓冲（Decoded Picture Buffer, DPB）的大小，范围是 0~16。 该参数决定了溯块参考前后帧数半径，即可参考的帧的数量，开的越高编码时间线性增加，收益递减，对 x264 出现在到 8~10 左右，而对 x265 只需要一半。较高的参数值对静态为主或动态为主的场景帮助均不大，对 x264 可以开到 13，而 x265 一般给 3~4。 -f, --deblock 默认：0:0 环路滤波器（loop filter），也称环内去块器（inloop deblocker）的参数。参数前者为侦测到块状瑕疵之后的抹除强度（Alpha Deblocking），后者是判断块状瑕疵的阈值（Beta Deblocking）。 码率有限的情况下宏块划分不够细致，导致画面出现块状瑕疵（block），环路滤波器侦测块状瑕疵的边缘，试图抹除它。 参考这篇 Doom9 帖子详细了解环路滤波器参数的原理。 （根据这个帖子，）两个参数推荐范围为 -3~3。Alpha Deblocking 越大，抹除效果越强烈，但画面也越柔和并可能损失细节；Beta Deblocking 越大，deblocking 将向细节更多、更不平整的宏块集中。提升 Beta Deblocking 对去除振铃瑕疵（ringing artifact）有帮助，即对画面不平整的宏块施加更剧烈的抹除；降低 Beta Deblocking 有助于减少 DCT 块状瑕疵且避免画面模糊。 码率控制 编码器一般提供两种码率控制模式：恒定质量（CRF、CQP）和恒定码率（ABR/CBR），一般只使用恒定质量模式（constant quality mode, aka constant ratefactor, CRF）。 -q, --qp 默认：Not Set 让编码器使用恒定量化模式（constant quantizer mode, CQP），范围为 0~81，0 表示无损。该选项与 --crf 冲突。量化值越低，输出画面越接近原始画面。CRF 比 CQP 高级，相对也不会太慢，所以不用 CQP 模式。 bitrate 默认：Not Set 对应恒定码率模式，编码器尝试控制平均码率，该选项也与 --crf 冲突。只在遇到限制码率场合使用。 crf 默认：23.0 让编码器使用 CRF，尝试确保恒定的画面“质量”。--crf n 试图达到与 --qp n 相同的目视质量，但使用更低的码率。CRF 试图提高复杂度高或者高动态等对观众来说更不容易注意到的画面的量化值，这会降低对这类画面的码率分配，将节省的码率分给对提升目视质量更有效的画面。 CRF 比 2pass 更快，相当于跳过了 'first-pass' 的 2pass，但无法预测最终视频文件的码率。 一般动画 BDRip 会设置到 16~18。 --vbv-maxrate、--vbv-bufsize 默认分别为：0、0 视频缓冲验证（video buffering verifier, VBV）的两个参数。vbv-maxrate 设置填充 VBV 缓冲的最大速度，vbv-bufsize 指 VBV 缓冲的大小，单位为 kilobit。 两个参数的作用在于限制最高码率，可能导致欠码，仅在需要时使用。一般 vbv-bufsize 设置为所需的最高码率，vbv-maxrate 设置为 vbv-bufsize 的 90% 左右。 --qpmin、 --qpmax、--qpstep 默认分别为：0、51、4 最低、最高量化值和相邻两帧间量化值的最大差距。 --ipratio、--pbratio 默认分别为：1.40、1.30 P 帧与 I 帧、B 帧与 P 帧之间的量化值比例。大致 P 帧的量化值为 I 帧的 1.4 倍，B 帧的量化值为 P 帧的 1.3 倍。使用 mbtree （默认启用）时，--pbratio 无效，该值将被自动设置。 提高 ipratio 提高 I 帧质量，提高 pbratio 降低 B 帧质量。调整参数，如 --pbratio 1.2 防止 B 帧欠码，对 x265 比较重要。 --chroma-qp-offset 默认：0 对色度平面的量化施加一个偏置，数值可正可负。 设为 -n 即色度平面量化值比亮度平面量化值小 n。x264 在使用 psy-rd 和/或 psy-trellis 时会自动降低该值，以补偿它牺牲色度平面质量来增加亮度平面质量的做法。对 YUV420，该值默认为 -2。 使用默认的 0 即可。 --aqmode 默认：1 自适应量化（adaptive quantizer, AQ）的模式。 x264 倾向于削减细节较少的宏块的码率，例如色块平面、模糊背景的纹理。AQ 的作用是调整宏块的量化值，使码率更合理地分配到所有宏块中，即平衡线条、平面（flat area）和纹理（textured area）的码率分配。 AQ 模式包括： 0：不使用 AQ 1：可变 AQ，在帧内分配码率 2：自动可变 AQ（实验性功能），可跨帧使用 AQ 3：自动可变 AQ，mod1，针对暗场优化 4：自动可变 AQ，mod2 一般使用模式 3。 --aq-strength 默认：1.0 自适应量化的强度，作用是降低平面和纹理出现块状瑕疵或变模糊的程度，非负数。 AQ 强度越大，平面和纹理分到的码率越多，相应的线条得到的码率更少，有烂线的可能。 参考 0.8。 --no-mbtree 默认: Not Set 关闭宏块树码率控制（macroblock tree ratecontrol, mbtree）。 mbtree 跟踪宏块在帧之间的继承情况，为各宏块依据时间上的传递关系分配量化权重。 mbtree 对动态多、噪点多、线条锐利的场景效果很好，但对平静的画面起到反效果。 简单理解 --no-mbtree 相当于 crf 降低 1 左右。高码率下最好关闭 mbtree 规避附效果。日常番 + crf 小于 17 可以考虑关，crf 开到 14.5 时就可以关掉 mbtree，然后 crf + 1 继续测试。 --qcomp 默认：0.60 量化曲线的压缩系数，指画面变化时量化值变化的灵敏程度。--qcomp 0.0 为恒定码率，--qcomp 1.0 为恒定量化。 该参数越小，画面变化剧烈时量化值变化越灵敏，码率抖动越稳定；该参数越大，量化值变化越缓慢，码率随画面变化剧烈程度变化越明显。使用 mbtree 时同时影响其强度，qcomp 越高，mbtree 越弱。 观感对快速变化的画面不敏感，适当降低该参数可压缩剧烈变化的画面。 分析 -A, --partitions 默认：p8x8,b8x8,i8x8,i4x4 H.264 将画面划分为 16×16 的宏块，宏块进一步被划分为更小的分区，该选项决定分区类型和大小。分区类型根据帧类型决定，可选项有： I 帧：i8×8、i4×4 P 帧：p8×8（同时启用 p16×8、p8×16）、p4×4（同时启用 p8×4、p4×8） B 帧：b8×8（同时启用 b16×8、b8×16） 也可使用 none 和 all。选 all 让帧内搜索精度最高。 --direct 默认：spatial 设置运动向量搜索模式。none 禁用运动向量，可用的两种模式为 spatial 和 temporal，auto 使 x264 自动选择合适的方法。auto 在 2pass 中效果最佳。仅在 first pass 启用 auto 的情况下才在 second pass 中使用 auto，否则 second pass 默认使用 temporal。 推荐 auto。 --me 默认：hex 指定全像素（full-pixel，即完整像素）运动估计方法，参考这篇 Doom9 帖子，有以下五种搜索方法： dia (diamond)：菱形搜索，方向为上下左右，一次搜索半径为 1 hex (hexagon)：六边形搜索，一次搜素半径为 2 umh (uneven multi-hexagon)：非平均多六边形搜索，--merange 选项直接影响该方法的搜索半径 esa (exhaustive)：穷举法，在 --merange 指定的范围内搜索所有的运动向量 tesa (transformed exhaustive)：哈达马穷举法 这些估计方法递归地从当前最佳估计开始，向各可能的方向寻找更佳的运动向量，直到找不到更好的运动向量位为止。按五种方法的次序，它们对运动向量的搜索效果越好，同时速度也越慢。运动向量的搜索对画面影响不大，但更好的算法在同码率下画面可能更好。 在 2021 年，x264 开 tesa 已经是标配了。 --merange 默认：16 全像素运动搜索的范围半径。对 dia 和 hex，取值范围为 4~16。对 umh 以上的方法，可以开到大于 16。 该选项的选择与视频的分辨率和帧率有关。视频分辨率越大，物体在画面上移动相同距离跨域的像素越多，需要搜索范围越大；视频帧率越高，则移动相同距离所花帧数越多，可减小搜索范围。 x264 即使在 placebo 预设下 merange 也只有 24，比较适合 720p 视频。对 1080p 视频开到 32~40 是不错的选择。 -m, --subme 默认：7 设置次像素运动估计方法，有以下 12 个选项： 0：fullpel only (not recommended) 1：SAD mode decision, one qpel iteration 2：SATD mode decision 3-5：Progressively more qpel 6：RD mode decision for I/P-frames 7：RD mode decision for all frames 8：RD refinement for I/P-frames 9：RD refinement for all frames 10：QP-RD (requires --trellis=2, --aq-mode &gt; 0) 11：Full RD: disable all early terminations0. fullpel only 开越高运动估计方法越复杂，效果也越好。选默认或更好点的 10。 -psy-rd 默认：1.0:0.0 率失真优化（rate-distortion optimization, RDO）中的心理学视觉优化（psychovisual optimization），根据观感舒适优化画面，而非注重保持 PSNR 和 SSIM。参考这个 Doom9 帖子，PSY 分两部分，其一是 RD，需要 subme &gt;= 6，其二是启用 trellis。 该选项为 PSY-RD 的两个参数。前者是 PSY-RD 的强度，主要负责保留画面纹理；后者是 PSY-Trellis 的强度，在前者的基础上保留噪点和细节。 动画远没有显示录像那么多细节，推荐 0.6:0.15。对实录视频可选择 0.7~1.2:0.1~0.2。 --no-psy 关闭所有导致 PSNR 和 SSIM 下降的视觉优化。 -t, --trellis 默认：1 开启率失真优化中网格量化部分，有以下 3 种选项： 0：关闭 1：仅在宏块最终编码时启用 2：对所有决策启用 率失真优化的目的是为了平衡 mbtree 等模式决策让画面变模糊的问题。该选项需要启用 cabac（context adaptive binary arithmetic coder）。率失真优化可阻止画面劣化，但开太高会增大压缩视频的体积。 使用 2 即可。 视频播放信息 视频播放信息（video usability info）对编码器无用，仅作为对播放器的提示。 --range 默认：auto 指定色彩范围，选项有 auto、tv 和 pc。 --colorprim 默认：undef 指定 RGB 转换的原色。 --transfer 默认：undef 指定光-电转换特性，即伽马矫正。 --colormatrix 默认：undef 指定 RGB 到 YUV 转换的矩阵系数。 一般视频都是 bt709，但要注意制作标准不一的 BD 附带特典和 DVD。 输入/输出 --threads 默认：auto 大于 1 的值启用多线程编码。auto 给处理帧的线程分配 1.5 倍逻辑处理器数量，为处理分块的线程分配 1 倍逻辑处理器数量。速度收益小于线程数量的的线性增加，开太高可能带来微小的画面损失。","link":"/2021/note/Video-Scripting/x264-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/"},{"title":"x265 命令行选项","text":"x265 是 MulticoreWare 等开发的视频编码器，用于将视频流转换为 HEVC/H.265 编码格式。 x265 代码仓库在 https://bitbucket.org/multicoreware/x265_git x264 文档位于 https://x265.readthedocs.io High Efficiency Video Coding HEVC，又称 H.265 或 MPEG-H Part 2，是 AVC/H.264 的继承者。至今已是使用率第二的视频编码格式，仅次于 AVC。 功能 x265 继承了 x264 的许多功能，包括 恒定量化（CQP）、恒定质量（CRF）、平局码率（ABR）、2-pass 或 multi-pass 以及 VBV 码率控制模式，macroblock-tree 的进阶版 CU-tree，自适应量化，加权预测和心理学视觉优化等。 编码树单元 编码树单元（coding tree unit, CTU）取代了 AVC 中 16×16 的宏块，大小可扩展至 64×64。CTU 可进一步划分为 CU 区分动态和静态部分，CU 进一步划分为 PU 区分对称和非对称部分。 变换单元 HEVC 使用大小为 4×4、8×8、16×16 和 32×32 的变换单元（transform unit, TU）对预测残差进行编码。一个 CTU 可以递归地被划分为 4 个或更多 TU。 并行处理 引入 tiles 将图片分解为可独立编解码的矩形区域，方便并行处理，以及波前并行处理（wavefront parallel processing, WPP）。 Tiles 和 WPP 都是可选项，tiles 的最小高度为 64 像素，最小宽度为 256 像素，其数量根据级别决定。 熵编码 熵编码（entropy encoding）采用的是 cabac，抛弃了 cavlc。 环路滤波器 环路滤波器（loop filter）包括去块滤波器（deblocking filter）和取样自适应偏移滤波器（sample adaptive offset, SAO）。 x265 命令行选项 参考选项 12345678--y4m -D 10 --preset slower --deblock -1:-1 --ctu 32--qg-size 8 --crf 16.0 --pbratio 1.2 --cbqpoffs -2--crqpoffs -2 --no-sao --me star --subme 5 --merange 32--b-intra --limit-tu 3 --no-amp --ref 5 --weightb--keyint 240 --min-keyint 1 --bframes 8--aq-mode 3 --aq-strength 0.7 --rd 5 --psy-rd 1.5--psy-rdoq 1.0 --rdoq-level 1 --no-open-gop --rc-lookahead 80--scenecut 40 --qcomp 0.65 --no-strong-intra-smoothing Performance --asm &lt;integer:false:string&gt;, --no-asm 默认：auto-detected SIMD architectures x265 默认使用 CPU 支持的所有 SIMD 架构。AVX512 只在 4K 下有优势，而且很耗电。 --pmode, --no-pmode 默认：disabled 启用并行 mode decision。仅推荐在 x265 没有吃满 CPU 时使用。对 rd level 3 和 4，该选项在使用 --rect 时最有效果。rd 5 到 6 时一般 CPU 已经能吃满。 --pme, --no-pme 默认：disabled 启用并行运动估计。仅推荐在 x265 没有吃满 CPU 时使用。该选项没有 --pmode 那样有效果，--pme 中分配任务导致的损失可能大于并行处理带来的提升。 Profile, Level, Tier --ref &lt;1..16&gt; 默认：3 最大 L0 参考数量。与 x264 不同，开到 4 就足够。 Mode decision / Analysis --rd &lt;1..6&gt; 默认：3 RDO 在 mode decision 中的参与程度。开得越高，RDO 分析越复杂，编码速度越慢，但画质提升也越高。 一般用 5。 --ctu, -s &lt;64|32|16&gt; 默认：64 最大 CU 大小。CU 越大编码效率越高，但可能对画面的破坏越大，同时并行处理能力下降。 对 1080p，默认 64 显得过高，32 比较合适。 --b-intra, --no-b-intra 默认：disabled 启用 B 帧帧内编码，一般都开启。 --rd-refine, --no-rd-refine 默认：disabled 仅对 rd level 5 和 6 有用，让率失真优化参与帧内 CU 的 CRF 计算。 极大提高计算量但能降低码率。 --rdoq-level &lt;0|1|2&gt;、--no-rdoq-level psy-rdoq 的复杂度，0 相当于关闭 psy-rdoq，1 和 2 的区别参考文档。 该选项用 1，2 曾经能显著减少体积，但后来证实似乎会引入缺陷。 --tu-intra-depth &lt;0..4&gt;、--tu-inter-depth &lt;0..4&gt; 默认分别为：1、1 帧内或帧间 CU 中 TU 进一步分解的次数，一般会给 3~4，保证 TU 分解足够，画面细节更好。 --limit-tu &lt;0..4&gt; 默认：0 该选项可允许 TU 递归分块步骤的提前退出，提高编码速度。 0 跳过 TU 分块，1~4 依次根据不同方法设置 TU 分块次数的上限。TU 分块对画面锐利细节的压缩率比较关键，为保证画质应尽量完成 TU 分块少退出，但性能下降严重。 综合考虑使用 3。 Temporal / Motion search --me &lt;integer|string&gt; 默认：1|hex x265 的运动搜索方法，有以下 6 种： 0：dia 1：hex 2：umh 3：star 4：sea 5：full 前三个选项来自 x264，star 为三步心形散布搜索，full 是穷举，sea 是穷举的优化版。比 star 更高的搜索方法太慢不用考虑。 --subme, -m &lt;0..7&gt; 默认：2 动态估计中的次像素优化，开得越高优化步骤越多。 不推荐 subme &lt; 3，一般用 --subme 4 较为合适。 --merange &lt;integer&gt; 默认：57 运动搜索半径。默认值（57） = 默认 CTU 大小（64）- 亮度平面插值半径（4）- 最大次像素距离（2）- 一个像素（1）。 与分辨率和帧率有关，默认的 57 比较适合 4K，1080p 一般用 32 足够。 --analyze-src-pics, --no-analyze-src-pics 默认：disabled 直接使用源视频进行动态搜索，用很多时间换码率。 --weightb, --no-weight-b 默认：disabled 启用 B 帧加权预测，可在渐变场景给 B 帧更好的效果，一般开启。 Spatial / Intra option --strong-intra-smoothing, --no-strong-intra-smoothing 默认：enabled 对 P、B 块做双线性插值来降噪，用码率换质量。 一般 BDRip 在低 crf 下不会开。 Psycho-visual --psy-rd &lt;float&gt; 默认：2.0 psy-rdo 强度。一般给 2.0 左右，开的越高码率越高，画面细节保留越多。 --psy-rdoq &lt;float&gt; 默认：0.0 psy-rdoq（rate distortion optimized quantization） 是 x265 率失真优化中心理学视觉部分新引入的方法。仅在 rdoq-level 选项为 1 或 2 时有效。 psy-rdoq 和量化同时进行，目的是寻找损失小的部分进行 QP 再分配，趋向于分配至平面。 选择 --psy-rdoq 1.0。 Slice decision --open-gop, --no-open-gop 默认：enabled 允许 open GOP，使 I 帧 不一定是 IDR 帧。 open GOP 的收益不是很大，但影响播放兼容性，一般关闭。 --keyint, -I &lt;integer&gt; 默认：250 最大帧间编码帧数。一般建议 10 秒，即 24 * 10 = 240。 --min-keyint, -i &lt;integer&gt; 默认：0（auto） 最小 GOP 长度，一般设置为 1。 --bframes, -b &lt;0..16&gt; 默认：4 连续出现的 B 帧的最大数量。x265 解码压力更大，连续的 B 帧对解码要求更高。 Quality, rate control and rate distortion --lossless, --no-lossless 默认：disabled 启用真无损压缩。为压制无损视频，例如完全静止的画面，一般开 --preset veryslow、--ref 1，me/subme 开到最低，有一点压缩率。 --aq-mode &lt;0|1|2|3|4&gt; 默认：2 自适应量化模式。 3 对暗场优化，在 8-bit 和低码率 10-bit 编码时效果很好。 推荐码率够给 1，码率不算够给 3，2 不适合动画，可能适合实录。 --qg-size &lt;64|32|16|8&gt; 默认：same as maxCUSize 调整 AQ 能影响到的最大分裂程度，可以说是最小 CU 边长。 默认 64 可以提高速度，但会削弱优化效果，一般给到 8。 --cbqpoffs &lt;integer&gt;、--crqpoffs &lt;integer&gt; 默认分别为：0、0 x265 版本的 --chroma-qp-offset，x265 不会自动 -2，需要自己设定。一般给低一点，x265 对特殊纹理损伤非常大，色度平面质量很低时使用。 常见使用 -3、-3。 --ipratio &lt;float&gt;、--pbratio &lt;float&gt; 默认分别为：1.4、1.3 P 帧与 I 帧、B 帧与 P 帧间的量化值比例。 由于 x265 的 B 帧比较容易烂，而动画中 B 帧出现几率很高，我们尝试降低 pbratio 提高画质。 Loop filters --sao, --no-sao 默认：enabled 取样自适应偏移（sample adaptive offset）是 x265 引入的环路滤波器。通过采样图像编码后降低的细节偏移量，修复编码造成的 banding 和 ringing，减轻高 crf 引入这类瑕疵的影响。 BDRip 码率一般充足，不太可能引入编码造成的 banding 和 ringing，一定带一个 --no-sao 防止 SAO 造成画面问题。crf 在 19~23 左右可以用 --limit-sao，更大可开 --sao。","link":"/2021/note/Video-Scripting/x265-%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/"},{"title":"Detection and Estimation in Additive Gaussian Noise","text":"A.1 Gaussian Random Variables A.1.1 Scalar Real Gaussian Random Variables For a standard Gaussian random variable \\(w\\). The mean of \\(w\\) is zero and the variance is 1. A general Gaussian random variable \\(x\\) is of the form \\(x=\\sigma w+\\mu\\). Its probability density function (PDF) is \\[ f(x)=\\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp{\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)} \\text{,}\\quad x\\in\\real\\text{.} \\tag{A.3} \\] The random variable \\(x\\) is denoted by \\(\\mathcal{N}(\\mu, \\sigma^2)\\). The tail of the standard Gaussian random variable \\(w\\) is \\[ Q(a)\\coloneqq\\mathbb{P}{w&gt;a} \\text{.}\\tag{A.4} \\] The tail decays exponentially fast as evident by the following upper and lower bounds: \\[ \\frac{1}{\\sqrt{2\\pi a^2}}\\left(1-\\frac{1}{a^2}\\right) e^{-\\frac{a^2}{2}}&lt;Q(a)&lt;e^{-\\frac{a^2}{2}} \\text{,}\\quad a&gt;1\\text{.} \\tag{A.5} \\] An important property of Gaussianity is that it is preserved by linear transformations: linear combinations of independent Gaussian random variables are still Gaussian. If \\(x_1,\\dotsc,x_n\\) are independent and \\(x_i\\sim\\mathcal{N}(\\mu_i,\\sigma_i^2)\\), then \\[ \\sum_{i=1}^nc_ix_i\\sim \\mathcal{N}\\left(\\sum_{i=1}^nc_i\\mu_i,\\sum_{i=1}^nc_i^2\\sigma_i^2\\right) \\text{.}\\tag{A.6} \\] A.1.2 Real Gaussian Random Vectors A standard Gaussian random vector \\(\\mathbf{w}\\) is a collection of \\(n\\) independent and identically distributed (i.i.d.) standard Gaussian random variables \\(w_1,\\dotsc,w_n\\). The vector \\(\\mathbf{w}=(w_1,\\dotsc,w_n)^t\\) takes values in the vector space \\(\\real^n\\). The PDF of \\(\\mathbf{w}\\) is: \\[ f(\\mathbf{w})=\\frac{1}{\\left(\\sqrt{2\\pi}\\right)^n} \\exp{\\left(-\\frac{|\\mathbf{w}|^2}{2}\\right)} \\text{,}\\quad\\mathbf{w}\\in\\real^n\\text{.} \\tag{A.7} \\] \\(|\\mathbf{w}|\\) is the Euclidean distance from the origin to \\(\\mathbf{w}\\): \\(|\\mathbf{w}|=\\sqrt{\\sum_{i=1}^nw_i^2}\\). The PDF depends only on the magnitude of \\(\\mathbf{w}\\). Since an orthogonal transformation \\(\\mathbf{O}\\) (i.e., \\(\\mathbf{O}^t\\mathbf{O}=\\mathbf{O}\\mathbf{O}^t=\\mathbf{I}\\)) preserves the magnitude of a vector, we can immediately conclude: \\[ \\boxed{\\text{If }\\mathbf{w}\\text{ is standard Gaussian, then }\\mathbf{Ow}\\text{ is also standard Gaussian.}} \\tag{A.8} \\] What this result says is that \\(\\mathbf{w}\\) has the same distribution in any orthonormal basis. The density of the standard Gaussian vector \\(\\mathbf{w}\\) experiences isotropic behavior.","link":"/2020/note/Wireless-Communication/Detection-and-Estimation-in-Additive-Gaussian-Noise/"},{"title":"The Wireless Channel","text":"A defining characteristic of the mobile wireless channel is the variations of the channel strength over time and over frequency. The variations can be roughly divided into two types: Large-scale fading, due to path loss of signal as a function of distance and shadowing by large objects such as buildings and hills. This occurs as the mobile moves through a distance of the order of the cell size, and is typically frequency independent. Small-scale fading, due to the constructive and destructive interference of the multiple signal paths between the transmitter and receiver. This occurs at the spatial scale of the order of the carrier wavelength, and is frequency dependent. Large-scale fading is more relevant to issues such as cell-site planning. Small-scale multipath fading is more relevant to the design of reliable and efficient communication systems. Physical modeling for wireless channels Free space, fixed transmit and receive antennas It is important to observe that, as the distance r increases, the electric field decreases as \\(r^{-1}\\) and thus the power per square meter in the free space wave decreases as \\(r^{-2}\\). In response to a transmitted sinusoid \\(\\cos{2\\pi ft}\\), we can express the electric far field at time \\(t\\) as \\[ E(f, t, (r, \\theta, \\psi))=\\frac {\\alpha_s(\\theta, \\psi, f)\\cos{2\\pi f(t-r/c)}}{r} \\text{.}\\tag{2.1} \\] The far field is the field sufficiently far away from the antenna so that (2.1) is valid. For cellular systems, it is a safe assumption that the receiver is in the far field. \\((r, \\theta, \\psi)\\) represents the point \\(\\mathbf{u}\\) in space at which the electric field is being measured, where \\(r\\) is the distance from the transmit antenna to \\(\\mathbf{u}\\) and where \\((\\theta, \\psi)\\) represents the vertical and horizontal angles from the antenna to \\(\\mathbf{u}\\) respectively. The constant \\(c\\) is the speed of light, and \\(\\alpha_s(\\theta, \\psi, f)\\) is the radiation pattern of the sending antenna at frequency \\(f\\) in the direction \\((\\theta, \\psi)\\); it also contains a scaling factor to account for antenna losses. Note that the phase of the field varies with \\(fr/c\\), corresponding to the delay caused by the radiation traveling at the speed of light. Next, suppose there is a fixed receive antenna at the location \\(\\mathbf{u}=(r, \\theta, \\psi)\\). The received waveform (in the absence of noise) in response to the above transmitted sinusoid is then \\[ E_r(f, t, \\mathbf{u})=\\frac {\\alpha(\\theta, \\psi, f)\\cos{2\\pi f(t-r/c)}}{r}\\text{,} \\tag{2.2} \\] where \\(\\alpha(f, \\theta, \\psi)\\) is the product of the antenna patterns of transmit and receive antennas in the given direction. Now suppose, for the given \\(\\mathbf{u}\\), that we define \\[ H(f)\\coloneqq\\frac{\\alpha(\\theta, \\psi, f)e^{-j2\\pi fr/c}}{r} \\text{.}\\tag{2.3} \\] We then have \\(E_r(f, t, \\mathbf{u})=\\real\\left[H(f)e^{-j2\\pi ft}\\right]\\). \\((2.1)\\) and \\((2.2)\\) are both linear in the input. That is, the received field (waveform) at \\(\\mathbf{u}\\) in response to a weighted sum of transmitted waveforms is simply the weighted sum of responses to those individual waveforms. Thus, \\(H(f)\\) is the system function for an LTI (linear time-invariant) channel, and its inverse Fourier transform is the impulse response. Free space, moving antenna Next consider the fixed antenna and free space model above with a receive antenna that is moving with speed \\(v\\) in the direction of increasing distance from the transmit antenna, we have \\[ E(f, t, (r_0+vt, \\theta, \\psi))=\\frac {\\alpha_s(\\theta, \\psi, f)\\cos{2\\pi f(t-r_0/c-vt/c)}} {r_0+vt} \\text{.}\\tag{2.4} \\] We can rewrite \\(f(t-r_0/c-vt/c)\\) as \\(f(1-v/c)t-fr_0/c\\). Thus, the sinusoid at frequency \\(f\\) has been converted to a sinusoid of frequency \\(f(1-v/c)\\); there has been a Doppler shift of \\(-fv/c\\) due to the motion of the observation point. Reflecting wall, fixed antenna \\[ E_r(f,t)=\\frac{\\alpha\\cos{2\\pi f(t-r/c)}}{r} -\\frac{\\alpha\\cos{2\\pi f(t-(2d-r)/c)}}{2d-r} \\]","link":"/2020/note/Wireless-Communication/The-Wireless-Channel/"},{"title":"Wireless Communication Index","text":"Reference book Fundamentals of Wireless Communication by David Tse and Pramod Viswanath. Contents Chapter 2: Post not found: Note/Wireless-Communication/The-Wireless-Channel Appendix A: Post not found: Note/Wireless-Communication/Detection-and-Estimation-in-Additive-Gaussian-Noise","link":"/2020/note/Wireless-Communication/Wireless-Communication-Index/"},{"title":"心肌细胞生物学基础及传感器检测原理","text":"本文内容摘录自浙江大学博士学位论文《心肌细胞多参数复合传感器与系统及其在药物和毒素检测中的应用》的第二章。论文作者是浙江大学生物医学工程与仪器科学学院生物医学工程专业黎洪波博士 1，论文提交于 2018 年 4 月。 说在前面 这是Post not found: Tutorial/跨阻放大器-Transimpedance-Amplifier-简介 之前提到的实验室研究项目的参考资料之一。胡宁副教授和黎洪波博士目前都在我院生物医学电子团队工作。 心肌细胞生物学基础 心脏 (Heart) 推动血液，人类和其他动物循环系统中重要肌造器官。人类、其他哺乳类和鸟类的心脏可分为四个腔室：左右心房（上半部分）、左右心室（下班部分）。心脏搏动使静脉血回流至右心房，之后进入右心室。右心室将血液泵入肺部完成肺循环。血液离开肺回到左心房，之后由左心室推动进入主动脉，完成一个心动周期 (Cardiac cycle)。 心脏主要由心肌细胞 (Cardiomyocytes) 组成，根据功能可分为工作心肌细胞和自律心肌细胞。工作心肌细胞执行收缩。自律心肌细胞失去了收缩性，但它们的一个特点是自律性：离体的心脏仍表现出自律的收缩舒张运动，因为自律心肌细胞可自发产生和传递动作电位。 本文中，心机细胞一般指工作心肌细胞。 心机细胞的动作电位 跨膜电位 (Membrane potential) 是细胞膜内外的电压差。按惯例，细胞膜外的电压被定义为零，跨膜电位是细胞膜内电压相较细胞膜外电压的差。心肌细胞的动作电位 (Cardiac action potential) 是其跨膜电位的短暂变化。动作电位的变化是带电离子通过细胞膜上称为离子通道的蛋白质离开或进入细胞的结果。与肌肉细胞不同，心肌细胞的动作电位不是由神经细胞发起的，而是来自于自律心肌细胞。 心肌细胞的动作电位可分为 5 个时间阶段： &nbsp;&nbsp; PHYSIOLOGY OF CARDIAC CONDUCTION AND CONTRACTILITY Work in Progress","link":"/2019/note/bioelectronics/%E5%BF%83%E8%82%8C%E7%BB%86%E8%83%9E%E7%94%9F%E7%89%A9%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86/"},{"title":"软件无线电基础原理","text":"引言 软件无线电 (Software-defined radio, SDR) 的基本思想是把信号处理的部分尽可能在数字处理器中完成，而模拟前端和射频收发部分使用通用硬件实现。SDR 实现的理论基础是复基带等效定理和多采样率数字信号处理技术。 复基带等效定理 现代无线通信系统所传输的信号为数字带通信号，一个数字带通信号可以表示为 \\[ s(t)=A(t)\\cos(\\omega t+\\varphi(t)) \\tag{1.1} \\] \\(A(t)\\) 表示带通信号的包络，\\(\\varphi(t)\\) 表示信号的相位，\\((1.1)\\) 的复数表达如下 \\[ s(t)=\\operatorname{Re}{A(t)e^{j\\varphi(t)}e^{j\\omega t}}=\\operatorname{Re}{S(t)e^{j\\omega t}} \\tag{1.2} \\] 其中 \\(S(t)\\) 为复数基带信号，将其展开为两路正交基带信号 \\[ S(t)=A(t)e^{j\\varphi(t)}=A(t)\\cos(\\varphi(t))+jA(t)\\sin(\\varphi(t))=I(t)+jQ(t) \\tag{1.3} \\] 其中 \\(I\\) 是信号的同相 (in-phase) 分量，\\(Q\\) 是信号的正交 (quadrature) 分量。复数基带信号 \\(S(t)\\) 包含了带通信号 \\(s(t)\\) 的全部信息，这意味着带通信号的处理可以等效为对应复数基带信号的处理，当复数基带信号的处理完成后，通过把复数基带信号的实部和虚部分别与两路正交的同频载波相乘恢复到带通信号。这个方法被称为复基带等效定理。 I/Q 调制 那么所谓同相和正交分量到底是什么东西？首先从时域观察一个载波信号 它表明正弦信号由幅度、频率和相位决定，因此这三个参数可以用来携带信息。由于频率是相位对时间的导数，它们可统称为角度。在极坐标系中，我们可以用一个点表示一个正弦信号的瞬时值，它到原点的距离表示信号当前的幅度，它与水平轴的夹角表示角度。 时间 \\(t\\) 以 \\(\\mathrm{d}t\\) 速度增加，该点从初相位 \\(\\varphi\\) 出发，以角速度 \\(\\omega\\) 绕原点逆时针转动，期间它到原点的距离由 \\(A_c(t)\\) 决定。 --WIP-- 根据此方法进行信号处理的第一步是从接收到的信号 \\(s(t)\\) 中分离出两路正交的 \\(I\\)/\\(Q\\) 信号。首先在接收端生成一个与发送端同频同相的载波信号 \\(\\cos(\\omega t)\\) 和对该载波信号移相 90° 的信号 \\(\\sin(\\omega t)\\)，将其分别与接收到的信号相乘 \\[ \\begin{aligned} s(t)\\cos(\\omega t) &amp;= A(t)\\cos(\\omega t+\\varphi(t))\\cos(\\omega t) \\\\ &amp;= \\frac{1}{2}A(t)[\\cos(\\omega t+\\varphi(t)+\\omega t)+\\cos(\\omega t + \\varphi(t)-\\omega t)] \\\\ &amp;= \\frac{1}{2}A(t)[\\cos(2\\omega t)\\cos(\\varphi(t))-\\sin(2\\omega t)\\sin(\\varphi(t))+\\cos(\\varphi(t))] \\\\ &amp;= \\frac{1}{2}I(t)+\\frac{1}{2}I(t)\\cos(2\\omega t)+\\frac{1}{2}Q(t)\\sin(2\\omega t) \\\\ s(t)\\sin(\\omega t) &amp;= A(t)\\cos(\\omega t+\\varphi(t))\\sin(\\omega t) \\\\ &amp;= \\frac{1}{2}A(t)[\\sin(\\omega t+\\varphi(t)+\\omega t)-\\sin(\\omega t + \\varphi(t)-\\omega t)] \\\\ &amp;= \\frac{1}{2}A(t)[\\sin(2\\omega t)\\cos(\\varphi(t))+\\cos(2\\omega t)\\sin(\\varphi(t))-\\sin(\\varphi(t))] \\\\ &amp;= -\\frac{1}{2}Q(t)+\\frac{1}{2}I(t)\\sin(2\\omega t)+\\frac{1}{2}Q(t)\\cos(2\\omega t) \\end{aligned} \\] 将相乘后的信号进行低通滤波即可得到同相和正交分量。 http://www.ni.com/tutorial/4805/en/","link":"/2019/note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E8%BD%AF%E4%BB%B6%E6%97%A0%E7%BA%BF%E7%94%B5%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"},{"title":"通信原理目录","text":"课程简介 第一章：绪论 第二章：确知信号 第三章：随机过程 第四章：信道 第五章：模拟调制系统 第六章：数字基带传输系统 第七章：数字带通传输系统 第十章：信源编码 第十一章：差错控制编码 第十三章：同步原理 WIP","link":"/2019/note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%9B%AE%E5%BD%95/"},{"title":"传输线与反射","text":"引起反射的原因是什么？如何消除反射？（详细讨论每种方法的优缺点） 信号沿传输线传播时，只要瞬时阻抗突变，信号就会发生反射。反射信号的产生是为了满足交界面两侧电压和电流的连续性，表述为两个重要的边界条件，即 \\[ \\begin{aligned} V_{inc}+V_{refl}&amp;=V_{trans} \\\\ I_{inc}-I_{refl}&amp;=I_{trans} \\end{aligned} \\] 根据边界条件可以推导反射系数 \\(\\rho\\) \\[ \\rho=\\frac{V_{refl}}{V_{inc}}=\\frac{Z_2-Z_1}{Z_2+Z_1} \\] 变化的信号通过阻抗不同的两个区域时，不能满足电压和电流的连续性，为了使系统平衡，区域一中产生了反射回源端的电压，以吸收入射信号和传输信号之间不匹配的电压和电流。 消除反射的根本方法是减小阻抗突变，第一层含义是保持互连的瞬时阻抗恒定，制造阻抗可控电路板。其中几个设计规则是减小桩线长度，使用菊花链代替分支结构，使用点到点拓扑；第二层是在传输线总端进行阻抗匹配。对点到点拓扑有四种常用的端接方式；第三层是维持线性布线拓扑，线上不要有分支和桩线。 首先是使用阻抗可控传输线。目前一般采用 50Ω 特性阻抗互连，这个要求是比较容易满足的。其优点是从根源上解决阻抗突变的问题，但布线时难免会出现线宽改变、折角或过孔等阻抗突变的情况。 使用菊花链拓扑并尽可能减小桩线长度，能在非点到点拓扑中改善时延和反射，其缺点是增加了设计难度。 源端串联端接把电阻串联在驱动器端，端接电阻和驱动器内阻之和等于传输线的特性阻抗。其特点是驱动器输出电压最初到达传输线时只有端接电阻和传输线特性阻抗串联分压后剩余的一半，当反射电压返回源端时才上升到正常值。在远端，信号没有振铃。串联匹配减小反射量，降低 EMI，在各种匹配方式中能耗最小。但在源端，信号呈现台阶状，需要等待反射电压经过一个往返时间回到源端后才能升到驱动器输出电压值，因此源端不能有接收器，这种特点增大了上升边，不适用于高速传输和分布负载。 远端并联端接在接收器前并联一个与传输线特性阻抗一致的端接电阻，信号不会在接收器上反射，而是通过端接电阻到达地。串联端接可用于分布负载，吸收全部的反射波，但它把信号直接并联到地，增加了电路的功耗，也对驱动器的驱动能力提出了更高的要求。 远端戴维南端接用上拉电阻和下拉电阻构成分压以消除反射。与并联端接不同，这种方法不需要驱动器提供额外电流，因此减少了对驱动能力的要求，可获得最快的电路性能，驱动分布负载。但这种端接仍要消耗更多功率，更多元件也增加了布线难度。 远端 RC 端接在并联端接的基础上串联一个电容。端接电阻值等于特性阻抗，电容值满足 RC 时间常数大于两倍信号时延。电容的存在使端接功耗降低，可用于分布负载和总线传输，但降低了高速系统的速度。 电路板有哪些常见的不可避免的突变互连？当这些突变互连长度达到何种程度就必须采取措施？ 线的两端 封装引线 输入门电容 信号层之间的过孔 拐角 桩线 分支 测试焊盘 返回路径上的间隙 过孔区的颈状 线交叉 如果时延远小于上升边，那么多次反射将被掩盖在上升边沿中，不会对信号质量造成影响。 当传输线时延 \\(TD\\) 大于信号上升沿的 20% 时就要控制反射来避免振铃。经验法则是不需要端接的传输线长度约为 \\[ Len_{max} &lt; RT \\] 长度单位为 \\(in\\)，上升边单位为 \\(ns\\)。互连长度超过此值就要采取措施。 什么是补偿设计？其基本原则是什么？ 电路中串联回路电感是不可避免的，补偿的概念就是尽量不让信号感受到很大的感性突变，而是觉得遇到了与导线特性阻抗相匹配的一段传输线。 导线的特性阻抗是 \\(Z_0=\\sqrt{\\frac{L}{C}}\\)，则补偿的原则是在感性突变的两则各加小电容器，将其转变为一段传输线，电容值 \\(C_1=\\frac{L_1}{Z_0}\\)。对感性突变增加电容，对容性突变增加电感，补偿至传输线的特性阻抗。 如何从测量或时域仿真的波形中分辨容性突变和感性突变？ 电容器的阻抗为 \\(Z_{cap}=\\frac{RT}{C}\\)，面对上升边时，电容充电，电压变化量由大变小，其阻抗由低变高。源端和远端的信号波形为： 可见容性突变使信号下凹。 电感阻抗为 \\(Z_{ind}=\\frac{L}{RT}\\)，面对上升边，电流变化量由大变小，其阻抗由高变低。源端和远端的信号波形为： 可见感性突变使信号上凸。","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E4%BC%A0%E8%BE%93%E7%BA%BF%E4%B8%8E%E5%8F%8D%E5%B0%84/"},{"title":"时域与频域","text":"概念解析：信号带宽、测量带宽、模型带宽、互连带宽 带宽指波形频谱中最高的有效正弦波频率分量。 信号带宽：对上升边有限的数字信号而言，“有效”指的是其谐波幅度高于相同基频理想方波中对应谐波幅度的 70%，信号带宽是其频谱中谐波幅度下降为 70% 的那一点的谐波频率值。 测量带宽指测量结果有足够准确度的最高正弦波频率分量。测量带宽不同于元器件本身的可用带宽。 模型带宽指模型能被准确地用于预估实际结构真实性能的最高正弦波频率分量。 互连带宽指能被互连传输且未造成有效损耗的最高正弦波频率分量，“有效”指的是互连能够传输满足应用技术条件的正弦波频率范围。 信号带宽的近似估算法 用上升边估算带宽 用 \\(RT\\) 表示 \\(10%\\sim90%\\) 上升边时间，由实验数据分析得到直线拟合的带宽与上升边关系： \\[ BW=\\frac{0.35}{RT} \\] 用时钟频率估算带宽 对时钟信号而言，上升边不会短于脉冲长度的 \\(10%\\)： \\[ BW_{Clock}=5\\times F_{Clock} \\] 带宽对上升沿有什么影响 WIP","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E6%97%B6%E5%9F%9F%E4%B8%8E%E9%A2%91%E5%9F%9F/"},{"title":"阻抗与电器模型","text":"引言 在高速数字系统中，信号是指变化的电压或变化的电流。所有信号完整性问题都是由模拟信号与互连电气特性之间的相互作用引起的，而影响信号的关键电气特性是互连的阻抗。 阻抗定义为电压与电流之比，通常用大写字母 \\(Z\\) 表示： \\[Z=V/I\\] 当信号沿互连传播时，它将不断地探测互连的阻抗，并做出相应的反应。 简述阻抗在信号完整性分析与设计中的重要意义 在高速数字系统中，信号指变化的电压或变化的电流。信号传输中遇到的完整性问题都是由模拟信号与互连电气特性之间的相互作用引发的，而互连的阻抗是影响信号的关键电气特性之一。这说明了研究阻抗在研究互连对信号传输的影响中的必要性。 阻抗定义为电压与电流之比，这个定义可用于任何元件，如贴片电阻、去耦电容、封装中的引线和 PCB 中的线条，而且无论何种元件的阻抗，在时域和频域中的表示都是适用的。这说明了阻抗定义的普适性。 当信号沿互连传播时，它将不断地探测互连的阻抗，并做出相应的反应。因此如果在产品制造前的设计阶段就知道互连的阻抗，就能准确预估信号的失真程度，判断设计是否能满足性能指标。同理，由对性能和信号的要求可以确定互连阻抗的技术规范，如果掌握了材料特性和几何形状对互连阻抗的影响，就有依据设计拓扑结构、材料横截面，选择合适的元件让产品的设计在第一次就能达到要求。 阻抗突变引起电压信号的反射和失真的问题，两条相邻信号线条之间电场与磁场的耦合引起的信号串扰问题，芯片电流切换时在电源与地之间形成压降的问题和电磁干扰这四类基本信号完整性问题都可以用阻抗加以描述。阻抗是连接物理设计与电气性能的桥梁，是解决信号完整性问题方法学的核心。 阻抗是描述互连的电气特性的关键。它不仅可以用于描述与信号完整性相关的问题，而且还可以用于寻找信号完整性问题的解决方案和设计方法。若信号的传播路径没有阻抗突变，则可以避免不必要的失真。知道了互连的阻抗和传播时延，也就知道了它几乎所有的电气特性。这是阻抗在信号完整性分析与设计中的重要性。 概念解析：建模，实际模型、理想模型 建模是在满足准确度和带宽的要求下把所设计的物理结构转化为用理想元件构建的等效电路模型的过程。 实际模型是实际存在的事物，它们是构成现实硬件系统的互连或元件，是可以被测量的，例如贴片电阻和电容。 理想模型是具体电路元件的数学描述，具有详细准确的数学定义，电路理论可用于理想模型实现电路仿真。例如理想电阻器和电容器。","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E9%98%BB%E6%8A%97%E4%B8%8E%E7%94%B5%E5%99%A8%E6%A8%A1%E5%9E%8B/"},{"title":"高速电路设计与信号完整性分析目录","text":"课程介绍 随着时钟频率的不断提高，信号完整性 (Signal Integrity) 成为产品开发的关键问题。课程主要介绍理解和解决信号完整性 (SI) 和电源完整性 (PI) 问题的基本原理。 第一章：信号完整性分析概论 电流总是以回路形式存在 电流总是趋向阻抗最小的路线 第二章：Post not found: Note/高速电路设计与信号完整性分析/时域与频域 第三章：Post not found: Note/高速电路设计与信号完整性分析/阻抗与电器模型 第四章：电阻的物理基础 第五章：电容的物理基础 第六章：电感的物理基础 第七章：传输线的物理基础 第八章：Post not found: Note/高速电路设计与信号完整性分析/传输线与反射 第九章：有损线、上升边退化与材料特性 第十章：传输线的串扰 第十一章：差分对与差分阻抗 第十二章：S 参数在信号完整性中的应用 第十三章：电源分配网络 WIP","link":"/2019/note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90%E7%9B%AE%E5%BD%95/"},{"title":"HFSS Cheat Sheet","text":"HFSS is a full-wave electromagnetic (EM) field simulator for arbitrary 3D volumetric passive device modeling. HFSS employs the finite element method (FEM) for EM simulation. View Ctrl + D - Fit all Ctrl + Shift + D - Fit selection (assign this in Keyboard Shortcuts &gt; View &gt; Fit Selection) Mouse Middle or Alt + Drag on object - Rotate in 3D Mouse Middle or Alt + Drag close to the edge of the view window - Rotate camera Shift + Drag - Pan Alt + Shift + Drag - Dynamic zoom Hold Alt and double click Mouse Primary on locations shown below to rotate to predefined views: Ctrl + A - Select all Ctrl + Shift + A - Deselect all F6 / F7 - Wire frame / Smooth shaded Modeller B - Select face/object behind current selection F - Face select mode O - Object select mode E - Edge select mode V - Vertices select mode General Ctrl + 0 - Cascade windows Ctrl + 1 - Tile windows horizontally Ctrl + 2 - Tile windows vertically HFSS Design Process Solution Type Driven Model: calculates the model-based S-parameters. THe S-matrix solutions will be expressed in terms of the incident and reflected powers of waveguide modes. Driven Terminal: calculates the terminal-based S-parameters of multi-conductor transmission line ports. The S-matrix solutions will be expressed in terms of terminal voltages and currents. Eigenmode: calculate the eigenmodes, or resonances, of a structure. The Eigenmode solver finds the resonant frequencies od the structure and the fields at those resonant frequencies. Convergence Driven Model: Delta S for model S-parameters. Driven Terminal: Delta S for the single-ended or differential nodal S-parameters. Eigenmode: Delta F.","link":"/2021/note/Antenna/HFSS/HFSS-Cheat-Sheet/"},{"title":"HFSS Scripting","text":"Introduction to Desktop Scripting Using scripts is a fast, effective way to accomplish tasks you want to repeat. When you execute a script, the commands in the script are performed. You can write a script using any text editor or you can record a script from within the HFSS interface. After recording the script from within HFSS, you can then modify it if necessary using a text editor. HFSS Scripting Guide Recording in HFSS HFSS offers several scripting methods: Visual Basic Scripting Edition: Based on Microsoft Visual Basic programming language JavaScript: Interfaces with HFSS via Microsoft COM methods IronPython: A Python implementation written in C# targeting Microsoft's .NET framework, abandoned by Microsoft in late 2010 Automated Simulation Process HFSS command-line syntax: 'HFSS15'1hfss &lt;option&gt; &lt;runcommand&gt; &lt;project name/script name&gt; 'ANSYS Electronic Desktop'1ansysedt ... Example: 123456789101112131415from pathlib import pathimport oshfss_exe = Path(r'path_to_hfss_exe')assert hfss_exe.exists()hfss_path = str(hfss_exe)option = '-RunScriptAndExit'script = Path(r'path_to_script')assert script.exists()script_path = str(script)try: os.system(''.join([hfss_path, option, script_path]))except: ... IronPython Implementation Script Objects HFSS15 oAnsoftApplication - representing the entire application oDesktop - representing the desktop ANSYS EDT 123import ScriptEnvScriptEnv.Initialize('Ansoft.ElectronicsDesktop')oDesktop.RestoreWindow()","link":"/2021/note/Antenna/HFSS/HFSS-Scripting/"},{"title":"HFSS 偶极子天线仿真","text":"建模 现在我们仿真偶极子天线。其结构可建模为两个沿 y 轴放置的金属圆柱体，两者之间连接馈电接口。 设置仿真频率为 2.4 GHz，添加 50 点频率扫描，范围是 2 GHz ~ 3 GHz。 分析 方向图 铅锤面方向图 水平面方向图 方向图说明了偶极子天线的特性：其增益在位于中心垂直于天线指向的平面上最大，在 \\(\\varphi\\) 各方向上增益相同。 反射系数 以馈电接口处的反射系数为匹配效果的标准，天线的长度和半径是优化设计的目标。 \\(S\\) 参数中，设端口 2 匹配时，端口 1 的归一化输入电压为 \\(a_1\\)，反射波电压为 \\(b_1\\)，输入反射系数定义为 \\[ S_{11}=\\frac{b_1}{a_1} \\] 馈电接口处反射系数越低则传递到天线的能量越多。认为 \\(S_{11}\\) 小于 -10 dB 时接口于天线匹配。比较不同天线长度和半径来寻找最佳匹配结果。 天线半径对反射系数 -10dB 带宽的影响 天线半径的观测范围是 0.5 mm ~ 1.5 mm。对不同的天线半径，上限频率大致相同而下限频率差异较大。在观测范围内天线半径越大则 -10 dB 带宽越大，谐振频率略有下降。 天线长度对谐振频率的影响 天线长度的观测范围是 22 mm ~ 32 mm。观察反射系数曲线最低点即谐振点。在观测范围内谐振频率随天线长度增加而降低，反射系数增大。 考虑不同长度和半径的 9 种组合：","link":"/2020/note/Antenna/HFSS/HFSS-%E5%81%B6%E6%9E%81%E5%AD%90%E5%A4%A9%E7%BA%BF%E4%BB%BF%E7%9C%9F/"},{"title":"HFSS 矩形波导仿真","text":"在 Ansys HFSS (High Frequency Structure Simulator) 中可使用有限元法求解电磁场，现在我们借助 HFSS 15 仿真矩形金属波导中的场分布。 矩形波导中的场 矩形金属波导只有一个导体，电磁波在中间空腔内传播。由于金属波导没有自由电荷和传导电流，无法传输 TEM 波。一般情况下，只需要 \\(E_z\\) 和 \\(H_z\\) 中一个为零即可满足边界条件，因此只能存在 TE 波和 TM 波。 建立如下的矩形波导模型。 设矩形波导的宽边长度为 \\(a\\)，窄边长度为 \\(b\\)。电磁波沿 \\(z\\) 方向传播。 TE 波 对 TE 波，\\(E_z=0\\) 而 \\(H_z=H_{oz}(x,y)e^{-j\\beta z}\\neq 0\\)，只有纵向磁场，满足边界条件 \\[ \\left.\\frac{\\partial H_z}{\\partial \\mathbf{n}}\\right|_S=0 \\tag{2-1-22} \\] 其中 \\(S\\) 表示波导周界，\\(\\mathbf{n}\\) 是边界法向单位矢量。 矩形波导 TE 波纵向磁场的基本解为 \\[ H_z=H_{mn}\\cos(\\frac{m\\pi}{a}x)\\cos(\\frac{n\\pi}{b}y)e^{-j\\beta z} \\tag{2-2-8} \\] 由式 \\((2-2-10)\\) 可得矩形波导 \\(\\text{TE} _ \\text{mn}\\) 模的截止波数为 \\[ k^2 _ \\text{cmn}=\\left(\\frac{m\\pi}{a}\\right)^2+\\left(\\frac{n\\pi}{b}\\right)^2 \\tag{2-2-15} \\] 对应截止波长 \\[ \\lambda _ {\\text{cTE} _ {\\text{mn}}}=\\frac{2\\pi}{k _ \\text{cmn}}=\\lambda _ \\text{c} \\tag{2-2-15} \\] 只有当工作波长 \\(\\lambda\\) 小于某个模式的截止波长 \\(\\lambda _ \\text{c}\\) 时，这个模式才可在波导中传输。主模 \\(\\text{TE} _ \\text{10}\\) 模是最常用的模式，下面分析该模式的场分布。 HFSS 仿真 定义矩形波导尺寸，\\(a=0.03\\text{m}\\)，\\(b=0.02\\text{m}\\)。 金属管壁是理想导体，其表面是电场等势面，设置 Perfect E 边界条件。 在 \\(z=0\\) 处设置激励 Wave Port 作为电磁波输入口。\\(\\text{TE} _ \\text{10}\\) 模已经是矩形波导的最低次模，只需设置仿真一个模式。 各模式的截止波长和截止频率如下 模式 截止波长 截止频率 \\(\\text{TE} _ \\text{10}\\) 0.06m 5GHz \\(\\text{TE} _ \\text{01}\\) 0.04m 7.5GHz \\(\\text{TE} _ \\text{11}\\) 0.033m 9GHz 设置求解频率为 \\(f=10\\text{GHz}\\)，以上各个模式都能够传播。这里只显示最低模式。 行波状态 设置波导终端边界条件为辐射面，电磁波离开辐射面后不再返回，即终端匹配。 将 \\(m=1\\)，\\(n=0\\)，\\(k_\\text{c}=\\pi/a\\) 代入 \\((2-2-10)\\) 可得场强与 \\(y\\) 无关。在没有反射的情况下，电磁波沿 \\(z\\) 方向按行波传播；沿 \\(x\\) 方向，\\(E_y\\)、\\(H_x\\) 最大值在同截面出现，与 \\(H_z\\) 有 90° 的相位差，电磁波沿横向呈驻波分布。 由于沿 \\(y\\) 方向场强相同，只需观察表面场，如下为电场幅值分布。 0° 90° 可见仿真结果符合理论预期。相邻的电场幅值点一个是最大值一个是最小值，第一个幅值点与第三个幅值点的距离为波导波长： \\[ \\lambda _ \\text{g}=\\frac{2\\pi}{\\beta}=\\frac{\\lambda}{\\sqrt{1-(\\lambda/2a)^2}}=0.035\\text{m} \\tag{2-2-24} \\] 驻波状态 终端边界条件为 Perfect E 时相当于终端短路，电场必为零。电磁波全部反射形成驻波，终端为电压波节点。 0° 90° 终端边界条件为 Perfect H 时相当于终端开路，电磁波也呈纯驻波分布。终端为电压波腹点。 0° 90° 波腹点与波节点之间距离为 \\(\\lambda _ \\text{g}/4\\)，因为反射波与入射波叠加，因此驻波状态电场幅值明显高于行波状态，但由于该模型中反射波与入射波存在相位差，因此幅值小于行波幅值的 2 倍。","link":"/2020/note/Antenna/HFSS/HFSS-%E7%9F%A9%E5%BD%A2%E6%B3%A2%E5%AF%BC%E4%BB%BF%E7%9C%9F/"}],"tags":[{"name":"Analog","slug":"Analog","link":"/tags/Analog/"},{"name":"vapoursynth","slug":"vapoursynth","link":"/tags/vapoursynth/"},{"name":"changelog","slug":"changelog","link":"/tags/changelog/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"info","slug":"info","link":"/tags/info/"},{"name":"QR Code","slug":"QR-Code","link":"/tags/QR-Code/"},{"name":"electronic","slug":"electronic","link":"/tags/electronic/"},{"name":"robot","slug":"robot","link":"/tags/robot/"},{"name":"antenna","slug":"antenna","link":"/tags/antenna/"},{"name":"HFSS","slug":"HFSS","link":"/tags/HFSS/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Hyper-V","slug":"Hyper-V","link":"/tags/Hyper-V/"},{"name":"YouTube","slug":"YouTube","link":"/tags/YouTube/"},{"name":"subtitle","slug":"subtitle","link":"/tags/subtitle/"},{"name":"Aegisub","slug":"Aegisub","link":"/tags/Aegisub/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"config","slug":"config","link":"/tags/config/"},{"name":"transcript","slug":"transcript","link":"/tags/transcript/"},{"name":"sensor","slug":"sensor","link":"/tags/sensor/"},{"name":"sequence","slug":"sequence","link":"/tags/sequence/"},{"name":"limit","slug":"limit","link":"/tags/limit/"},{"name":"课程目录","slug":"课程目录","link":"/tags/%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"name":"DRA","slug":"DRA","link":"/tags/DRA/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"CMOS","slug":"CMOS","link":"/tags/CMOS/"},{"name":"VHDL","slug":"VHDL","link":"/tags/VHDL/"},{"name":"syllabus","slug":"syllabus","link":"/tags/syllabus/"},{"name":"Digital logic","slug":"Digital-logic","link":"/tags/Digital-logic/"},{"name":"Info","slug":"Info","link":"/tags/Info/"},{"name":"x264","slug":"x264","link":"/tags/x264/"},{"name":"x265","slug":"x265","link":"/tags/x265/"},{"name":"normal distribution","slug":"normal-distribution","link":"/tags/normal-distribution/"},{"name":"fading","slug":"fading","link":"/tags/fading/"},{"name":"SDR","slug":"SDR","link":"/tags/SDR/"},{"name":"bandwidth","slug":"bandwidth","link":"/tags/bandwidth/"},{"name":"impedance","slug":"impedance","link":"/tags/impedance/"},{"name":"model","slug":"model","link":"/tags/model/"},{"name":"wave guide","slug":"wave-guide","link":"/tags/wave-guide/"}],"categories":[{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Video Scripting","slug":"Note/Video-Scripting","link":"/categories/Note/Video-Scripting/"},{"name":"Design of Analog Integrated Circuit","slug":"Note/Design-of-Analog-Integrated-Circuit","link":"/categories/Note/Design-of-Analog-Integrated-Circuit/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"History","slug":"History","link":"/categories/History/"},{"name":"Log","slug":"Log","link":"/categories/Log/"},{"name":"Tip","slug":"Tip","link":"/categories/Tip/"},{"name":"Walk-through","slug":"Walk-through","link":"/categories/Walk-through/"},{"name":"Tutorial","slug":"Tutorial","link":"/categories/Tutorial/"},{"name":"Bioinformatics","slug":"Tutorial/Bioinformatics","link":"/categories/Tutorial/Bioinformatics/"},{"name":"新时代中国特色社会主义理论与实践","slug":"History/新时代中国特色社会主义理论与实践","link":"/categories/History/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"name":"Advanced Mathematics","slug":"Note/Advanced-Mathematics","link":"/categories/Note/Advanced-Mathematics/"},{"name":"Language Reference","slug":"Note/Language-Reference","link":"/categories/Note/Language-Reference/"},{"name":"Digital Integrated Circuit","slug":"Note/Digital-Integrated-Circuit","link":"/categories/Note/Digital-Integrated-Circuit/"},{"name":"Image Processing","slug":"Note/Image-Processing","link":"/categories/Note/Image-Processing/"},{"name":"Methodology of Integrated Circuit Design","slug":"Note/Methodology-of-Integrated-Circuit-Design","link":"/categories/Note/Methodology-of-Integrated-Circuit-Design/"},{"name":"Wireless Communication","slug":"Note/Wireless-Communication","link":"/categories/Note/Wireless-Communication/"},{"name":"Bioelectronics","slug":"Note/Bioelectronics","link":"/categories/Note/Bioelectronics/"},{"name":"通信原理","slug":"Note/通信原理","link":"/categories/Note/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"},{"name":"高速电路设计与信号完整性分析","slug":"Note/高速电路设计与信号完整性分析","link":"/categories/Note/%E9%AB%98%E9%80%9F%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/"}]}